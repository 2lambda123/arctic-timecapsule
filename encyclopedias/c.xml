<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikibooks</sitename>
    <dbname>enwikibooks</dbname>
    <base>https://en.wikibooks.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.16</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikibooks</namespace>
      <namespace key="5" case="first-letter">Wikibooks talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="102" case="first-letter">Cookbook</namespace>
      <namespace key="103" case="first-letter">Cookbook talk</namespace>
      <namespace key="108" case="first-letter">Transwiki</namespace>
      <namespace key="109" case="first-letter">Transwiki talk</namespace>
      <namespace key="110" case="first-letter">Wikijunior</namespace>
      <namespace key="111" case="first-letter">Wikijunior talk</namespace>
      <namespace key="112" case="first-letter">Subject</namespace>
      <namespace key="113" case="first-letter">Subject talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>C Programming/Print version</title>
    <ns>0</ns>
    <id>90742</id>
    <revision>
      <id>3355132</id>
      <parentid>3354762</parentid>
      <timestamp>2017-12-29T07:46:16Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <comment>Update</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3020" xml:space="preserve">{{print version notice|C Programming|C Programming/Print version}}  
{{print version cover}}

= Why learn C? =
{{:C Programming/Why learn C?}}
= History =
{{:C Programming/History}}
= What You Need Before You Can Learn =
{{:C Programming/What you need before you can learn}}
= Obtaining a Compiler =
{{:C Programming/Obtaining a compiler}}

= Beginning C =
= Intro Exercise =
{{:C Programming/Intro exercise}}
= Preliminaries =
{{:C Programming/Preliminaries}} 
= Basics of Compilation =
{{:C Programming/Basics of compilation}} 
= Programming Structure and Style =
{{:C Programming/Structure and style}} 
= Variables =
{{:C Programming/Variables}}
= Simple Input and Output =
{{:C Programming/Simple input and output}} 
= Operators and type casting =
{{:C Programming/Operators and type casting}}
= Arrays and Strings =
{{:C Programming/Arrays and strings}}
= Program Flow Control =
{{:C Programming/Program flow control}}
= Procedures and Functions =
{{:C Programming/Procedures and Functions}}
= Standard Libraries =
{{:C Programming/Standard libraries}}
= Beginning exercises =
{{:C Programming/Beginning exercises}}

= Intermediate C =
= Advanced Data Types =
{{:C Programming/Advanced data types}}
= Pointers and Relationship to Arrays =
{{:C Programming/Pointers and arrays}}
= Memory Management =
{{:C Programming/Memory management}}
= Error Handling =
{{:C Programming/Error handling}}
= File I/O =
{{:C Programming/File IO}}
= String Manipulation =
{{:C Programming/String manipulation}}
= Further Math =
{{:C Programming/Further math}}
= Libraries =
{{:C Programming/Libraries}}

= Advanced C =
= Common Practices =
{{:C Programming/Common practices}}
= Preprocessor Directives and Macros =
{{:C Programming/Preprocessor directives and macros}}
= Sockets and Networking (UNIX) =
{{:C Programming/Networking in UNIX}}
= Serialization and X-Macros =
{{:C Programming/Serialization}}
= Coroutines =
{{:C Programming/Coroutines}}

= C and beyond =
= Particularities of C =
{{:C Programming/Particularities of C}}
= C Trigraph =
{{:C Programming/C trigraph}}
= Language Overloading and Extensions =
{{:C Programming/Language overloading and extensions}}
= Combining Languages =
{{:C Programming/Mixing languages}}
= Object Oriented Programming: The GObject System =
{{:C Programming/GObject}}

= Computer Programming =
The following articles are C adaptations from articles of the [[Computer programming]] book. 

= Statements =
{{:C Programming/Statements}}

= Reference Tables =
This section has some tables and lists of C entities.
= Standard Library Reference =
{{:C Programming/Standard library reference}}
= Language Reference =
{{:C Programming/Language Reference}}
= Platform Reference =
{{:C Programming/Platform reference}}
= POSIX Reference =
{{:C Programming/POSIX Reference}}
= GNU C Library Reference =
{{:C Programming/GNU C Library Reference}}
= MS Windows Reference =
{{:C Programming/MS Windows Reference}}
= C Compilers Reference List =
{{:C Programming/C Compilers Reference List}}

{{BookCat}}</text>
      <sha1>llvhz0l1sq45ks7y0evrmi4zow5wxia</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Advanced data types</title>
    <ns>0</ns>
    <id>1935</id>
    <revision>
      <id>3588633</id>
      <parentid>3588629</parentid>
      <timestamp>2019-10-21T21:42:57Z</timestamp>
      <contributor>
        <username>Keymusic</username>
        <id>2910724</id>
      </contributor>
      <comment>/* Structs */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5757" xml:space="preserve">{{TODO|Add information and a section about recursive and cyclic mutually-inclusive data structures.}}

{{C Programming/Navigation|Beginning exercises|Pointers and arrays}}

In the chapter [[../Variables|Variables]] we looked at the primitive data types. However ''advanced'' data types allow us greater flexibility in managing data in our program.

== Structs ==

Structs are data types made of variables of other data types (possibly including other structs).  They are used to group pieces of information into meaningful units, and also permit some constructs not possible otherwise.  The variables declared in a struct are called "members".  One defines a struct using the &lt;code&gt;struct&lt;/code&gt; keyword. For example:

&lt;syntaxhighlight lang="c"&gt;
struct mystruct {
    int int_member;
    double double_member;
    char string_member[25];
} struct_var;
&lt;/syntaxhighlight&gt;

&lt;code&gt;struct_var&lt;/code&gt; is a variable of type &lt;code&gt;struct mystruct&lt;/code&gt;, which we declared along with the definition of the new &lt;code&gt;struct mystruct&lt;/code&gt; data type.  More commonly, struct variables are declared after the definition of the struct, using the form:

&lt;syntaxhighlight lang="c"&gt;
struct mystruct struct_var;
&lt;/syntaxhighlight&gt;

It is often common practice to make a ''type synonym'' so we don't have to type "struct mystruct" all the time. C allows us the possibility to do so using a &lt;code&gt;typedef&lt;/code&gt; statement, which aliases a type:

&lt;syntaxhighlight lang="c"&gt;
typedef struct {
    // ...
} Mystruct;
&lt;/syntaxhighlight&gt;

The &lt;code&gt;struct&lt;/code&gt; itself is an ''incomplete'' type (by the absence of a name on the first line), but it is aliased as &lt;code&gt;Mystruct&lt;/code&gt;.  Then the following may be used:

&lt;syntaxhighlight lang="c"&gt;
Mystruct struct_var;
&lt;/syntaxhighlight&gt;

The members of a struct variable may be accessed using the member access operator &lt;code&gt;.&lt;/code&gt; (a dot) or the indirect member access operator &lt;code&gt;-&gt;&lt;/code&gt; (an arrow) if the struct variable is a pointer:

&lt;syntaxhighlight lang="c"&gt;
struct_var.int_member = 0;
struct_var-&gt;int_number = 0; // this statement is equivalent to: (*struct_var).int_number = 0;
&lt;/syntaxhighlight&gt;

Structs may contain not only their own variables but may also contain variables pointing to to other structs. This allows a recursive definition, which is very powerful when used with pointers:

&lt;syntaxhighlight lang="c"&gt;
struct restaurant_order {
    char description[100];
    double price;
    struct restaurant_order *next_order;
};
&lt;/syntaxhighlight&gt;

This is an implementation of the [[w:Linked list|linked list]] data structure.  Each node (a restaurant order) is pointing to one other node.  The linked list is terminated on the last node (in our example, this would be the last order) whose &lt;code&gt;next_order&lt;/code&gt; variable would be assigned to &lt;code&gt;NULL&lt;/code&gt;.

A recursive struct definition can be tricky when used with &lt;code&gt;typedef&lt;/code&gt;.  It is not possible to declare a struct variable inside its own type by using its aliased definition, since the aliased definition by &lt;code&gt;typedef&lt;/code&gt; does not exist before the &lt;code&gt;typedef&lt;/code&gt; statement is evaluated:

&lt;syntaxhighlight lang="c"&gt;
typedef struct Mystruct {
    // ...
    struct Mystruct *pointer; // Mystruct *pointer; would cause a compile-time error
} Mystruct;
&lt;/syntaxhighlight&gt;

The size of a struct type is at least the sum of the sizes of all its members. But a compiler is free to insert padding bytes between the struct members to align the members to certain constraints. For example, a struct containing of a char and a float will occupy 8 bytes on many 32bit architectures.

== Unions ==

The definition of a union is similar to that of a struct.  The difference between the two is that in a struct, the members occupy different areas of memory, but in a union, the members occupy the same area of memory.  Thus, in the following type, for example:

&lt;syntaxhighlight lang="c"&gt;
union {
    int i;
    double d;
} u;
&lt;/syntaxhighlight&gt;

The programmer can access either &lt;code&gt;u.i&lt;/code&gt; or &lt;code&gt;u.d&lt;/code&gt;, but not both at the same time. Since &lt;code&gt;u.i&lt;/code&gt; and &lt;code&gt;u.d&lt;/code&gt; occupy the same area of memory, modifying one modifies the value of the other, sometimes in unpredictable ways.

The size of a union is the size of its largest member.

== Enumerations ==

Enumerations are artificial data types representing associations between labels and integers.  Unlike structs or unions, they are not composed of other data types.  An example declaration:

&lt;syntaxhighlight lang="c"&gt;
enum color {
    red,
    orange,
    yellow,
    green,
    cyan,
    blue,
    purple,
} crayon_color;
&lt;/syntaxhighlight&gt;

In the example above, red equals 0, orange equals 1, ... and so each subsequent label is by 1 larger that the previous one.  It is possible to assign values to labels within the integer range, but they must be a literal.

Similar declaration syntax that applies for structs and unions also applies for enums.  Also, one ''normally'' doesn't need to be concerned with the integers that labels represent:

&lt;syntaxhighlight lang="c"&gt;
enum weather weather_outside = rain;
&lt;/syntaxhighlight&gt;

This peculiar property makes enums especially convenient in switch-case statements:

&lt;syntaxhighlight lang="c"&gt;
enum weather {
    sunny,
    windy,
    cloudy,
    rain,
} weather_outside;

// ...

switch (weather_outside) {
case sunny:
    wear_sunglasses();
    break;
case windy:
    wear_windbreaker();
    break;
case cloudy:
    get_umbrella();
    break;
case rain:
    get_umbrella();
    wear_raincoat();
    break;
}
&lt;/syntaxhighlight&gt;

{{C Programming/Navigation|Beginning exercises|Pointers and arrays}}

[[de:C-Programmierung: Komplexe Datentypen]]
[[fr:Programmation C/Types avancés]]
[[pl:C/Typy złożone]]</text>
      <sha1>c4pzrcz72liupils72hqrhnhhj8hccr</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Arrays and strings</title>
    <ns>0</ns>
    <id>573</id>
    <revision>
      <id>3522425</id>
      <parentid>3522424</parentid>
      <timestamp>2019-03-07T10:08:03Z</timestamp>
      <contributor>
        <username>XXBlackburnXx</username>
        <id>1402334</id>
      </contributor>
      <comment>Undid revision 3522424 by [[Special:Contributions/182.76.21.122|182.76.21.122]] ([[User talk:182.76.21.122|discuss]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7399" xml:space="preserve">{{C Programming/Navigation|Simple math|Control}}

Arrays in C act to store related data under a single variable name with an index, also known as a ''subscript''.  It is easiest to think of an array as simply a list or ordered grouping for variables of the same type.  As such, arrays often help a programmer organize collections of data efficiently and intuitively.

Later we will consider the concept of a ''pointer'', fundamental to C, which extends the nature of the array (array can be termed as a constant pointer). For now, we will consider just their declaration and their use.

== Arrays ==

C arrays are declared in the following form:

&lt;source lang="text"&gt;
type name[number of elements];
&lt;/source&gt;

For example, if we want an array of six integers (or whole numbers), we write in C:
&lt;source lang="c"&gt;
int numbers[6];
&lt;/source&gt;

For a six character array called ''letters'',

&lt;source lang="c"&gt;
char letters[6];
&lt;/source&gt;

and so on.

You can also initialize as you declare. Just put the initial elements in curly brackets separated by commas as the initial value:

&lt;source lang="text"&gt;
type name[number of elements]={comma-separated values}
&lt;/source&gt;

For example, if we want to initialize an array with six integers, with &lt;tt&gt;0, 0, 1, 0, 0, 0&lt;/tt&gt; as the initial values:
&lt;source lang="c"&gt;
int point[6]={0,0,1,0,0,0};
&lt;/source&gt;

Though when the array is initialized as in this case, the array dimension may be omitted, and the array will be automatically sized to hold the initial data:
&lt;source lang="c"&gt;
int point[]={0,0,1,0,0,0};
&lt;/source&gt;
This is very useful in that the size of the array can be controlled by simply adding or removing initializer elements from the definition without the need to adjust the dimension.

If the dimension is specified, but not all elements in the array are initialized, the remaining elements will contain a value of 0. This is very useful, especially when we have very large arrays.

&lt;source lang="c"&gt;
int numbers[2000]={245};
&lt;/source&gt;

The above example sets the first value of the array to 245, and the rest to 0.

If we want to access a variable stored in an array, for example with the above declaration, the following code will store a 1 in the variable &lt;tt&gt;x&lt;/tt&gt;

&lt;source lang="c"&gt;
int x;
x = point[2];
&lt;/source&gt;

Arrays in C are indexed starting at 0, as opposed to starting at 1.  The first element of the array above is &lt;tt&gt;point[0]&lt;/tt&gt;.  The index to the last value in the array is the array size minus one.
In the example above the subscripts run from 0 through 5. C does not guarantee bounds checking on array accesses. The compiler may not complain about the following (though the best compilers do):

&lt;source lang="c"&gt;
char y;
int z = 9;
char point[6] = { 1, 2, 3, 4, 5, 6 };
//examples of accessing outside the array. A compile error is not always raised
y = point[15];
y = point[-4];
y = point[z];
&lt;/source&gt;

During program execution, an out of bounds array access does not always cause a run time error. Your program may happily continue after retrieving a value from point[-1]. To alleviate indexing problems, the sizeof() expression is commonly used when coding loops that process arrays.

Many people use a macro that in turn uses sizeof() to find the number of elements in an array,
a macro variously named
"lengthof()",&lt;ref&gt;
Pádraig Brady.
[http://www.pixelbeat.org/programming/gcc/c_c++_notes.html "C and C++ notes"].
&lt;/ref&gt;
"MY_ARRAY_SIZE()" or "NUM_ELEM()",&lt;ref&gt;
[[C Programming/Pointers and arrays]]
&lt;/ref&gt;
"SIZEOF_STATIC_ARRAY()",&lt;ref&gt;
[[MINC/Reference/MINC1-volumeio-programmers-reference]]
&lt;/ref&gt;
etc.

&lt;source lang="c"&gt;
int ix;
short anArray[]= { 3, 6, 9, 12, 15 };
 
for (ix=0; ix&lt; (sizeof(anArray)/sizeof(short)); ++ix) {
  DoSomethingWith("%d", anArray[ix] );
}
&lt;/source&gt;

Notice in the above example, the size of the array was not explicitly specified. The compiler knows to size it at 5 because of the five values in the initializer list.  Adding an additional value to the list will cause it to be sized to six, and because of the sizeof expression in the &lt;tt&gt;for&lt;/tt&gt; loop, the code automatically adjusts to this change.  Good programming practice is to declare a variable &lt;i&gt;size &lt;/i&gt;, and store the number of elements in the array in it.
&lt;p&gt;
size = sizeof(anArray)/sizeof(short)
&lt;/p&gt;

C also supports multi dimensional arrays (or, rather, arrays of arrays). The simplest type is a two dimensional array. This creates a rectangular array - each row has the same number of columns. To get a char array with 3 rows and 5 columns we write in C
 char two_d[3][5];

To access/modify a value in this array we need two subscripts:

&lt;source lang="c"&gt;
char ch;
ch = two_d[2][4];
&lt;/source&gt;

or

&lt;source lang="c"&gt;
two_d[0][0] = 'x';
&lt;/source&gt;

Similarly, a multi-dimensional array can be initialized like this:
&lt;source lang="c"&gt;
int two_d[2][3] = {{ 5, 2, 1 },
                   { 6, 7, 8 }};
&lt;/source&gt;

The amount of columns must be explicitly stated; however, the compiler will find the appropriate amount of rows based on the initializer list.

There are also weird notations possible:
&lt;source lang="c"&gt;
int a[100];
int i = 0;
if (a[i]==i[a])
{
  printf("Hello world!\n");
}
&lt;/source&gt;
----

a[i] and i[a] refer to the same location. (This is explained later in the next Chapter.)

== Strings ==
[[Image:Merkkijono.svg|thumb|300px|String "Merkkijono" stored in memory]]
C has no string handling facilities built in; consequently, strings are defined as arrays of characters. C allows a character array to be represented by a character string rather than a list of characters, with the null terminating character automatically added to the end. For example, to store the string "Merkkijono", we would write

&lt;source lang="c"&gt;
char string[11] = "Merkkijono";
&lt;/source&gt;

or

&lt;source lang="c"&gt;
char string[11] = {'M', 'e', 'r', 'k', 'k', 'i', 'j', 'o', 'n', 'o', '\0'};
&lt;/source&gt;

In the first example, the string will have a null character automatically appended to the end by the compiler; by convention, library functions expect strings to be terminated by a null character.  The latter declaration indicates individual elements, and as such the null terminator needs to be added manually. 

Strings do not always have to be linked to an explicit variable.  As you have seen already, a string of characters can be created directly as an unnamed string that is used directly (as with the printf functions.)  

To create an extra long string, you will have to split the string into multiple sections, by closing the first section with a quote, and recommencing the string on the next line (also starting and ending in a quote):
&lt;source lang="c"&gt;
char string[58] = "This is a very, very long "
                "string that requires two lines.";
&lt;/source&gt;

While strings may also span multiple lines by putting the backslash character at the end of the line, this method is deprecated. 

There is a useful library of string handling routines which you can use by including another header file.

&lt;source lang="c"&gt;
#include &lt;string.h&gt;  //new header file
&lt;/source&gt;

This standard string library will allow various tasks to be performed on strings, and is discussed in the [[../Strings|Strings]] chapter.

== References ==
{{reflist}}

{{C Programming/Navigation|Simple math|Control}}

[[et:Programmeerimiskeel C/Massiivid]]
[[fr:Programmation C/Tableaux]]
[[it:C/Vettori e puntatori/Vettori]]
[[pl:C/Tablice]]
[[fi:C/Taulukot]]</text>
      <sha1>bt6hk1silj024vfg0u4keoaklj8ee3f</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Basics of compilation</title>
    <ns>0</ns>
    <id>2133</id>
    <revision>
      <id>3535639</id>
      <parentid>3535638</parentid>
      <timestamp>2019-04-06T14:07:42Z</timestamp>
      <contributor>
        <ip>2804:7F7:2383:6729:0:0:0:1</ip>
      </contributor>
      <comment>/* Automation */ Break a long paragraph talking about Makefiles, how to get help and gdb into three</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7765" xml:space="preserve">{{C Programming/Navigation|Preliminaries|Structure and style}}

Having covered the basic concepts of C programming, we can now briefly discuss the process of ''compilation''.

Like any programming language, C by itself is completely incomprehensible to a [[w:microprocessor|microprocessor]]. Its purpose is to provide an intuitive way for humans to provide instructions that can be easily converted into machine code that ''is'' comprehensible to a microprocessor. The '''''compiler''''' is what translates our human-readable source code into machine code. 

To those new to programming, this seems fairly simple. A naive compiler might read in every source file, translate everything into machine code, and write out an executable. That could work, but has two serious problems. First, for a large project, the computer may not have enough memory to read all of the source code at once. Second, if you make a change to a single source file, you would have to recompile the ''entire'' application. 

To deal with these problems, compilers break the job into steps. For each source file (each &lt;code&gt;.c&lt;/code&gt; file), the compiler reads the file, reads the files it references via the &lt;code&gt;#include&lt;/code&gt; directive, and translates them to machine code. The result of this is an "object file" (&lt;code&gt;.o&lt;/code&gt;). After all the object files are created, a "linker" program collects all of the object files and writes the actual executable program. That way, if you change one source file, only that file needs to be recompiled, after which, the application will need to be re-linked. 

Without going into details, it can be beneficial to have a superficial understanding of the compilation process. 

== Preprocessor ==
The preprocessor provides the ability for the inclusion of so called header files, macro expansions, conditional compilation and line control.
Many times you will need to give special instructions to your compiler. This can be done by inserting preprocessor [[w:Preprocessor directives|directives]] into your code. When you begin compiling your code, a special program called the preprocessor scans the source code and performs simple substitution of token strings for others according to predefined rules. The C preprocessor is not a part of the C language. 

All preprocessor directives begin with the hash character (#). You can see one preprocessor directive in the [[Hello world program]]. Example: 

&lt;source lang="c"&gt;
 #include &lt;stdio.h&gt; 
&lt;/source&gt;

This directive causes the stdio header to be included into your program. Other directives such as &lt;code&gt;#pragma&lt;/code&gt; control compiler settings and macros. The result of the preprocessing stage is a text string. You can think of the preprocessor as a non-interactive text editor that prepares your code for compilation.
The language of preprocessor directives is agnostic to the grammar of C, so the C preprocessor can also be used independently to process other kinds of text files.

== Syntax Checking ==
This step ensures that the code is valid and will sequence into an executable program. Under most compilers, you may get messages or warnings indicating potential issues with your program (such as a [[w:Conditional_(computer_programming)|conditional statement]] always being true or false, etc.)

When an error is detected in the program, the compiler will normally report the file name and line that is preventing compilation.

== Object Code ==
The compiler produces a machine code equivalent of the source code that can be linked into the final program. At this point the code itself can't be executed, as it requires linking to do so.

It's important to note after discussing the basics that compilation is a "one way street". That is, compiling a C source file into machine code is easy, but "decompiling" (turning machine code into the C source that creates it) is not. Decompilers for C do exist, but the code they create is hard to understand and only useful for [[w:Reverse_engineering|reverse engineering]].

== Linking ==
Linking combines the separate object files into one complete program by integrating libraries and the code and producing either an [[W:Executable|executable program]] or a [[W:Library (computing)|library]]. Linking is performed by a linker program, which is often part of a compiler suite.

Common errors during this stage are either missing or duplicate functions.

== Automation ==
For large C projects, many programmers choose to automate compilation, both in order to reduce user interaction requirements and to speed up the process by recompiling only modified files.

Most Integrated Development Environments (IDE's) have some kind of project management which makes such automation very easy. However, the project management files are often usable only by users of the same integrated development environment, so anyone desiring to modify the project would need to use the same IDE.

On UNIX-like systems, [[make]] and Makefiles are often used to accomplish the same. Make is traditional and flexible and is available as one of the standard developer tools on most Unix and GNU distributions.

Makefiles have been extended by the [[w:GNU_Build_System|GNU Autotools]], composed of [https://www.gnu.org/software/automake/ Automake] and [https://www.gnu.org/software/autoconf/ Autoconf] for making software compilable, testable, translatable and configurable on many types of machines. Automake and Autoconf are described in detail in their respective manuals.

The Autotools are often perceived to be complicated and various simpler build systems have been developed. Many components of the [[w:GNOME|GNOME project]] now use the declarative [http://mesonbuild.com/ Meson build system] which is less flexible, but instead focuses on providing the features most commonly needed from a build system in a simple way. Other popular build systems for programs written in the C language include [https://cmake.org/ CMake] and [https://waf.io/ Waf].

Once gcc is installed, it can be called with a list of c source files 
that have been written but not yet compiled. e.g. if the file main.c
includes functions described in myfun.h and implemented in myfun_a.c
and  myfun_b.c, then it is enough to write

  gcc   main.c myfun_a.c myfun_b.c 

myfun.h is included in main.c, but if it is in a separate header file
directory, then that directory can be listed after a  "-I " switch.

In larger programs,  Makefiles and gnu make program can compile
c files into intermediate files ending with suffix .o which can be linked
by gcc.

How to compile each object file is usually described in the Makefile
with the object file as a label ending with a colon followed by two spaces 
(tabs often cause problems) followed by a list of other files that are 
dependencies, e.g. .c files and .o files compiled in another section,
and on the next line, the invocation of gcc that is required.

Typing   &lt;code&gt;man  make&lt;/code&gt;  or  &lt;code&gt;info make&lt;/code&gt; often gives the information 
needed to on how to use make, as well as gcc.

Although gcc has a lot of option switches, one often used is
-g to generate debugging information for gdb to allow
gdb to show source code during a step-through of the machine
code program.  gdb has an 'h' command that shows what it can do,
and is usually started with  'gdb a.out' if a.out is the anonymous
executable machine code file that was compiled by gcc.



[[de:C-Programmierung: Kompilierung]]
[[es:Programación_en_C/Compilar_un_programa]]
[[et:Programmeerimiskeel C/Kompileerimine]]
[[fr:Programmation C-C%2B%2B/Modularité et compilation]]
[[it:C/Compilatore e precompilatore/Compilatore]]
[[pt:Programar em C/Utilizando um compilador]]

== References ==
{{reflist}}

{{C Programming/Navigation|Preliminaries|Structure and style}}</text>
      <sha1>id8ktfssnxay2w74mdkoufigs6dk2fo</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Beginning exercises</title>
    <ns>0</ns>
    <id>3246</id>
    <revision>
      <id>3542049</id>
      <parentid>3512889</parentid>
      <timestamp>2019-05-04T20:03:22Z</timestamp>
      <contributor>
        <ip>217.101.177.168</ip>
      </contributor>
      <comment>Corrected two misspellings of Edsger Dijkstra's name</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12536" xml:space="preserve">{{C Programming/Navigation|Standard libraries|Composite data types}}

==Variables==
=== Naming ===

# Can a variable name start with a number?
# Can a variable name start with a typographical symbol(e.g. #, *, _)?
# Give an example of a C variable name that would ''not'' work.  Why doesn't it work?

=== Data Types ===

# List at least three data types in C
## On your computer, how much memory does each require?
## Which ones can be used in place of another?  Why?
### Are there any limitations on these uses?
### If so, what are they?
### Is it necessary to do anything special to use the alternative?
# Can the name we use for a data type (e.g. 'int', 'float') be used as a variable?

=== Assignment ===

# How would you assign the value 3.14 to a variable called pi?
# Is it possible to assign an ''int'' to a ''double''?  
## Is the reverse possible?

=== Referencing ===

# A common mistake for new students is reversing the assignment statement.  Suppose you want to assign the value stored in the variable "pi" to another variable, say "pi2":
## What is the correct statement?
## What is the reverse?  Is this a valid C statement (even if it gives incorrect results)?
## What if you wanted to assign a constant value (like 3.1415) to "pi2":  
##: '''a'''. What would the correct statement look like?
##: '''b'''. Would the reverse be a valid or invalid C statement?

==Simple I/O==
=== String manipulation ===
1. Write a program that prompts the user for a string, and prints its reverse.

2. Write a program that prompts the user for a sentence, and prints each word on its own line.

=== Loops ===
1. Write a function that outputs a right isosceles triangle of height and width ''n'', so ''n = 3'' would look like
&lt;pre&gt;
*
**
***
&lt;/pre&gt;

2. Write a function that outputs a sideways triangle of height ''2n-1'' and width ''n'', so the output for ''n = 4'' would be:
&lt;pre&gt;
*
**
***
****
***
**
*
&lt;/pre&gt;

3. Write a function that outputs a right-side-up triangle of height ''n'' and width ''2n-1''; the output for ''n = 6'' would be:
&lt;pre&gt;
     *
    ***
   *****
  *******
 *********
***********
&lt;/pre&gt;

==Program Flow==

1. Build a program where control passes from main to four different functions with 4 calls.

2. Now make a while loop in main with the function calls inside it. Ask for input at the beginning of the loop. End the while loop if the user hits Q

3. Next add conditionals to call the functions when the user enters numbers, so 1 goes to function1, 2 goes to function 2, etc.

4. Have function 1 call function a, which calls function b, which calls function c 

5. Draw out a diagram of program flow, with arrows to indicate where control goes

==Functions==

1. Write a function to check if an integer is negative; the declaration should look like
bool is_positive(int i);

2. Write a function to raise a floating point number to an integer power, so for example to when you use it

&lt;syntaxhighlight lang="c"&gt;
float a = raise_to_power(2, 3);    //a gets 8
float b = raise_to_power(9, 2);    //b gets 81
float raise_to_power(float f, int power);    //make this your declaration
&lt;/syntaxhighlight&gt;

==Math==

1. Write a function to calculate if a number is prime. Return 1 if it is prime and 0 if it is not a prime.

2. Write a function to determine the number of prime numbers below n.

3. Write a function to find the square root by using [[wikipedia:Newton's_method|Newton's method]].

4. Write functions to evaluate the trigonometric functions.

5. Try to write a random number generator.

6. Write a function to determine the prime number(s) between 2 and 100.

== Recursion ==
==== Merge sort ====
1. Write a C program to generate a random  integer array with a given length n ,  and sort it recursively using the Merge sort algorithm.
* The merge sort algorithm is a recursive algorithm .

- sorting a one element array is easy.

- sorting two  one-element arrays,  requires the merge operation. The merge operation looks at two sorted arrays as lists, and compares
the head of the list , and which ever head is smaller, this element is put on the sorted list and the head of that list is ticked off, so the
next element becomes the head of that list. This is done until one of the lists is exhausted, and the other list is then copied onto the end
of the sorted list.

- the recursion occurs, because merging two one-element arrays produces one two-element sorted array, which can be merged with another two-element
sorted array produced the same way. This produces a sorted 4 element array, and the same applies for another 4 element sorted array.

- so the basic merge sort, is to check the size of list to be sorted, and if it is greater than one, divide the array into two, and call merge sort again on the two halves. After wards, merge the two halves in a temporary space of equal size, and then copy back the final sorted array onto the original array.

==== Binary heaps ====
2.  '''Binary heaps''' :
* A binary max-heap or min-heap, is an ordered structure where some nodes are guaranteed greater than other nodes, e.g. the parent vs two children.  A binary heap can be stored in an array , where , 

- given a position '''i''' (the parent) , '''i*2''' is the left child, and '''i*2+1''' is the right child. 

- ( C arrays begin at position 0, but 0 * 2 = 0, and 0 *2 + 1= 1, which is incorrect , so start the heap at position 1, or add 1 for parent-to-child calculations, and subtract 1 for child-to-parent calculations ). 

* try to model this using with a pencil and paper, using 10 random unsorted numbers, and inserting each of them into a   "heapsort" array of 10 elements.

* To insert into a heap,  '''end-add''' and '''swap-parent''' if higher, until parent higher.

* To delete the top of a heap,   move   '''end-to-top''',  and  '''defer-higher-child''' or '''sift-down''' , until no child is higher. 

* try it on a pen and paper the numbers 10, 4, 6 ,3 ,5 , 11.

* the answer was 11, 5, 10, 3, 4 , 6.   

*EXERCISE:  Now try removing each top element of 11, 5, 10, 3, 4, 6  , using  end-to-top and sift-down ( or swap-higher-child) to get the numbers
in descending order.

* a priority queue allows elements to be inserted with a priority , and extracted according to priority. ( This can happen usefully, if the element has a paired structure, one part is the key, and the other part the data. Otherwise, it is just a mechanism for sorting ). 

* EXERCISE: Using the above technique of insert-back/challenge-parent, and delete-front/last-to-front/defer-higher-child, implement either heap sort or a priority queue.

====Dijkstra's algorithm ====
Dijkstra's algorithm is a searching algorithm using a priority queue. It begins with inserting the start node with a priority value of 0. All other
nodes are inserted with priority values of large N. Each node  has an adjacency list of other nodes, a current distance to start node, and previous pointer to previous node used to calculate current node. Alternative to an adjacency list, is an adjacency matrix, which needs n x n  boolean adjacencies.

The algorithm basically iterates over the priority queue, removing the front node, examining the adjacent nodes, and updating with a distance equal to the sum of the front nodes distance for each adjacent node , and the distance given by the adjacency information for an adjacent node. 

After each node's update, the extra operation '''"update priority"''' is used on that node :  

''while'' the node's distance is less than it's parents node ( for this priority queue, parents have lesser distances than the children), the node is swapped with the parent. 

After this, ''while'' the node is greater distance than one or more of its children, it is swapped with the least distant child, so the least distant child becomes parent of its greater distant sibling, and parent to the greater distant current node.  

With updating the priority, the adjacent node to the current node has a back pointer changed to the current node. 

The algorithm ends when the target node becomes the current node removed, and the path to the start node can be recorded in an array by following back pointers, and then doing something like a quick sort partition to reverse the order of the array , to give the shortest path to target node from the start node.

==== Quick sort ====
3. Write a C program to recursively sort using the Quick sort partition exchange algorithm.
* you can use the "driver", or the random number test data from Q1. on mergesort. This is "re-use", which is encouraged in general. 
- an advantage of reuse is less writing time, debugging time, testing time.
* the concept of partition exchange is that a partition element is (randomly) selected, and every thing that needs sorted is put into 3 equivalance
classes : those elements less than the partition value, the partition element, and everything above (and equal to ) the partition element.
* this can be done without allocating more space than one temporary element space for swapping two elements. e.g a temporary integer for integer data.
* However, where the partition element should be using the original array space is not known. 
* This is usually implemented with putting the partition on the end of the array to be sorted, and then putting two pointers , one at the start of the array,
and one at the element next to the partition element , and repeatedly scanning the left pointer right, and the right pointer left.
* the left scan stops when an element equal to or greater than the partition is found, and the right scan stops for a smaller element than the partition value,
and these are swapped, which uses the temporary extra space.
* the left scan will always stop if it reaches the partition element , which is the last element; this means the entire array is less than partition value.
* the right scan could reach the first element, if the entire array is greater than the partition , and this needs to be tested for, else the scan doesn't stop.
* the outer loop exits when then left and right pointers cross. Testing for pointer crossing and outer loop exit
should occur before swapping, otherwise the right pointer may be swapping a less-than-partition element
previously scanned by the left pointer.
* finally, the partition element needs to be put between the left and right partitions, once the pointers cross.
* At pointer crossing, the left pointer may be stopped at the partition element's last position in the array, and the right pointer not progressed past the
element just before the last element. This happens when all the elements are less than the partition. 

- if the right pointer is chosen to swap with the partition, then an incorrect state results where the last element of the left array becomes less than the partition element value.

- if the left pointer is chosen to swap with the partition, then the left array will be less than the partition, and partition will have swapped with an element with value greater than the partition
or the partition itself.   

* The corner case of quicksorting a 2 element &lt;b&gt;out-of-order&lt;/b&gt; array has to be examined. 

- The left pointer stops on the first '''out of order''' element. The right pointer begins on the first &lt;b&gt;out-of-order&lt;/b&gt; element,
but the outer loop exits because this is the leftmost element. The partition element  is then swapped with the left pointer's first element, and the two elements are now '''in order'''. 

- In the case of a 2 element '''in order''' array, the leftmost pointer skips the first element which is less than the partition, and stops on the partition. The right pointer begins on the first element and exits
because it is the first position. The pointers have crossed so the outer loop exits. The partition swaps with itself, so the in-ordering is preserved.

* After doing a swap, the left pointer should be incremented and right pointer decremented, so the same positions aren't scanned again, because an endless loop can result ( possibly when the left pointer exits when the element is equal to or greater than the partition, and the  right element is equal to the partition value).  One implementation, Sedgewick,  starts the pointers with the left pointer minus one and right pointer
the plus one the intended initial scan positions, and use the pre-increment and pre-decrement operators e.g. ( ++i, --i) .

{{C Programming/Navigation|Standard libraries|Composite data types}}

[[fr:Exercices en langage C]]
[[et:Programmeerimiskeel C/Harjutused]]
[[pl:C/Ćwiczenia dla początkujących]]</text>
      <sha1>nyp895v70ie1dfp8aa653pcnkup8awn</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/C Compilers Reference List</title>
    <ns>0</ns>
    <id>42794</id>
    <revision>
      <id>3537405</id>
      <parentid>3454034</parentid>
      <timestamp>2019-04-15T02:50:54Z</timestamp>
      <contributor>
        <ip>74.215.253.211</ip>
      </contributor>
      <comment>/* Free (or with a free version) */Updated the name of MSVS free edition</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3078" xml:space="preserve">{{C Programming/Navigation|Reference Tables}}

For a brief introduction to setting up and using some of the more beginner-friendly compilers and IDEs, see [[../Using a Compiler/]].

== Free (or with a free version) ==

* [[w:Ch_interpreter|Ch_interpreter]] (http://www.softintegration.com) - The software works in Windows, Linux, Mac OS X, Freebsd, Solaris, AIX and HP-UX. The Ch Standard Edition is free for noncommercial use.
* [[w:Interactive C|Interactive C]] (http://www.botball.org/educational-resources/ic.php).
** target platform: Handy Board (Freescale 68HC11); Lego RCX
* [[w:CINT|CINT]] is an interpreter for C and C++ code, included in the data-analysis package [[ROOT]]. The CINT interpreter is licensed under the X11/MIT license. ( https://root.cern.ch/drupal/content/cint ).
* [https://github.com/zsaleeba/picoc PicoC]
* [http://sourceforge.net/projects/eic/ Extensible Interactive C (EiC)]
* [[w:lcc-win32|lcc-win32]] (http://www.cs.virginia.edu/~lcc-win32) -  Software copyrighted by Jacob Navia. It is free for non-commercial use. Windows (98/ME/XP/2000/NT).
* [[w:GNU Compiler Collection|GNU Compiler Collection]] (http://gcc.gnu.org) - GNU Compiler Collection. GNU General Public License / GNU Lesser General Public License.
** [[w:MinGW|MinGW]] (http://www.mingw.org/) provides GCC for Windows
* [[w:LLVM|clang (LLVM)]] (http://clang.llvm.org/) - Almost everywhere
* [[w:Open Watcom|Open Watcom]] (http://www.openwatcom.org) Open Source development community to maintain and enhance the Watcom C/C++ and Fortran cross compilers and tools. Version 1.4 released in December 2005.
**'''Host Platforms:''' Win32 systems (IDE and command line), 32-bit OS/2 (IDE and command line), DOS (command line), and Windows 3.x (IDE) 
**'''Target Platforms:''' DOS (16-bit), Windows 3.x (16-bit), OS/2 1.x (16-bit), Extended DOS, Win32s, Windows 95/98/Me, Windows NT/2000/XP, 32-bit OS/2, and Novell NLMs 
**'''Experimental / Development:''' Linux, BSD, *nix, PowerPC, Alpha AXP, MIPS, and Sparc v8
*[[w:Tiny C Compiler|Tiny C Compiler]]
* [[w:Portable C Compiler|Portable C Compiler]] (http://pcc.ludd.ltu.se) - Portable C Compiler. BSD Style License(s).
* [[w:Small Device C Compiler|Small Device C Compiler]] (SDCC)
** target platforms: Intel 8051-compatibles; Freescale (Motorola) HC08; Microchip PIC16 and PIC18.
* [[w:FpgaC|FpgaC]]. Target platform: FPGA hardware via XNF or VHDL files.
* C compilers for many digital signal processors (DSPs), many of them are free, and are listed in the [http://www.bdti.com/faq/3.htm comp.dsp FAQ].
* [[w:Microsoft Visual C++|Microsoft Visual C++]] (http://msdn.microsoft.com/visualc) - Free (partially limited) version available (Express|Community Edition)

== Paid ==
* [[w:Intel C Compiler|Intel C Compiler]] (http://software.intel.com/en-us/intel-compilers) - Windows, Linux, Mac, QNX, and embedded C/C++ compilers.  Optimized for Intel 32-bit and 64-bit CPUs.
* [[w:Impulse C|Impulse C]] - Target platform: FPGA hardware via Hardware Description Language (HDL) files.

{{BookCat}}
{{C Programming/Navigation|Reference Tables}}</text>
      <sha1>c2sy8gmrga18g9jvp1ieetcoj019bab</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/C trigraph</title>
    <ns>0</ns>
    <id>291586</id>
    <revision>
      <id>3394268</id>
      <parentid>3349521</parentid>
      <timestamp>2018-03-28T01:59:25Z</timestamp>
      <contributor>
        <ip>2601:8B:C300:F440:7CF6:AE6C:F0B9:4CD8</ip>
      </contributor>
      <comment>Added a point</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2026" xml:space="preserve">==Trigraphs==

C was designed in English and assumes the common English character set, which includes such characters as &lt;tt&gt;{&lt;/tt&gt;, &lt;tt&gt;}&lt;/tt&gt;, &lt;tt&gt;[&lt;/tt&gt;, &lt;tt&gt;]&lt;/tt&gt;, and so on. Some other languages, however, do not have these or other characters which are required by C. To solve this problem, the 1989 C standard in section 5.2.1.1 defined a set of &lt;i&gt;trigraph sequences&lt;/i&gt; which can be substitutes for the symbols and which will work in any situation. In fact, the first translation phase of compilation specified in the 1989 C standard (section 5.1.1.2) is to replace the trigraph sequences with their corresponding single-character equivalents.

The following trigraph sequences exist, and no other. Each question mark &lt;tt&gt;?&lt;/tt&gt; that does not begin one of the trigraph sequences listed is not changed.

 Sequence Replacement
 ======== ===========
   ??=         #
   ??(         [
   ??/         \
   ??)         ]
   ??'         ^
   ??&lt;         {
   ??!         |
   ??&gt;         }
   ??-         ~

The effect of this is that statements such as

  &lt;syntaxhighlight lang="c"&gt;
printf ("Eh???/n");
&lt;/syntaxhighlight&gt;

will, after the trigraph is replaced, be the equivalent of

  &lt;syntaxhighlight lang="c"&gt;
printf ("Eh?\n");
&lt;/syntaxhighlight&gt;

Should the programmer want the trigraph ''not'' to be replaced, within strings and character constants (which is the only place they would need replacing and it would change things), the programmer can simply escape the second question mark; e.g. &lt;syntaxhighlight lang="c"&gt; printf ("Two question marks in a row: ?\?!\n"); &lt;/syntaxhighlight&gt;

The 1999 C standard added these punctuators, sometimes called &lt;i&gt;digraphs&lt;/i&gt;, in section 6.4.6. They are equivalent to the following tokens except for their spelling:

 Digraph Equivalent
 ======= ==========
    &lt;:       [
    :&gt;       ]
    &lt;%       {
    %&gt;       }
    %:       #
   %:%:      ##

In other words, they behave differently when stringized as part of a macro replacement, but are otherwise equivalent.

{{BookCat}}</text>
      <sha1>j3ll1sl8neqqtsdpb6ex6zl3uss92sg</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Common practices</title>
    <ns>0</ns>
    <id>20855</id>
    <revision>
      <id>3343545</id>
      <parentid>3343536</parentid>
      <timestamp>2017-12-11T17:38:55Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <comment>/* Nulling freed pointers */ Add syntax highlighting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11729" xml:space="preserve">{{C Programming/Navigation|Preprocessor|Side effects and sequence points}}

With its extensive use, a number of common practices and conventions have evolved to help avoid errors in C programs. These are simultaneously a demonstration of the application of good software engineering principles to a language and an indication of the limitations of C. Although few are used universally, and some are controversial, each of these enjoys wide use.

== Dynamic multidimensional arrays ==

Although one-dimensional arrays are easy to create dynamically using malloc, and fixed-size multidimensional arrays are easy to create using the built-in language feature, dynamic multidimensional arrays are trickier. There are a number of different ways to create them, each with different tradeoffs. The two most popular ways to create them are:
* They can be allocated as a single block of memory, just like static multidimensional arrays. This requires that the array be ''rectangular'' (i.e. subarrays of lower dimensions are static and have the same size).  The disadvantage is that the syntax of declaration the pointer is a little tricky for programmers at first.  For example, if one wanted to create an array of ints of 3 columns and &lt;tt&gt;rows&lt;/tt&gt; rows, one would do

&lt;syntaxhighlight lang="c"&gt;
int (*multi_array)[3] = malloc(rows * sizeof(int[3]));
&lt;/syntaxhighlight&gt;

:(Note that here &lt;tt&gt;multi_array&lt;/tt&gt; is a pointer to an array of 3 ints.)

:Because of array-pointer interchangeability, you can index this just like static multidimensional arrays, i.e. &lt;tt&gt;multi_array[5][2]&lt;/tt&gt; is the element at the 6th row and 3rd column.

* Dynamic multidimensional arrays can be allocated by first allocating an array of pointers, and then allocating subarrays and storing their addresses in the array of pointers.&lt;ref&gt;
Adam N. Rosenberg.
[http://www.the-adam.com/adam/rantrave/st02.pdf "A Description of One Programmer’s Programming
Style Revisited"].
2001.
p. 19-20.
&lt;/ref&gt; (This approach is also known as an [[w:Iliffe vector|Iliffe vector]]). The syntax for accessing elements is the same as for multidimensional arrays described above (even though they are stored very differently).  This approach has the advantage of the ability to make ragged arrays (i.e. with subarrays of different sizes). However, it also uses more space and requires more levels of indirection to index into, and can have worse cache performance. It also requires many dynamic allocations, each of which can be expensive.


For more information, see the [http://www.eskimo.com/~scs/C-faq/q6.16.html comp.lang.c FAQ, question 6.16].

In some cases, the use of multi-dimensional arrays can best be addressed as an array of structures.  Before user-defined data structures were available, a common technique was to define a multi-dimensional array, where each column contained different information about the row.  This approach is also frequently used by beginner programmers.  For example, columns of a two-dimensional character array might contain last name, first name, address, etc.

In cases like this, it is better to define a structure that contains the information that was stored in the columns, and then create an array of pointers to that structure.  This is especially true when the number of data points for a given record might vary, such as the tracks on an album.  In these cases, it is better to create a structure for the album that contains information about the album, along with a dynamic array for the list of songs on the album.  Then an array of pointers to the album structure can be used to store the collection.

* Another useful way to create a dynamic multi-dimensional array is to flatten the array and index manually. For example, a 2-dimensional array with sizes x and y has x*y elements, therefore can be created by
&lt;source lang="c"&gt;
int dynamic_multi_array[x*y];
&lt;/source&gt;
The index is slightly trickier than before, but can still be obtained by y*i+j. You then access the array with
&lt;source lang="c"&gt;
static_multi_array[i][j];
dynamic_multi_array[y*i+j];
&lt;/source&gt;
Some more examples with higher dimensions:
&lt;source lang="c"&gt;
int dim1[w];
int dim2[w*x];
int dim3[w*x*y];
int dim4[w*x*y*z];

dim1[i]
dim2[w*j+i];
dim3[w*(x*i+j)+k] // index is k + w*j + w*x*i
dim4[w*(x*(y*i+j)+k)+l] // index is w*x*y*i + w*x*j + w*k + l
&lt;/source&gt;
Note that w*(x*(y*i+j)+k)+l is equal to w*x*y*i + w*x*j + w*k + l, but uses fewer operations (see [http://en.wikipedia.org/wiki/Horner%27s_method Horner's Method]). It uses the same number of operations as accessing a static array by dim4[i][j][k][l], so should not be any slower to use.

The advantage to using this method is that the array can be passed freely between functions without knowing the size of the array at compile time (since C sees it as a 1-dimensional array, although some way of passing the dimensions is still necessary), and the entire array is contiguous in memory, so accessing consecutive elements should be fast. The disadvantage is that it can be difficult at first to get used to how to index the elements.

== Constructors and destructors ==

In most object-oriented languages, objects cannot be created directly by a client that wishes to use them. Instead, the client must ask the class to build an instance of the object using a special routine called a constructor. Constructors are important because they allow an object to enforce invariants about its internal state throughout its lifetime. Destructors, called at the end of an object's lifetime, are important in systems where an object holds exclusive access to some resource, and it is desirable to ensure that it releases these resources for use by other objects.

Since C is not an object-oriented language, it has no built-in support for constructors or destructors. It is not uncommon for clients to explicitly allocate and initialize records and other objects. However, this leads to a potential for errors, since operations on the object may fail or behave unpredictably if the object is not properly initialized. A better approach is to have a function that creates an instance of the object, possibly taking initialization parameters, as in this example:

&lt;syntaxhighlight lang="c"&gt;
struct string {
    size_t size;
    char *data;
};

struct string *create_string(const char *initial) {
    assert (initial != NULL);
    struct string *new_string = malloc(sizeof(*new_string));
    if (new_string != NULL) {
        new_string-&gt;size = strlen(initial);
        new_string-&gt;data = strdup(initial);
    }
    return new_string;
}
&lt;/syntaxhighlight&gt;

Similarly, if it is left to the client to destroy objects correctly, they may fail to do so, causing resource leaks. It is better to have an explicit destructor which is always used, such as this one:

&lt;syntaxhighlight lang="c"&gt;
void free_string(struct string *s) {
    assert (s != NULL);
    free(s-&gt;data);  ''/* free memory held by the structure */''
    free(s);        ''/* free the structure itself */''
}
&lt;/syntaxhighlight&gt;

It is often useful to combine destructors with ''[[#Nulling freed pointers]]''.

Sometimes it is useful to hide the definition of the object to ensure that the client does not allocate it manually. To do this, the structure is defined in the source file (or a private header file not available to users) instead of the header file, and a forward declaration is put in the header file:

&lt;syntaxhighlight lang="c"&gt;
struct string;
struct string *create_string(const char *initial);
void free_string(struct string *s);
&lt;/syntaxhighlight&gt;

== Nulling freed pointers ==

As discussed earlier, after &lt;code&gt;free()&lt;/code&gt; has been called on a pointer, it becomes a dangling pointer. Worse still, most modern platforms cannot detect when such a pointer is used before being reassigned.

One simple solution to this is to ensure that any pointer is set to a null pointer immediately after being freed:
&lt;ref&gt;
[http://c-faq.com/malloc/ptrafterfree.html comp.lang.c FAQ list: "Why isn't a pointer null after calling free?"] mentions that "it is often useful to set [pointer variables] to NULL immediately after freeing them".

&lt;/ref&gt;
&lt;syntaxhighlight lang="c"&gt;
free(p);
p = NULL;
&lt;/syntaxhighlight&gt;

Unlike dangling pointers, a hardware exception will arise on many modern architectures when a null pointer is dereferenced. Also, programs can include error checks for the null value, but not for a dangling pointer value. To ensure it is done at all locations, a macro can be used:

&lt;syntaxhighlight lang="c"&gt;
#define FREE(p)   do { free(p); (p) = NULL; } while(0)
&lt;/syntaxhighlight&gt;

(To see why the macro is written this way, see ''[[#Macro conventions]]''.) Also, when this technique is used, destructors should zero out the pointer that they are passed, and their argument must be passed by reference to allow this. For example, here's the destructor from ''[[#Constructors and destructors]]'' updated:

&lt;syntaxhighlight lang="c"&gt;
void free_string(struct string **s) {
    assert(s != NULL  &amp;&amp;  *s != NULL);
    FREE((*s)-&gt;data);  ''/* free memory held by the structure */''
    FREE(*s);          ''/* free the structure itself */''
    *s=NULL;           ''/* zero the argument */''
}
&lt;/syntaxhighlight&gt;

Unfortunately, this idiom will not do anything to any other pointers that may be pointing to the freed memory.  For this reason, some C experts regard this idiom as dangerous due to creating a false sense of security.

== Macro conventions ==

Because preprocessor macros in C work using simple token replacement, they are prone to a number of confusing errors, some of which can be avoided by following a simple set of conventions:
# Placing parentheses around macro arguments wherever possible. This ensures that, if they are expressions, the order of operations does not affect the behavior of the expression. For example:
#*Wrong: &lt;code&gt;#define square(x)   x*x&lt;/code&gt;
#*Better: &lt;code&gt;#define square(x)   (x)*(x)&lt;/code&gt;
# Placing parentheses around the entire expression if it is a single expression. Again, this avoids changes in meaning due to the order of operations.
#*Wrong: &lt;code&gt;#define square(x)   (x)*(x)&lt;/code&gt;
#*Better: &lt;code&gt;#define square(x)   ((x)*(x))&lt;/code&gt;
#*Dangerous, remember it replaces the text in verbatim. Suppose your code is &lt;code&gt;square (x++)&lt;/code&gt;, after the macro invocation will x be incremented by 2
# If a macro produces multiple statements, or declares variables, it can be wrapped in a '''do''' { ... } '''while'''(0) loop, with no terminating semicolon. This allows the macro to be used like a single statement in any location, such as the body of  an if statement, while still allowing a semicolon to be placed after the macro invocation without creating a null statement. Care must be taken that any new variables do not potentially mask portions of the macro's arguments.
#*Wrong: &lt;code&gt;#define FREE(p)   free(p); p = NULL;&lt;/code&gt;
#*Better: &lt;code&gt;#define FREE(p)   do { free(p); p = NULL; } while(0)&lt;/code&gt;
# Avoiding using a macro argument twice or more inside a macro, if possible; this causes problems with macro arguments that contain side effects, such as assignments.
# If a macro may be replaced by a function in the future, considering naming it like a function.

== Further reading ==

{{Reflist}}
There are a huge number of C style guidelines.

* [http://www.chris-lott.org/resources/cstyle/ "C and C++ Style Guides"] by Chris Lott lists many popular C style guides.
* The Motor Industry Software Reliability Association (MISRA) publishes "MISRA-C: Guidelines for the use of the C language in critical systems". ([[Wikipedia: MISRA C]]; [http://www.misra-c.com/]).

{{C Programming/Navigation|Preprocessor|Side effects and sequence points}}

[[pl:C/Powszechne praktyki]]</text>
      <sha1>12rntqjbfv4lt27duvoapxpmqb4w464</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Coroutines</title>
    <ns>0</ns>
    <id>141602</id>
    <revision>
      <id>3437411</id>
      <parentid>3383809</parentid>
      <timestamp>2018-06-22T02:00:21Z</timestamp>
      <contributor>
        <username>Holdoffhunger</username>
        <id>2983037</id>
      </contributor>
      <comment>"similiar" should be "similar"</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2686" xml:space="preserve">
A little known fact is that most C implementations have built-in primitives that can be used for cooperative multitasking / coroutines. They are [[w:setcontext|setcontext]] and [[w:setjmp.h|setjmp]].

== setjmp ==

The function &lt;code&gt;setjmp&lt;/code&gt; is used in a pair with &lt;code&gt;longjmp&lt;/code&gt; to transfer execution to a different point in the code.  It relies on an existing &lt;code&gt;jmp_buf&lt;/code&gt; declaration.

&lt;source lang=c&gt;
#include &lt;setjmp.h&gt;

int main (void)
{
  jmp_buf buf1;
  
  if (setjmp(buf1) == 0)
  {
    /* This code is executed on the first call to setjmp. */

    longjmp(buf1, 1);
  } else {
    /* This code is executed once longjmp is called. */
  }
  return 0; 
}
&lt;/source&gt;

&lt;code&gt;setjmp()&lt;/code&gt; stores the current execution point in memory, which remains valid as long as the containing function doesn't return.  It initially returns &lt;code&gt;0&lt;/code&gt;.  Control is returned to &lt;code&gt;setjmp&lt;/code&gt; once &lt;code&gt;longjmp&lt;/code&gt; is called with the original &lt;code&gt;jmp_buf&lt;/code&gt; and the replacement return value.  

Note that jmp_buf is passed to setjmp without using the address-of operator.

The easiest way to understand setjmp and longjmp, is that setjmp stores the state of the cpu which includes program counter, stack pointer, all the registers, including the bits of the flags register, at the location pointed to by jmp_buf , which is defined some LEN+1, which is enough bytes to store the registers of whatever CPU is involved. The longjmp(buf) , never returns, because it restores the CPU from the contents of struct jmp_buf buf previously set by a previous call the setjmp, so execution begins from after setjmp was called, but the return value of setjmp is not 0, but whatever value was used in the second parameter to longjmp. This is similar to the fork() system call, which returns 0 to the child process, and the PID of the child process to the parent.

The internet suggests co-routines are useful for implementing software as state machines cooperating, such as lexer processing input text and emitting tokens , so that a parser can decide to store the token and ask for the next one, or to act on its current set of token . This is not multithreaded programs synchronising on data, with possibly race conditions if a bug forgets to acquire a lock, but with setjmp and longjmp, seems to be cooperative processes that guarantee only one process will run at a time, with no worries about context switches waking up sleeping processes ( using separate jmp_buf static locations, each process can call setjmp for its own jmp_buf, before calling longjmp later on if zero was returned, or continue a loop to process shared data for non-zero returns).

{{BookCat}}</text>
      <sha1>4zr1tdhlw4pqn69w025de8kp5ozb5o5</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Error handling</title>
    <ns>0</ns>
    <id>21053</id>
    <revision>
      <id>3223727</id>
      <parentid>2986554</parentid>
      <timestamp>2017-05-28T18:31:13Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <minor/>
      <comment>Fix navigation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6377" xml:space="preserve">{{C Programming/Navigation|Memory management|File IO}}

C does not provide direct support for error handling (also known as exception handling).  By convention, the programmer is expected to prevent errors from occurring in the first place, and test return values from functions.  For example, -1 and NULL are used in several functions such as socket() (Unix socket programming) or malloc() respectively to indicate problems that the programmer should be aware about.  In a worst case scenario where there is an unavoidable error and no way to recover from it, a C programmer usually tries to log the error and "gracefully" terminate the program. 

There is an external variable called "errno", accessible by the programs after including &lt;errno.h&gt; - that file comes from the definition of the possible errors that can occur in some Operating Systems (e.g. Linux - in this case, the definition is in include/asm-generic/errno.h) when programs ask for resources. Such variable indexes error descriptions accessible by the function 'strerror( errno )'. 

The following code tests the return value from the library function malloc to see if dynamic memory allocation completed properly:
&lt;source lang="c"&gt;
#include &lt;stdio.h&gt;        /* perror */
#include &lt;errno.h&gt;        /* errno */
#include &lt;stdlib.h&gt;       /* malloc, free, exit */

int main(void)
{

    /* Pointer to char, requesting dynamic allocation of 2,000,000,000
     * storage elements (declared as an integer constant of type
     * unsigned long int). (If your system has less than 2 GB of memory
     * available, then this call to malloc will fail.)
     */
    char *ptr = malloc(2000000000UL);

    if (ptr == NULL) {
        perror("malloc failed");
        /* here you might want to exit the program or compensate
           for that you don't have 2GB available
         */
    } else {
        /* The rest of the code hereafter can assume that 2,000,000,000
         * chars were successfully allocated... 
         */
        free(ptr);
    }

    exit(EXIT_SUCCESS); /* exiting program */
}
&lt;/source&gt;

The code snippet above shows the use of the return value of the library function malloc to check for errors.  Many library functions have return values that flag errors, and thus should be checked by the astute programmer.  In the snippet above, a NULL pointer returned from malloc signals an error in allocation, so the program exits.  In more complicated implementations, the program might try to handle the error and try to recover from the failed memory allocation.

== Preventing divide by zero errors ==

A common pitfall made by C programmers is not checking if a divisor is zero before a division command. The following code will produce a runtime error and in most cases, exit.

&lt;source lang="c"&gt;
int dividend = 50;
int divisor = 0;
int quotient;

quotient = (dividend/divisor); /* This will produce a runtime error! */
&lt;/source&gt;

For reasons beyond the scope of this document, you must check or make sure that a divisor is never zero. Alternatively, for *nix processes, you can stop the OS from terminating your process by blocking the SIGFPE signal. 

The code below fixes this by checking if the divisor is zero before dividing.

&lt;source lang="c"&gt;
#include &lt;stdio.h&gt; /* for fprintf and stderr */
#include &lt;stdlib.h&gt; /* for exit */
int main( void )
{
    int dividend = 50;
    int divisor = 0;
    int quotient;

    if (divisor == 0) {
        /* Example handling of this error. Writing a message to stderr, and
         * exiting with failure.
         */
        fprintf(stderr, "Division by zero! Aborting...\n");
        exit(EXIT_FAILURE); /* indicate failure.*/
    }

    quotient = dividend / divisor;
    exit(EXIT_SUCCESS); /* indicate success.*/
}
&lt;/source&gt;

== Signals ==

In some cases, the environment may respond to a programming error in C by raising a signal. Signals are events raised by the host environment or operating system to indicate that a specific error or critical event has occurred (e.g. a division by zero, interrupt, and so on.) However, these signals are not meant to be used as a means of error catching; they usually indicate a critical event that will interfere with normal program flow.  

To handle signals, a program needs to use the &lt;tt&gt;signal.h&lt;/tt&gt; header file.  A signal handler will need to be defined, and  the signal() function is then called to allow the given signal to be handled.  Some signals that are raised to an exception within your code (e.g. a division by zero) are unlikely to allow your program to recover.  These signal handlers will be required to instead ensure that some resources are properly cleaned up before the program terminates.

This example creates a signal handler and raises the signal:

&lt;source lang="c"&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void catch_function(int signal) {
    puts("Interactive attention signal caught.");
}

int main(void) {
    if (signal(SIGINT, catch_function) == SIG_ERR) {
        fputs("An error occurred while setting a signal handler.\n", stderr);
        return EXIT_FAILURE;
    }
    puts("Raising the interactive attention signal.");
    if (raise(SIGINT) != 0) {
        fputs("Error raising the signal.\n", stderr);
        return EXIT_FAILURE;
    }
    puts("Exiting.");
    return 0;
}
&lt;/source&gt;

== setjmp ==
The [[C Programming/Coroutines#setjmp|setjmp]] function can be used to emulate the exception handling feature of other programming languages.  The first call to setjmp provides a reference point to returning to a given function, and is valid as long as the function containing setjmp() doesn't return or exit.  A call to longjmp causes the execution to return to the point of the associated setjmp call.

&lt;source lang="c"&gt;
#include &lt;stdio.h&gt;
#include &lt;setjmp.h&gt;

jmp_buf test1;

void tryjump()
{
    longjmp(test1, 3);
}

int main (void)
{
    if (setjmp(test1)==0) {
        printf ("setjmp() returned 0.");
        tryjump();
    } else {
        printf ("setjmp returned from a longjmp function call.");
    }
}
&lt;/source&gt;

The values of non-volatile variables may be corrupted when setjmp returns from a longjmp call. 

While setjmp() and longjmp() may be used for error handling, it is generally preferred to use the return value of a function to indicate an error, if possible.  

{{C Programming/Navigation|Memory management|File IO}}</text>
      <sha1>m087pa4kpowins63f0yxspf83c12e3v</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/File IO</title>
    <ns>0</ns>
    <id>395372</id>
    <redirect title="C Programming/Stream IO" />
    <revision>
      <id>3372319</id>
      <timestamp>2018-02-07T22:29:42Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <comment>Strange quark moved page [[C Programming/File IO]] to [[C Programming/Stream IO]]: Rename to a more appropriate name</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="37" xml:space="preserve">#REDIRECT [[C Programming/Stream IO]]</text>
      <sha1>p2qgsmzy9ivhk0mrr8ggobv166dtzed</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Further math</title>
    <ns>0</ns>
    <id>27775</id>
    <revision>
      <id>3656482</id>
      <parentid>3651338</parentid>
      <timestamp>2020-01-31T14:05:55Z</timestamp>
      <contributor>
        <ip>134.158.40.174</ip>
      </contributor>
      <comment>/* Error and gamma functions */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="20937" xml:space="preserve">{{C Programming/Navigation|Strings|Libraries}}
{{wikipedia|math.h}}

The &lt;code&gt;&lt;math.h&gt;&lt;/code&gt; header contains prototypes for several functions that deal with mathematics. In the 1990 version of the ISO standard, only the &lt;code&gt;double&lt;/code&gt; versions of the functions were specified; the 1999 version added the &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long double&lt;/code&gt; versions. To use these math functions, you must link your program with the math library. For some compilers (including GCC), you must specify the additional parameter &lt;code&gt;-lm&lt;/code&gt;&lt;ref name="Why-lm-is-needed"&gt;[https://stackoverflow.com/questions/1033898/why-do-you-have-to-link-the-math-library-in-c] Why do you have to link the math library in C?&lt;/ref&gt;&lt;ref name="Why-math-library-link-needed"&gt;[https://stackoverflow.com/questions/5419366/why-do-i-have-to-explicitly-link-with-libm] Why do I have to explicitly link with libm?&lt;/ref&gt;.

The math functions may produce one of two kinds of errors. ''Domain errors'' occur when the parameters to the functions are invalid, such as a negative number as a parameter to &lt;tt&gt;sqrt&lt;/tt&gt; (the square root function). ''Range errors'' occur when the result of the function cannot be expressed in that particular floating-point type, such as &lt;tt&gt;pow(1000.0, 1000.0)&lt;/tt&gt; if the maximum value of a double is around 10&lt;sup&gt;308&lt;/sup&gt;.

The functions can be grouped into the following categories:

== Trigonometric functions ==

=== The &lt;code&gt;acos&lt;/code&gt; and &lt;code&gt;asin&lt;/code&gt; functions ===

The &lt;code&gt;acos&lt;/code&gt; functions return the arccosine of their arguments in radians, and the &lt;code&gt;asin&lt;/code&gt; functions return the arcsine of their arguments in radians.  All functions expect the argument in the range [-1,+1]. The arccosine returns a value in the range [0,π]; the arcsine returns a value in the range [-π/2,+π/2].

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float asinf(float x); /* C99 */
 float acosf(float x); /* C99 */
 double asin(double x);
 double acos(double x);
 long double asinl(long double x); /* C99 */
 long double acosl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;atan&lt;/code&gt; and &lt;code&gt;atan2&lt;/code&gt; functions ===

The &lt;code&gt;atan&lt;/code&gt; functions return the arctangent of their arguments in radians, and the &lt;code&gt;atan2&lt;/code&gt; function return the arctangent of &lt;code&gt;y/x&lt;/code&gt; in radians. The &lt;code&gt;atan&lt;/code&gt; functions return a value in the range [-π/2,+π/2] (the reason why ±π/2 are included in the range is because the floating-point value may represent infinity, and atan(±∞) = ±π/2); the &lt;code&gt;atan2&lt;/code&gt; functions return a value in the range [-π,+π]. For &lt;code&gt;atan2&lt;/code&gt;, a domain error may occur if both arguments are zero.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float atanf(float x); /* C99 */
 float atan2f(float y, float x); /* C99 */
 double atan(double x);
 double atan2(double y, double x);
 long double atanl(long double x); /* C99 */
 long double atan2l(long double y, long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, and &lt;code&gt;tan&lt;/code&gt; functions ===

The &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, and &lt;code&gt;tan&lt;/code&gt; functions return the cosine, sine, and tangent of the argument, expressed in radians.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float cosf(float x); /* C99 */
 float sinf(float x); /* C99 */
 float tanf(float x); /* C99 */
 double cos(double x);
 double sin(double x);
 double tan(double x);
 long double cosl(long double x); /* C99 */
 long double sinl(long double x); /* C99 */
 long double tanl(long double x); /* C99 */
&lt;/source&gt;

== Hyperbolic functions ==

The &lt;tt&gt;cosh&lt;/tt&gt;, &lt;tt&gt;sinh&lt;/tt&gt; and &lt;tt&gt;tanh&lt;/tt&gt; functions compute the hyperbolic cosine, the hyperbolic sine, and the hyperbolic tangent of the argument respectively. For the hyperbolic sine and cosine functions, a range error occurs if the magnitude of the argument is too large.

The &lt;tt&gt;acosh&lt;/tt&gt; functions compute the inverse hyperbolic cosine of the argument. A domain error occurs for arguments less than 1.

The &lt;tt&gt;asinh&lt;/tt&gt; functions compute the inverse hyperbolic sine of the argument.

The &lt;tt&gt;atanh&lt;/tt&gt; functions compute the inverse hyperbolic tangent of the argument. A domain error occurs if the argument is not in the interval [-1, +1]. A range error may occur if the argument equals -1 or +1.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float coshf(float x); /* C99 */
 float sinhf(float x); /* C99 */
 float tanhf(float x); /* C99 */
 double cosh(double x); 
 double sinh(double x);
 double tanh(double x);
 long double coshl(long double x); /* C99 */
 long double sinhl(long double x); /* C99 */
 long double tanhl(long double x); /* C99 */
 float acoshf(float x); /* C99 */
 float asinhf(float x); /* C99 */
 float atanhf(float x); /* C99 */
 double acosh(double x); /* C99 */
 double asinh(double x); /* C99 */
 double atanh(double x); /* C99 */
 long double acoshl(long double x); /* C99 */
 long double asinhl(long double x); /* C99 */
 long double atanhl(long double x); /* C99 */
&lt;/source&gt;

== Exponential and logarithmic functions ==

=== The &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, and &lt;code&gt;expm1&lt;/code&gt; functions ===

The &lt;code&gt;exp&lt;/code&gt; functions compute the base-''e'' exponential function of &lt;code&gt;x&lt;/code&gt; (''e''&lt;sup&gt;x&lt;/sup&gt;). A range error occurs if the magnitude of &lt;code&gt;x&lt;/code&gt; is too large.

The &lt;code&gt;exp2&lt;/code&gt; functions compute the base-2 exponential function of &lt;code&gt;x&lt;/code&gt; (2&lt;sup&gt;x&lt;/sup&gt;). A range error occurs if the magnitude of &lt;code&gt;x&lt;/code&gt; is too large.

The &lt;code&gt;expm1&lt;/code&gt; functions compute the base-''e'' exponential function of the argument, minus 1. A range error occurs if the magnitude of &lt;code&gt;x&lt;/code&gt; is too large.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float expf(float x); /* C99 */
 double exp(double x);
 long double expl(long double x); /* C99 */
 float exp2f(float x); /* C99 */
 double exp2(double x); /* C99 */
 long double exp2l(long double x); /* C99 */
 float expm1f(float x); /* C99 */
 double expm1(double x); /* C99 */
 long double expm1l(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt;, and &lt;code&gt;scalbln&lt;/code&gt; functions ===

These functions are heavily used in software floating-point emulators, but are otherwise rarely directly called.

Inside the computer, each floating point number is represented by two parts:
* The significand is either in the range [1/2, 1), or it equals zero.
* The exponent is an integer.
The value of a floating point number &lt;math&gt;v&lt;/math&gt; is
&lt;math&gt;v = {\rm significand} \times 2^{\rm exponent}&lt;/math&gt;.

The &lt;code&gt;frexp&lt;/code&gt; functions break the argument floating point number &lt;code&gt;value&lt;/code&gt; into those two parts, the exponent and significand.
After breaking it apart, it stores the exponent in the &lt;code&gt;int&lt;/code&gt; object pointed to by &lt;code&gt;ex&lt;/code&gt;, and returns the significand.
In other words, the value returned is a copy of the given floating point number but with an exponent replaced by 0.
If &lt;code&gt;value&lt;/code&gt; is zero, both parts of the result are zero.

The &lt;code&gt;ldexp&lt;/code&gt; functions multiply a floating-point number by a integral power of 2 and return the result.
In other words, it returns copy of the given floating point number with the exponent increased by ex.
A range error may occur.

The &lt;code&gt;modf&lt;/code&gt; functions break the argument &lt;code&gt;value&lt;/code&gt; into integer and fraction parts, each of which has the same sign as the argument. They store the integer part in the object pointed to by &lt;code&gt;*iptr&lt;/code&gt; and return the fraction part.
The &lt;code&gt;*iptr&lt;/code&gt; is a floating-point type, rather than an "int" type, because it might be used to store an integer like 1 000 000 000 000 000 000 000 which is too big to fit in an int.

The &lt;code&gt;scalbn&lt;/code&gt; and &lt;code&gt;scalbln&lt;/code&gt; compute &lt;code&gt;x&lt;/code&gt; × &lt;code&gt;FLT_RADIX&lt;sup&gt;n&lt;/sup&gt;&lt;/code&gt;. &lt;code&gt;FLT_RADIX&lt;/code&gt; is the base of the floating-point system; if it is 2, the functions are equivalent to &lt;code&gt;ldexp&lt;/code&gt;.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float frexpf(float value, int *ex); /* C99 */
 double frexp(double value, int *ex);
 long double frexpl(long double value, int *ex); /* C99 */
 float ldexpf(float x, int ex); /* C99 */
 double ldexp(double x, int ex);
 long double ldexpl(long double x, int ex); /* C99 */
 float modff(float value, float *iptr); /* C99 */
 double modf(double value, double *iptr); 
 long double modfl(long double value, long double *iptr); /* C99 */
 float scalbnf(float x, int ex); /* C99 */
 double scalbn(double x, int ex); /* C99 */
 long double scalbnl(long double x, int ex); /* C99 */
 float scalblnf(float x, long int ex); /* C99 */
 double scalbln(double x, long int ex); /* C99 */
 long double scalblnl(long double x, long int ex); /* C99 */
&lt;/source&gt;

Most C floating point libraries also implement the IEEE754-recommended nextafter(), nextUp( ), and nextDown( ) functions.
[http://www.opengroup.org/onlinepubs/009695399/functions/nextafter.html]

=== The &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, and &lt;code&gt;log10&lt;/code&gt; functions ===

The &lt;code&gt;log&lt;/code&gt; functions compute the base-''e'' natural logarithm of the argument and return the result. A domain error occurs if the argument is negative. A range error may occur if the argument is zero.

The &lt;code&gt;log1p&lt;/code&gt; functions compute the base-''e'' natural logarithm of one plus the argument and return the result. A domain error occurs if the argument is less than -1. A range error may occur if the argument is -1.

The &lt;code&gt;log10&lt;/code&gt; functions compute the common (base-10) logarithm of the argument and return the result. A domain error occurs if the argument is negative. A range error may occur if the argument is zero.

The &lt;code&gt;log2&lt;/code&gt; functions compute the base-2 logarithm of the argument and return the result. A domain error occurs if the argument is negative. A range error may occur if the argument is zero.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float logf(float x); /* C99 */
 double log(double x);
 long double logl(long double x); /* C99 */
 float log1pf(float x); /* C99 */
 double log1p(double x); /* C99 */
 long double log1pl(long double x); /* C99 */
 float log10f(float x); /* C99 */
 double log10(double x);
 long double log10l(long double x); /* C99 */
 float log2f(float x); /* C99 */
 double log2(double x); /* C99 */
 long double log2l(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;ilogb&lt;/code&gt; and &lt;code&gt;logb&lt;/code&gt; functions ===

The &lt;code&gt;ilogb&lt;/code&gt; functions extract the exponent of &lt;code&gt;x&lt;/code&gt; as a signed int value. If &lt;code&gt;x&lt;/code&gt; is zero, they return the value &lt;code&gt;FP_ILOGB0&lt;/code&gt;; if &lt;code&gt;x&lt;/code&gt; is infinite, they return the value &lt;code&gt;INT_MAX&lt;/code&gt;; if &lt;code&gt;x&lt;/code&gt; is not-a-number they return the value &lt;code&gt;FP_ILOGBNAN&lt;/code&gt;; otherwise, they are equivalent to calling the corresponding &lt;code&gt;logb&lt;/code&gt; function and casting the returned value to type &lt;code&gt;int&lt;/code&gt;. A range error may occur if &lt;code&gt;x&lt;/code&gt; is zero. &lt;code&gt;FP_ILOGB0&lt;/code&gt; and &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; are macros defined in &lt;code&gt;math.h&lt;/code&gt;; &lt;code&gt;INT_MAX&lt;/code&gt; is a macro defined in &lt;code&gt;limits.h&lt;/code&gt;.

The &lt;code&gt;logb&lt;/code&gt; functions extract the exponent of &lt;code&gt;x&lt;/code&gt; as a signed integer value in floating-point format. If &lt;code&gt;x&lt;/code&gt; is subnormal, it is treated as if it were normalized; thus, for positive finite &lt;code&gt;x&lt;/code&gt;, 1 ≤ &lt;code&gt;x&lt;/code&gt; × &lt;code&gt;FLT_RADIX&lt;sup&gt;-logb(x)&lt;/sup&gt;&lt;/code&gt; &amp;lt; &lt;code&gt;FLT_RADIX&lt;/code&gt; . &lt;code&gt;FLT_RADIX&lt;/code&gt; is the radix for floating-point numbers, defined in the &lt;code&gt;float.h&lt;/code&gt; header.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 int ilogbf(float x); /* C99 */
 int ilogb(double x); /* C99 */
 int ilogbl(long double x); /* C99 */
 float logbf(float x); /* C99 */
 double logb(double x); /* C99 */
 long double logbl(long double x); /* C99 */
&lt;/source&gt;

== Power functions ==

=== The &lt;code&gt;pow&lt;/code&gt; functions ===

The &lt;code&gt;pow&lt;/code&gt; functions compute &lt;code&gt;x&lt;/code&gt; raised to the power &lt;code&gt;y&lt;/code&gt; and return the result. A domain error occurs if &lt;code&gt;x&lt;/code&gt; is negative and &lt;code&gt;y&lt;/code&gt; is not an integral value. A domain error occurs if the result cannot be represented when &lt;code&gt;x&lt;/code&gt; is zero and &lt;code&gt;y&lt;/code&gt; is less than or equal to zero. A range error may occur.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float powf(float x, float y); /* C99 */
 double pow(double x, double y);
 long double powl(long double x, long double y); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;sqrt&lt;/code&gt; functions ===

The &lt;code&gt;sqrt&lt;/code&gt; functions compute the positive square root of &lt;code&gt;x&lt;/code&gt; and return the result. A domain error occurs if the argument is negative.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float sqrtf(float x); /* C99 */
 double sqrt(double x);
 long double sqrtl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;cbrt&lt;/code&gt; functions ===

The &lt;code&gt;cbrt&lt;/code&gt; functions compute the cube root of &lt;code&gt;x&lt;/code&gt; and return the result.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float cbrtf(float x); /* C99 */
 double cbrt(double x); /* C99 */
 long double cbrtl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;hypot&lt;/code&gt; functions ===

The &lt;code&gt;hypot&lt;/code&gt; functions compute the square root of the sums of the squares of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, without overflow or underflow, and return the result.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float hypotf(float x, float y); /* C99 */
 double hypot(double x, double y); /* C99 */
 long double hypotl(long double x, long double y); /* C99 */
&lt;/source&gt;

== Nearest integer, absolute value, and remainder functions ==

=== The &lt;code&gt;ceil&lt;/code&gt; and &lt;code&gt;floor&lt;/code&gt; functions ===

The &lt;code&gt;ceil&lt;/code&gt; functions compute the smallest integral value not less than &lt;code&gt;x&lt;/code&gt; and return the result; the &lt;code&gt;floor&lt;/code&gt; functions compute the largest integral value not greater than &lt;code&gt;x&lt;/code&gt; and return the result.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float ceilf(float x); /* C99 */
 double ceil(double x);
 long double ceill(long double x); /* C99 */
 float floorf(float x); /* C99 */
 double floor(double x);
 long double floorl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;fabs&lt;/code&gt; functions ===

The &lt;code&gt;fabs&lt;/code&gt; functions compute the absolute value of a floating-point number &lt;code&gt;x&lt;/code&gt; and return the result.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float fabsf(float x); /* C99 */
 double fabs(double x); 
 long double fabsl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;fmod&lt;/code&gt; functions ===

The &lt;code&gt;fmod&lt;/code&gt; functions compute the floating-point remainder of &lt;code&gt;x/y&lt;/code&gt; and return the value &lt;code&gt;x&lt;/code&gt; - ''i'' * &lt;code&gt;y&lt;/code&gt;, for some integer ''i'' such that, if &lt;code&gt;y&lt;/code&gt; is nonzero, the result has the same sign as &lt;code&gt;x&lt;/code&gt; and magnitude less than the magnitude of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;y&lt;/code&gt; is zero, whether a domain error occurs or the &lt;code&gt;fmod&lt;/code&gt; functions return zero is implementation-defined.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float fmodf(float x, float y); /* C99 */
 double fmod(double x, double y);
 long double fmodl(long double x, long double y); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;nearbyint&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, and &lt;code&gt;llrint&lt;/code&gt; functions ===

The &lt;code&gt;nearbyint&lt;/code&gt; functions round their argument to an integer value in floating-point format, using the current rounding direction and without raising the "inexact" floating-point exception.

The &lt;code&gt;rint&lt;/code&gt; functions are similar to the &lt;code&gt;nearbyint&lt;/code&gt; functions except that they can raise the "inexact" floating-point exception if the result differs in value from the argument.

The &lt;code&gt;lrint&lt;/code&gt; and &lt;code&gt;llrint&lt;/code&gt; functions round their arguments to the nearest integer value according to the current rounding direction. If the result is outside the range of values of the return type, the numeric result is undefined and a range error may occur if the magnitude of the argument is too large.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float nearbyintf(float x); /* C99 */
 double nearbyint(double x); /* C99 */
 long double nearbyintl(long double x); /* C99 */
 float rintf(float x); /* C99 */
 double rint(double x); /* C99 */
 long double rintl(long double x); /* C99 */
 long int lrintf(float x); /* C99 */
 long int lrint(double x); /* C99 */
 long int lrintl(long double x); /* C99 */
 long long int llrintf(float x); /* C99 */
 long long int llrint(double x); /* C99 */
 long long int llrintl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, and &lt;code&gt;llround&lt;/code&gt; functions ===

The &lt;code&gt;round&lt;/code&gt; functions round the argument to the nearest integer value in floating-point format, rounding halfway cases away from zero, regardless of the current rounding direction.

The &lt;code&gt;lround&lt;/code&gt; and &lt;code&gt;llround&lt;/code&gt; functions round the argument to the nearest integer value, rounding halfway cases away from zero, regardless of the current rounding direction. If the result is outside the range of values of the return type, the numeric result is undefined and a range error may occur if the magnitude of the argument is too large.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float roundf(float x); /* C99 */
 double round(double x); /* C99 */
 long double roundl(long double x); /* C99 */
 long int lroundf(float x); /* C99 */
 long int lround(double x); /* C99 */
 long int lroundl(long double x); /* C99 */
 long long int llroundf(float x); /* C99 */
 long long int llround(double x); /* C99 */
 long long int llroundl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;trunc&lt;/code&gt; functions ===

The &lt;code&gt;trunc&lt;/code&gt; functions round their argument to the integer value in floating-point format that is nearest but no larger in magnitude than the argument.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float truncf(float x); /* C99 */
 double trunc(double x); /* C99 */
 long double truncl(long double x); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;remainder&lt;/code&gt; functions ===

The &lt;code&gt;remainder&lt;/code&gt; functions compute the remainder &lt;code&gt;x&lt;/code&gt; REM &lt;code&gt;y&lt;/code&gt; as defined by IEC 60559. The definition reads, "When ''y'' ≠ 0, the remainder ''r'' = ''x'' REM ''y'' is defined regardless of the rounding mode by the mathematical reduction ''r'' = ''x'' - ''ny'', where ''n'' is the integer nearest the exact value of ''x''/''y''; whenever |''n'' - ''x''/''y''| = ½, then ''n'' is even. Thus, the remainder is always exact. If ''r'' = 0, its sign shall be that of ''x''." This definition is applicable for all implementations.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float remainderf(float x, float y); /* C99 */
 double remainder(double x, double y); /* C99 */
 long double remainderl(long double x, long double y); /* C99 */
&lt;/source&gt;

=== The &lt;code&gt;remquo&lt;/code&gt; functions ===

The &lt;code&gt;remquo&lt;/code&gt; functions return the same remainder as the &lt;code&gt;remainder&lt;/code&gt; functions. In the object pointed to by &lt;code&gt;quo&lt;/code&gt;, they store a value whose sign is the sign of &lt;code&gt;x&lt;/code&gt;/&lt;code&gt;y&lt;/code&gt; and whose magnitude is congruent modulo 2&lt;sup&gt;n&lt;/sup&gt; to the magnitude of the integral quotient of &lt;code&gt;x&lt;/code&gt;/&lt;code&gt;y&lt;/code&gt;, where ''n'' is an implementation-defined integer greater than or equal to 3.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float remquof(float x, float y, int *quo); /* C99 */
 double remquo(double x, double y, int *quo); /* C99 */
 long double remquol(long double x, long double y, int *quo); /* C99 */
&lt;/source&gt;

== Error and gamma functions ==

The &lt;code&gt;erf&lt;/code&gt; functions compute the error function of the argument &lt;math&gt;\frac{2}{\sqrt{\pi}}\int_{0}^x e^{-t^2}\,\mathrm dt&lt;/math&gt;

The &lt;code&gt;erfc&lt;/code&gt; functions compute the complimentary error function of the argument (that is, 1 - erf x). For the &lt;code&gt;erfc&lt;/code&gt; functions, a range error may occur if the argument is too large.

The &lt;code&gt;lgamma&lt;/code&gt; functions compute the natural logarithm of the absolute value of the gamma of the argument (that is, log&lt;sub&gt;''e''&lt;/sub&gt;|Γ(x)|). A range error may occur if the argument is a negative integer or zero.

The &lt;code&gt;tgamma&lt;/code&gt; functions compute the gamma of the argument (that is, Γ(x)). A domain error occurs if the argument is a negative integer or if the result cannot be represented when the argument is zero. A range error may occur.

&lt;source lang=c&gt;
 #include &lt;math.h&gt;
 float erff(float x); /* C99 */
 double erf(double x); /* C99 */
 long double erfl(long double x); /* C99 */
 float erfcf(float x); /* C99 */
 double erfc(double x); /* C99 */
 long double erfcl(long double x); /* C99 */
 float lgammaf(float x); /* C99 */
 double lgamma(double x); /* C99 */
 long double lgammal(long double x); /* C99 */
 float tgammaf(float x); /* C99 */
 double tgamma(double x); /* C99 */
 long double tgammal(long double x); /* C99 */
&lt;/source&gt;

== References ==
{{wikipedia|circular shift}}
{{reflist}}
{{-}}
{{C Programming/Navigation|Strings|Libraries}}

[[fr:Programmation C/Mathématiques]]
[[pl:C/Zaawansowane operacje matematyczne]]</text>
      <sha1>lge2twgm46yqv3zci87bdfovwykkuvt</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/GNU C Library Reference</title>
    <ns>0</ns>
    <id>393586</id>
    <revision>
      <id>3427390</id>
      <parentid>3361160</parentid>
      <timestamp>2018-05-23T22:10:26Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <comment>/* Header files */ Fix formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6642" xml:space="preserve">== Header files ==

{| class="wikitable"
|-
|&lt;tt&gt;[[#argp.h|argp.h]]&lt;/tt&gt; || Interface for parsing unix-style argument vectors.
|-
|&lt;tt&gt;[[#argz.h|argz.h]]&lt;/tt&gt; || Allocate/grow argz vectors.
|-
|&lt;tt&gt;[[#envz.h|envz.h]]&lt;/tt&gt; ||
|-
|&lt;tt&gt;[[#execinfo.h|execinfo.h]]&lt;/tt&gt; || Backtrace support.
|-
|&lt;tt&gt;[[#libintl.h|libintl.h]]&lt;/tt&gt; ||
|}

== Table of functions ==


=== [[/argp.h|argp.h]] ===

{|
|
* &lt;tt&gt;[[/argp.h/argp_error|argp_error]]&lt;/tt&gt;
* &lt;tt&gt;[[/argp.h/argp_failure|argp_failure]]&lt;/tt&gt;
* &lt;tt&gt;[[/argp.h/argp_help|argp_help]]&lt;/tt&gt;
* &lt;tt&gt;[[/argp.h/argp_parse|argp_parse]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[/argp.h/argp_state_help|argp_state_help]]&lt;/tt&gt;
* &lt;tt&gt;[[/argp.h/argp_usage|argp_usage]]&lt;/tt&gt;
|}

=== [[/argz.h|argz.h]] ===

{|
|
* &lt;tt&gt;[[/argz.h/argz_add|argz_add]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_add_sep|argz_add_sep]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_append|argz_append]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_count|argz_count]]&lt;/tt&gt;
|
* &lt;tt&gt;[[/argz.h/argz_create|argz_create]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_create_sep|argz_create_sep]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_delete|argz_delete]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_extract|argz_extract]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[/argz.h/argz_insert|argz_insert]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_next|argz_next]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_replace|argz_replace]]&lt;/tt&gt;
* &lt;tt&gt;[[/argz.h/argz_stringify|argz_stringify]]&lt;/tt&gt;
|}

=== [[/envz.h|envz.h]] ===

{|
|
* &lt;tt&gt;[[/envz.h/envz_add|envz_add]]&lt;/tt&gt;
* &lt;tt&gt;[[/envz.h/envz_entry|envz_entry]]&lt;/tt&gt;
* &lt;tt&gt;[[/envz.h/envz_get|envz_get]]&lt;/tt&gt;
* &lt;tt&gt;[[/envz.h/envz_merge|envz_merge]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[/envz.h/envz_remove|envz_remove]]&lt;/tt&gt;
* &lt;tt&gt;[[/envz.h/envz_strip|envz_strip]]&lt;/tt&gt;
|}

=== [[/execinfo.h|execinfo.h]] ===

{|
|
* &lt;tt&gt;[[/execinfo.h/backtrace|backtrace]]&lt;/tt&gt;
* &lt;tt&gt;[[/execinfo.h/backtrace_symbols|backtrace_symbols]]&lt;/tt&gt;
* &lt;tt&gt;[[/execinfo.h/backtrace_symbols_fd|backtrace_symbols_fd]]&lt;/tt&gt;
|}

=== [[/libintl.h|libintl.h]] ===

{|
|
* &lt;tt&gt;[[/libintl.h/bind_textdomain_codeset|bind_textdomain_codeset]]&lt;/tt&gt;
* &lt;tt&gt;[[/libintl.h/bindtextdomain|bindtextdomain]]&lt;/tt&gt;
* &lt;tt&gt;[[/libintl.h/dcgettext|dcgettext]]&lt;/tt&gt;
* &lt;tt&gt;[[/libintl.h/dcngettext|dcngettext]]&lt;/tt&gt;
|
* &lt;tt&gt;[[/libintl.h/dgettext|dgettext]]&lt;/tt&gt;
* &lt;tt&gt;[[/libintl.h/dngettext|dngettext]]&lt;/tt&gt;
* &lt;tt&gt;[[/libintl.h/gettext|gettext]]&lt;/tt&gt;
* &lt;tt&gt;[[/libintl.h/ngettext|ngettext]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[/libintl.h/textdomain|textdomain]]&lt;/tt&gt;
|}

== Standard Library Extensions ==

Platform facilities that extend the standard library headers.

=== [[../assert.h|assert.h]] ===

{|
|
* &lt;tt&gt;[[../assert.h/assert_perror|assert_perror]]&lt;/tt&gt;
|}

=== [[../complex.h|complex.h]] ===

{|
|
* &lt;tt&gt;[[../complex.h/clog10|clog10]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/clog10f|clog10f]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/clog10fN|clog10fN]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/clog10fNx|clog10fNx]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[../complex.h/clog10l|clog10l]]&lt;/tt&gt;
|}

=== [[../fenv.h|fenv.h]] ===

{|
|
* &lt;tt&gt;[[../fenv.h/fedisableexcept|fedisableexcept]]&lt;/tt&gt;
* &lt;tt&gt;[[../fenv.h/feenableexcept|feenableexcept]]&lt;/tt&gt;
* &lt;tt&gt;[[../fenv.h/fegetexcept|fegetexcept]]&lt;/tt&gt;
|}

=== [[../math.h|math.h]] ===

{|
|
* &lt;tt&gt;[[../math.h/j0fN|j0fN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/j0fNx|j0fNx]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/j1fN|j1fN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/j1fNx|j1fNx]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/jnfN|jnfN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/jnfNx|jnfNx]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/lgammafN_r|lgammafN_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/lgammafNx_r|lgammafNx_r]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../math.h/pow10|pow10]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/pow10f|pow10f]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/pow10l|pow10l]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/sincos|sincos]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/sincosf|sincosf]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/sincosfN|sincosfN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/sincosfNx|sincosfNx]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/sincosl|sincosl]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[../math.h/y0fN|y0fN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/y0fNx|y0fNx]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/y1fN|y1fN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/y1fNx|y1fNx]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/ynfN|ynfN]]&lt;/tt&gt;
* &lt;tt&gt;[[../math.h/ynfNx|ynfNx]]&lt;/tt&gt;
|}

=== [[../signal.h|signal.h]] ===

{|
|
* &lt;tt&gt;[[../signal.h/sysv_signal|sysv_signal]]&lt;/tt&gt;
|}

=== [[../stdio.h|stdio.h]] ===

{|
|
* &lt;tt&gt;[[../stdio.h/asprintf|asprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/clearerr_unlocked|clearerr_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/feof_unlocked|feof_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/ferror_unlocked|ferror_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fgets_unlocked|fgets_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fileno_unlocked|fileno_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fmemopen|fmemopen]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fopencookie|fopencookie]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../stdio.h/fputs_unlocked|fputs_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fread_unlocked|fread_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fwrite_unlocked|fwrite_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/getdelim|getdelim]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fputs_unlocked|fputs_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fread_unlocked|fread_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/fwrite_unlocked|fwrite_unlocked]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/getdelim|getdelim]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[../stdio.h/getline|getline]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/obstack_printf|obstack_printf]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/obstack_vprintf|obstack_vprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/open_memstream|open_memstream]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/snprintf|snprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/tmpnam_r|tmpnam_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/vasprintf|vasprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdio.h/vsnprintf|vsnprintf]]&lt;/tt&gt;
|}

=== [[../stdlib.h|stdlib.h]] ===

{|
|
* &lt;tt&gt;[[../stdlib.h/alloca|alloca]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/canonicalize_file_name|canonicalize_file_name]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/clearenv|clearenv]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/drand48_r|drand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/ecvt_r|ecvt_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/erand48_r|erand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/getpt|getpt]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/initstate_r|initstate_r]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../stdlib.h/jrand48_r|jrand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/lcong48_r|lcong48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/lrand48_r|lrand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/mrand48_r|mrand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/nrand48_r|nrand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/ptsname_r|ptsname_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/qecvt|qecvt]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/qecvt_r|qecvt_r]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../stdlib.h/qfcvt|qfcvt]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/qfcvt_r|qfcvt_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/qgcvt|qgcvt]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/random_r|random_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/rpmatch|rpmatch]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/secure_getenv|secure_getenv]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/seed48_r|seed48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/setstate_r|setstate_r]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[../stdlib.h/srand48_r|srand48_r]]&lt;/tt&gt;
* &lt;tt&gt;[[../stdlib.h/srandom_r|srandom_r]]&lt;/tt&gt;
|}

{{BookCat}}</text>
      <sha1>lwulsvymfzv0x3yirxeoy3zxfmwmben</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/GObject</title>
    <ns>0</ns>
    <id>257892</id>
    <revision>
      <id>3448516</id>
      <parentid>3410322</parentid>
      <timestamp>2018-08-05T21:56:49Z</timestamp>
      <contributor>
        <username>DavidCary</username>
        <id>973</id>
      </contributor>
      <comment>yet another way of implementing objects in C</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5397" xml:space="preserve">{{C Programming/Navigation|Mixing languages|Code library}}

Since the C Programming-Language was not created with Object Oriented Programming in mind, it has no explicit support for classes, inheritance, polymorphism and other OO Concepts. Neither does it have its own Virtual Table, which is found in object-oriented languages such [[C++ Programming|C++]], [[Java Programming|Java]] and [[C_Sharp_Programming|C#]]. Therefore, it might not be as easy to implement an object-oriented programming paradigm using only C's language features and standard library. However, it can be done using structures which contain both function pointers as well as data, for example, or by using third-party libraries. 

There are many third-party libraries designed to add support for object-oriented programming in C. The most general-purpose and widely used among these is the GObject System, which is part of Glib. The GObject System comes with its own virtual table. To create an object in C using the GObject system, it has to be sub-classed from the GObject struct. 

==Object-Creation==
In this example a new object will be implemented directly derived from GObject. For simplicity, the object is named ''MyObject''.

===Declaring An Object===

To create a simple non-derivable (final) &lt;u&gt;object&lt;/u&gt;, two structs must be declared, the ''instance'' and the ''class''. They are declared using a macro:

&lt;syntaxhighlight lang="c"&gt;
/* in myobject.h */
G_DECLARE_FINAL_TYPE (MyObject, my_object, MY, OBJECT, GObject)
&lt;/syntaxhighlight&gt;

This declares two structures, MyObject and MyObjectClass. MyObject must be defined in the C implementation, and MyObjectClass is already defined by the macro.

===Boiler-Plate Code===

Since the GObject System is just a third-party library and therefore cannot make any changes to the C Language itself, creating a new object 
requires a lot of boiler-plate code. This is mostly handled by the macro shown above. However, the following is also required:

&lt;syntaxhighlight lang="c"&gt;
/* in myobject.h */
#define MY_TYPE_OBJECT my_object_get_type ()
&lt;/syntaxhighlight&gt;

The macro defines several functions, namely MY_OBJECT () and MY_OBJECT_CLASS (), used for casting, MY_IS_OBJECT () and MY_IS_OBJECT_CLASS () for testing whether an object or class is of the correct type and MY_OBJECT_GET_CLASS () for getting the class structure from an instance.

===Defining The Object===

Before use, the newly created object must be &lt;u&gt;defined&lt;/u&gt;, along with the instance structure.

&lt;syntaxhighlight lang="c"&gt;

/* in myobject.c */

struct _MyObject
{
    GObject parent_instance;

    /* other members */
};

G_DEFINE_TYPE (MyObject, my_object, G_TYPE_OBJECT)

&lt;/syntaxhighlight&gt;

===Static Functions===

There are a few &lt;u&gt;static&lt;/u&gt; functions that may or may not to be defined, depending on your object. For a minimal object these ones are compulsory:

&lt;syntaxhighlight lang="c"&gt;

/* in myobject.c */
static void
my_object_class_init (MyObjectClass *klass) 
{
     /* code */
}

static void
my_object_init (MyObject *self)
{
     /* code */
}
&lt;/syntaxhighlight&gt;


===The Constructor===

There is no internal way of &lt;u&gt;allocating memory&lt;/u&gt; for an object in C. Therefore an &lt;u&gt;explicit&lt;/u&gt; constructor must be declared for the new object.

&lt;syntaxhighlight lang="c"&gt;

/* in myobject.c */

GObject *
my_object_new (void)
{
     return g_object_new (MY_TYPE_OBJECT,
                          0);
}
&lt;/syntaxhighlight&gt;


===Object-Usage===

Although creating the object using its own pointer-type is perfectly valid, it is recommended to use the pointer-type of the object at the top of the hierarchy i.e the furthest off base class. The newly created object may now be used like this:

&lt;syntaxhighlight lang="c"&gt;

/* in main.c */

/* Note: GObject is at the top of the hierarchy. */

/* declaration and construction */
GObject *myobj = my_object_new (); 

/* destruction */
g_object_unref (myobj);

&lt;/syntaxhighlight&gt;

==Inheritance==
===Concept===
Inheritance is one of the most widely used and useful OO Concepts. It provides an efficient way to reuse existing code by wrapping it up into an object and then sub-classing it. The new classes are known as derived classes. Many object hieriarchies can be created using inheritance. Inheritance is also one of the most efficient ways of abstracting code.

===Implementation===
In the GObject System, inheritance can be achieved by sub-classing &lt;u&gt;GObject&lt;/u&gt;. Since C provides no keyword or operator for inheritance, a derived object is usually made by declaring the base instance and base class as a ''member'' of the derived instance and derived class respectively. In C code:

&lt;syntaxhighlight lang="c"&gt;

/* derived object instance */
struct _DerivedObject
{
     /* the base instance is a member of the derived instance */
     BaseObject parent_instance;
};
&lt;/syntaxhighlight&gt;

== Further reading ==

* Hanser. [http://www.cs.rit.edu/~ats/books/ooc.pdf "Object-oriented programming with ANSI-C"]. 1994. Hanser describes another way of implementing classes, inheritance, instances, methods, objects, vtables, polymorphism, late binding, etc. in standard ANSI C.

* Greg Kroah-Hartman. [https://lwn.net/Articles/266722/ "Everything you never wanted to know about kobjects, ksets, and ktypes"]. mirror: [https://www.kernel.org/doc/Documentation/kobject.txt "Everything you never wanted to know about kobjects, ksets, and ktypes"]. 2007.</text>
      <sha1>lypsmmjsj6uxe4lwe3uyrw2sbp3skdd</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/History</title>
    <ns>0</ns>
    <id>31447</id>
    <revision>
      <id>2980102</id>
      <parentid>2980077</parentid>
      <timestamp>2015-07-25T15:45:54Z</timestamp>
      <contributor>
        <username>Naderra</username>
        <id>394613</id>
      </contributor>
      <minor/>
      <comment>grammar correction</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3888" xml:space="preserve">{{C Programming/Navigation|Why learn C?|What you need before you can learn}}

The field of computing as we know it today started in 1947 with three scientists at Bell Telephone Laboratories—[[w:William Shockley|William Shockley]], [[w:Walter Brattain|Walter Brattain]], and [[w:John Bardeen|John Bardeen]]—and their groundbreaking invention: the [[w:transistor|transistor]]. In 1956, the first fully transistor-based computer, the [[w:TX-0|TX-0]], was completed at MIT. The first [[w:integrated circuit|integrated circuit]] was created in 1958 by [[w:Jack Kilby|Jack Kilby]] at Texas Instruments, but the first high-level programming language existed even before then.

"The [[w:Fortran|Fortran]] project" was originally developed in 1954 by IBM. A shortening of "''The IBM Mathematical '''For'''mula '''Tran'''slating System''", the project had the purpose of creating and fostering development of a procedural, imperative programming language that was especially suited to numeric computation and scientific computing. It was a breakthrough in terms of productivity and programming ease (compared to assembly language) and speed (Fortran programs ran nearly as fast as, and in some cases, just as fast as, programs written in assembly). Furthermore, Fortran was written at a high-enough level (and thus was machine independent enough) to become the first widely adopted programming language. The Algorithmic Language ([[w:ALGOL 58|Algol 58]]) was derived from Fortran in 1958 and evolved into [[w:ALGOL 60|Algol 60]] in 1960. The [[w:Combined Programming Language|Combined Programming Language (CPL)]] was then created out of Algol 60 in 1963. In 1967, it evolved into [[w:BCPL|Basic CPL]], which was itself, the base for [[w:B (programming language)|B]] in 1969. Finally, B, the root of C, was created in 1971.

C was the direct successor of B, a stripped down version of BCPL, created by [[w:Ken Thompson|Ken Thompson]] at Bell Labs, that was also a [[w:compiled language|compiled language]] - [https://www.bell-labs.com/usr/dmr/www/kbman.pdf User's Reference to B], used in early internal versions of the UNIX operating system.  As noted in Ritchie's [https://www.bell-labs.com/usr/dmr/www/chist.html C History] : "The B compiler on the PDP-7 did not generate machine instructions, but instead 'threaded code', an interpretive scheme in which the compiler's output consists of a sequence of addresses of code fragments that perform the elementary operations. The operations typically — in particular for B — act on a simple stack machine".  Thompson and [[w:Dennis Ritchie|Dennis Ritchie]], also working at Bell Labs, improved B and called the result NB. Further extensions to NB created its logical successor, C. Most of UNIX was rewritten in NB, and then C, which resulted in a more portable operating system.

The portability of UNIX was the main reason for the initial popularity of both UNIX and C. Rather than creating a new operating system for each new machine, system programmers could simply write the few system-dependent parts required for the machine, and then write a C compiler for the new system. Since most of the system utilities were thus written in C, it simply made sense to also write new utilities in C.

The American National Standards Institute began work on standardizing the C language in 1983, and completed the standard in 1989. The standard, ANSI X3.159-1989 "Programming Language C", served as the basis for all implementations of C compilers.  The standards were later updated in 1990 and 1999, allowing for features that were either in common use, or were appearing in C++. 

{{C Programming/Navigation|Why learn C?|What you need before you can learn}}
[[de:C-Programmierung: Grundlagen]]
[[es:Programación en C/Historia de C]]
[[fr:Programmation C/Introduction]]
[[it:C/Linguaggio/Panoramica]]
[[pt:Programar em C/História da linguagem C]]</text>
      <sha1>fvonimwqxjkb07m48tmvczvc2jb8uyu</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Intro exercise</title>
    <ns>0</ns>
    <id>31451</id>
    <revision>
      <id>3500488</id>
      <parentid>3438040</parentid>
      <timestamp>2018-12-10T17:41:05Z</timestamp>
      <contributor>
        <username>AsimovIV Ja</username>
        <id>3191593</id>
      </contributor>
      <comment>/* Unix-like */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5509" xml:space="preserve">{{C Programming/Navigation|Obtaining a compiler|Preliminaries}}

== The "Hello, World!" Program ==
Tradition dictates that we begin with a very simple program, which simply displays the characters "Hello, World!" on the screen and immediately exits.  Type the following source code in your preferred text editor/IDE and save this in a file named '''hello.c'''.

&lt;syntaxhighlight lang="c"&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    printf("Hello, World!\n");
    return 0;
}
&lt;/syntaxhighlight&gt;

=== Source code analysis ===
Below are described the parts the program is composed of.  The various details will be introduced and explained in later chapters.

&lt;syntaxhighlight lang="c"&gt;
#include &lt;stdio.h&gt;
&lt;/syntaxhighlight&gt;

This is a preprocessor directive.  {{w|Preprocessor directives}} instruct a part of the compiler - the '''preprocessor''' - to modify the code we've written before it is compiled. In this case, the &lt;code&gt;#include&lt;/code&gt; directive retrieves C code from the '''stdio.h''' file found in the standard library. Files used in this way are called '''header files''' and are saved with the '''.h''' extension. The stdio.h file contains many functions defined according to the C standard. For this program, the only function we need from stdio.h is the &lt;code&gt;printf&lt;/code&gt; function.

&lt;syntaxhighlight lang="c"&gt;
int main(void)
&lt;/syntaxhighlight&gt;

The '''function''' named &lt;code&gt;main&lt;/code&gt; is the starting point of all C programs. In computer science, the term function tends to be used a bit more loosely than in mathematics, since functions often express imperative ideas (as in the case of C) - that is, ''how-to'' process, instead of declarations.  For now, suffice it to say, functions let us define a complex process that we want to reference frequently.

&lt;syntaxhighlight lang="c"&gt;
    printf("Hello World!\n");
&lt;/syntaxhighlight&gt;

This line is of particular interest because it produces the actual output on the '''console''' (also known as the ''terminal'' in the context of Unix-like operating systems), a traditional text-based interface to system utilities and programs.

&lt;syntaxhighlight lang="c"&gt;
    return 0;
&lt;/syntaxhighlight&gt;

When terminating our program, it is useful to be able to let the operating system know whether or not the program succeeded. We do this with an '''exit status''', which is sent to the operating system with a &lt;code&gt;return&lt;/code&gt; statement in the &lt;code&gt;main&lt;/code&gt; function. In this case, we provide an exit status of &lt;code&gt;0&lt;/code&gt; to indicate that execution succeeded without error. As our programs grow in complexity, we can use other integers as codes to indicate various types of errors. This style of providing exit status is a long standing convention&lt;ref&gt;https://www.gnu.org/software/libc/manual/html_node/Exit-Status.html&lt;/ref&gt;.

=== Compiling ===

==== Unix-like ====
If you are using a Unix(-like) system, such as [[w:GNU/Linux|GNU/Linux]], [[w:Mac OS X|Mac OS X]], or [[w:Solaris Operating Environment|Solaris]], it will probably have GCC installed, otherwise on Linux you can install it using yum or apt-get commands depending on your distribution.  Open the virtual console or a terminal emulator and enter the following (be certain your current working directory is the one containing your source code):

 gcc hello.c

By default gcc will generate our executable binary with the name ''a.out''. To run your new generated program type:

 ./a.out

You should see &lt;code&gt;Hello, World!&lt;/code&gt; printed after the last prompt.

To see the exit status of the last program you ran, type on your shell command:

 echo $?

This shows the value the &lt;code&gt;main&lt;/code&gt; function has returned, which is 0 in the above example.

There are a lot of options you can use with the gcc compiler. For example, if you want the output to have a name other than a.out, you can use the -o option. The following shows a few examples:

&lt;!--;&lt;code&gt;-c&lt;/code&gt;: indicates that the compiler is supposed to generate an ''object file'', which can be later linked to other files to form a final program.--&gt;
;&lt;code&gt;-o&lt;/code&gt;: indicates that the next parameter is the name of the resulting program (or library).  If this option is not specified, the compiled program will, for historic reasons, end up in a file called "a.out" or "a.exe" (for cygwin users).
&lt;!--;&lt;code&gt;-g3&lt;/code&gt;: indicates that ''debugging information'' should be added to the results of compilation.
;&lt;code&gt;-O2 -ffast-math&lt;/code&gt;: indicates that the compilation should be optimized.--&gt;
;&lt;code&gt;-Wall&lt;/code&gt;: indicates that gcc should warn about many types of suspicious code that are likely to be incorrect.
&lt;!--;&lt;code&gt;-E&lt;/code&gt;: indicates that gcc should only preprocess the code; this is useful when you are having trouble understanding what gcc is doing with #include and #define, among other things.--&gt;

You can use these options to create a program called "helloworld" instead of "a.out" by typing:

 gcc -o helloworld hello.c -Wall

Now you can run it by typing:

 ./helloworld

All the options are well documented in the manual&lt;ref&gt;https://gcc.gnu.org/onlinedocs/&lt;/ref&gt; for GCC.

==== On IDEs ====
If you are using an IDE you may have to select console project, and to compile you just select build from the menu or the toolbar. The executable will appear inside the project folder, but you should have a menu button so you can just run the executable from the IDE.  The process is roughly the same on all IDEs.

== References ==
{{reflist}}

{{C Programming/Navigation|Obtaining a compiler|Preliminaries}}</text>
      <sha1>o2dj10r7hjgk397x22yo2b0b3f73mde</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Language Reference</title>
    <ns>0</ns>
    <id>5897</id>
    <revision>
      <id>3587297</id>
      <parentid>3348385</parentid>
      <timestamp>2019-10-16T16:26:26Z</timestamp>
      <contributor>
        <ip>137.149.182.24</ip>
      </contributor>
      <comment>/* Character sets */: made a small change to unicode example to make it more legible and semantically correct</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="18825" xml:space="preserve">{{C Programming/Navigation|Code library|Compilers}}

== Table of keywords ==

=== ANSI C (C89)/ISO C (C90) ===
Very old compilers may not recognize some or all of the C89 keywords &lt;tt&gt;'''const'''&lt;/tt&gt;, &lt;tt&gt;'''enum'''&lt;/tt&gt;, &lt;tt&gt;'''signed'''&lt;/tt&gt;, &lt;tt&gt;'''void'''&lt;/tt&gt;, &lt;tt&gt;'''volatile'''&lt;/tt&gt;, as well as any later standards' keywords.

{|
|
* &lt;tt&gt;'''auto'''&lt;/tt&gt;
* &lt;tt&gt;'''break'''&lt;/tt&gt;
* &lt;tt&gt;'''case'''&lt;/tt&gt;
* &lt;tt&gt;'''char'''&lt;/tt&gt;
* &lt;tt&gt;'''const'''&lt;/tt&gt;
* &lt;tt&gt;'''continue'''&lt;/tt&gt;
* &lt;tt&gt;'''default'''&lt;/tt&gt;
* &lt;tt&gt;'''do'''&lt;/tt&gt;
|
* &lt;tt&gt;'''double'''&lt;/tt&gt;
* &lt;tt&gt;'''else'''&lt;/tt&gt;
* &lt;tt&gt;'''enum'''&lt;/tt&gt;
* &lt;tt&gt;'''extern'''&lt;/tt&gt;
* &lt;tt&gt;'''float'''&lt;/tt&gt;
* &lt;tt&gt;'''for'''&lt;/tt&gt;
* &lt;tt&gt;'''goto'''&lt;/tt&gt;
* &lt;tt&gt;'''if'''&lt;/tt&gt;
|
* &lt;tt&gt;'''int'''&lt;/tt&gt;
* &lt;tt&gt;'''long'''&lt;/tt&gt;
* &lt;tt&gt;'''register'''&lt;/tt&gt;
* &lt;tt&gt;'''return'''&lt;/tt&gt;
* &lt;tt&gt;'''short'''&lt;/tt&gt;
* &lt;tt&gt;'''signed'''&lt;/tt&gt;
* &lt;tt&gt;'''sizeof'''&lt;/tt&gt;
* &lt;tt&gt;'''static'''&lt;/tt&gt;
|
* &lt;tt&gt;'''struct'''&lt;/tt&gt;
* &lt;tt&gt;'''switch'''&lt;/tt&gt;
* &lt;tt&gt;'''typedef'''&lt;/tt&gt;
* &lt;tt&gt;'''union'''&lt;/tt&gt;
* &lt;tt&gt;'''unsigned'''&lt;/tt&gt;
* &lt;tt&gt;'''void'''&lt;/tt&gt;
* &lt;tt&gt;'''volatile'''&lt;/tt&gt;
* &lt;tt&gt;'''while'''&lt;/tt&gt;
|}

=== ISO C (C99) ===
These are supported in most new compilers.

{|
|
* &lt;tt&gt;'''_Bool'''&lt;/tt&gt;
* &lt;tt&gt;'''_Complex'''&lt;/tt&gt;
|
* &lt;tt&gt;'''_Imaginary'''&lt;/tt&gt;
* &lt;tt&gt;'''inline'''&lt;/tt&gt;
| valign="top" | 
* &lt;tt&gt;'''[[w:restrict|restrict]]'''&lt;/tt&gt;
|}

=== ISO C (C11) ===
These are supported only in some newer compilers

{|
|
* &lt;tt&gt;'''alignof'''&lt;/tt&gt;
* &lt;tt&gt;'''_Alignas'''&lt;/tt&gt;
* &lt;tt&gt;'''_Atomic'''&lt;/tt&gt;
|
* &lt;tt&gt;'''_Generic'''&lt;/tt&gt;
* &lt;tt&gt;'''_Noreturn'''&lt;/tt&gt;
* &lt;tt&gt;'''_Static_assert'''&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;'''_Thread_local'''&lt;/tt&gt;
|}

Although not technically a keyword, C99-capable preprocessors/compilers additionally recognize the special preprocessor operator &lt;tt&gt;'''_Pragma'''&lt;/tt&gt;, which acts as an alternate form of the &lt;tt&gt;'''#pragma'''&lt;/tt&gt; directive that can be used from within macro expansions.  For example, the following code will cause some compilers (incl. GCC, Clang) to emit a diagnostic message:
&lt;syntaxhighlight lang="c"&gt;
#define EMIT_MESSAGE(str)    EMIT_PRAGMA(message(str))
#define EMIT_PRAGMA(content) _Pragma(#content)
EMIT_MESSAGE("Hello, world!")
&lt;/syntaxhighlight&gt;
Some compilers use a slight variant syntax; in  particular, MSVC supports &lt;tt&gt;'''__pragma'''&lt;/tt&gt; instead of &lt;tt&gt;'''_Pragma'''&lt;/tt&gt;.

Specific compilers may also&amp;#x2014;in a non-standards-compliant mode, or with additional syntactic markers like &lt;tt&gt;'''__extension__'''&lt;/tt&gt;&amp;#x2014;treat some other words as keywords, including &lt;tt&gt;'''asm'''&lt;/tt&gt;, &lt;tt&gt;'''cdecl'''&lt;/tt&gt;, &lt;tt&gt;'''far'''&lt;/tt&gt;, &lt;tt&gt;'''fortran'''&lt;/tt&gt;, &lt;tt&gt;'''huge'''&lt;/tt&gt;, &lt;tt&gt;'''interrupt'''&lt;/tt&gt;, &lt;tt&gt;'''near'''&lt;/tt&gt;, &lt;tt&gt;'''pascal'''&lt;/tt&gt;, or &lt;tt&gt;'''typeof'''&lt;/tt&gt;.  However, they typically allow these keywords to be overridden by declarations when operating in standards-compliant modes (e.g., by defining a variable named &lt;tt&gt;'''typeof'''&lt;/tt&gt;), in order to avoid introducing incompatibilities with existing programs.  In order to ensure the compiler can maintain access to extension features, these compilers usually have an additional set of proper keywords beginning with two underscores (&lt;tt&gt;'''__'''&lt;/tt&gt;).  For example, GCC treats &lt;tt&gt;'''asm'''&lt;/tt&gt;, &lt;tt&gt;'''__asm'''&lt;/tt&gt;, and &lt;tt&gt;'''__asm__'''&lt;/tt&gt; somewhat identically, but the latter two are always guaranteed to have the expected meaning since they can't be overridden.

Many of the newly introduced keywords&amp;#x2014;namely, those beginning with an underscore and capital letter like &lt;tt&gt;'''_Noreturn'''&lt;/tt&gt; or &lt;tt&gt;'''_Imaginary'''&lt;/tt&gt;&amp;#x2014;are intended to be used only indirectly in most situations.  Instead, the programmer should prefer the use of standard headers such as &lt;tt&gt;&amp;lt;stdbool.h&amp;gt;&lt;/tt&gt; or &lt;tt&gt;&amp;lt;stdalign.h&amp;gt;&lt;/tt&gt;, which typically use the preprocessor to establish an all-lower-case variant of the keyword (e.g., &lt;q&gt;&lt;tt&gt;complex&lt;/tt&gt;&lt;/q&gt; or &lt;q&gt;&lt;tt&gt;noreturn&lt;/tt&gt;&lt;/q&gt;).  These headers serve the purpose of enabling C and C++ code, as well as code targeting different compilers or language versions, to interoperate more cleanly.  For example, by including &lt;tt&gt;&amp;lt;stdbool.h&amp;gt;&lt;/tt&gt;, the tokens &lt;q&gt;&lt;tt&gt;bool&lt;/tt&gt;&lt;/q&gt;, &lt;q&gt;&lt;tt&gt;true&lt;/tt&gt;&lt;/q&gt;, and &lt;q&gt;&lt;tt&gt;false&lt;/tt&gt;&lt;/q&gt; can be used identically in either C99 or C++ without having to explicitly use &lt;tt&gt;'''_Bool'''&lt;/tt&gt; in C99 or &lt;tt&gt;'''bool'''&lt;/tt&gt; in C++.

See also the list of reserved identifiers &lt;ref&gt;http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/topic/com.ibm.vacpp7a.doc/language/ref/clrc02reserved_identifiers.htm list of reserved identifiers&lt;/ref&gt;.

==Table of operators==
Operators in the same row of this table have the same '''precedence''' and the order of evaluation is decided by the '''associativity''' (''left-to-right'' or ''right-to-left''). Operators closer to the top of this table have ''higher'' precedence than those in a subsequent group.

{| cellspacing=5
!Operators!!Description!!Example Usage!!Associativity
|-
!colspan=3 align=center|Postfix operators
|rowspan=5 style="border-left:1px solid gray"|Left to right
|-
|&lt;tt&gt;()&lt;/tt&gt;||function call operator||&lt;tt&gt;swap (x, y)&lt;/tt&gt;
|-
|&lt;tt&gt;[]&lt;/tt&gt;||array index operator||&lt;tt&gt;arr [i]&lt;/tt&gt;
|-
|&lt;tt&gt;.&lt;/tt&gt;||member access operator&lt;br&gt;''for an object of struct/union type&lt;br&gt;or a reference to it''||&lt;tt&gt;obj.member&lt;/tt&gt;
|-
|&lt;tt&gt;-&gt;&lt;/tt&gt;||member access operator&lt;br&gt;''for a pointer to an object of&lt;br&gt;struct/union type''||&lt;tt&gt;ptr-&gt;member&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Unary Operators
|rowspan=11 style="border-left:1px solid gray"|Right to left
|-
|&lt;tt&gt;!&lt;/tt&gt;||logical not operator||&lt;tt&gt;!eof_reached&lt;/tt&gt;
|-
|&lt;tt&gt;~&lt;/tt&gt;||bitwise not operator||&lt;tt&gt;~mask&lt;/tt&gt;
|-
|&lt;tt&gt;+ -&lt;/tt&gt;&lt;ref&gt;Very old compilers may not recognize the unary &lt;tt&gt;+&lt;/tt&gt; operator.&lt;/ref&gt;
|unary plus/minus operators||&lt;tt&gt;-num&lt;/tt&gt;
|-
|&lt;tt&gt;++ --&lt;/tt&gt;||post-increment/decrement operators||&lt;tt&gt;num++&lt;/tt&gt;
|-
|&lt;tt&gt;++ --&lt;/tt&gt;||pre-increment/decrement operators||&lt;tt&gt;++num&lt;/tt&gt;
|-
|&lt;tt&gt;&amp;&lt;/tt&gt;||address-of operator||&lt;tt&gt;&amp;data&lt;/tt&gt;
|-
|&lt;tt&gt;*&lt;/tt&gt;||indirection operator||&lt;tt&gt;*ptr&lt;/tt&gt;
|-
|&lt;tt&gt;'''sizeof'''&lt;/tt&gt;||sizeof operator ''for expressions''||&lt;tt&gt;'''sizeof''' 123&lt;/tt&gt;
|-
|&lt;tt&gt;'''sizeof'''()&lt;/tt&gt;||sizeof operator ''for types''||&lt;tt&gt;'''sizeof''' ('''int''')&lt;/tt&gt;
|-
|&lt;tt&gt;(''type'')&lt;/tt&gt;||cast operator||&lt;tt&gt;('''float''')i&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Multiplicative Operators
|rowspan=2|Left to right
|-
|&lt;tt&gt;* / %&lt;/tt&gt;||multiplication, division and&lt;br&gt;modulus operators||&lt;tt&gt;celsius_diff * 9.0 / 5.0&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Additive Operators
|rowspan=2|Left to right
|-
|&lt;tt&gt;+ -&lt;/tt&gt;||addition and subtraction operators||&lt;tt&gt;end - start + 1&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Bitwise Shift Operators
|rowspan=3 style="border-left:1px solid gray"|Left to right
|-
|&lt;tt&gt;&lt;&lt;&lt;/tt&gt;||left shift operator||&lt;tt&gt;bits &lt;&lt; shift_len&lt;/tt&gt;
|-
|&lt;tt&gt;&gt;&gt;&lt;/tt&gt;||right shift operator||&lt;tt&gt;bits &gt;&gt; shift_len&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Relational Inequality Operators
|rowspan=2|Left to right
|-
|&lt;tt&gt;&lt; &gt; &lt;= &gt;=&lt;/tt&gt;||less-than, greater-than, less-than or&lt;br&gt;equal-to, greater-than or equal-to&lt;br&gt;operators||&lt;tt&gt;i &lt; num_elements&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Relational Equality Operators
|rowspan=2|Left to right
|-
|&lt;tt&gt;== !=&lt;/tt&gt;||equal-to, not-equal-to||&lt;tt&gt;choice != 'n'&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Bitwise And Operator
|rowspan=2|Left to right
|-
|&lt;tt&gt;&amp;&lt;/tt&gt;|| ||&lt;tt&gt;bits &amp; clear_mask_complement&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Bitwise Xor Operator
|rowspan=2|Left to right
|-
|&lt;tt&gt;^&lt;/tt&gt;|| ||&lt;tt&gt;bits ^ invert_mask&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Bitwise Or Operator
|rowspan=2|Left to right
|-
||&lt;tt&gt;|&lt;/tt&gt;|| |||&lt;tt&gt;bits | set_mask&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Logical And Operator
|rowspan=2|Left to right
|-
|&lt;tt&gt;&amp;&amp;&lt;/tt&gt;|| ||&lt;tt&gt;arr != 0 &amp;&amp; arr-&gt;len != 0&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Logical Or Operator
|rowspan=2|Left to right
|-
|&lt;tt&gt;&lt;nowiki&gt;||&lt;/nowiki&gt;&lt;/tt&gt;|| ||&lt;tt&gt;&lt;nowiki&gt;arr == 0 || arr-&gt;len == 0&lt;/nowiki&gt;&lt;/tt&gt;
|-
!colspan=3 align=center|Conditional Operator
|rowspan=2|Right to left
|-
|&lt;tt&gt;?:&lt;/tt&gt;|| ||&lt;tt&gt;size != 0 ? size : 0&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Assignment Operators
|rowspan=3 style="border-left:1px solid gray"|Right to left
|-
|&lt;tt&gt;=&lt;/tt&gt;||assignment operator||&lt;tt&gt;i = 0&lt;/tt&gt;
|-
|&lt;tt&gt;+= -= *= /= &lt;br&gt;&lt;nowiki&gt;%= &amp;= |= ^=&lt;/nowiki&gt; &lt;br&gt;&lt;nowiki&gt;&lt;&lt;= &gt;&gt;=&lt;/nowiki&gt;&lt;/tt&gt;
|shorthand assignment operators&lt;br&gt;''(''&lt;tt&gt;''foo'' op= ''bar''&lt;/tt&gt;'' represents&lt;br&gt;''&lt;tt&gt;''foo'' = ''foo'' op ''bar''&lt;/tt&gt;'')''||&lt;tt&gt;num /= 10&lt;/tt&gt;
|-
|&lt;br&gt;
|-
!colspan=3 align=center|Comma Operator
|rowspan=2|Left to right
|-
|&lt;tt&gt;,&lt;/tt&gt;|| ||&lt;tt&gt;i = 0, j = i + 1, k = 0&lt;/tt&gt;
|}

==Table of data types==

{| cellspacing=20 
!Type!!Size in Bits!!Comments!!Alternative Names
|-
!colspan=4 align=center|Primitive Types in ANSI C (C89)/ISO C (C90)
|-
|&lt;tt&gt;'''char'''&lt;/tt&gt;||align=center|&amp;ge; 8
|
* &lt;tt&gt;'''sizeof'''&lt;/tt&gt; gives the size in units of &lt;tt&gt;'''char'''&lt;/tt&gt;s. These "C bytes" need not be 8-bit bytes (though commonly they are); the number of bits is given by the &lt;tt&gt;CHAR_BIT&lt;/tt&gt; macro in the &lt;tt&gt;limits.h&lt;/tt&gt; header.
* Signedness is implementation-defined.
* Any encoding of 8 bits or less (e.g. ASCII) can be used to store characters.
* Integer operations can be performed portably only for the range 0 ~ 127.
* All bits contribute to the value of the '''char''', i.e. there are no "holes" or "padding" bits.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''signed''' '''char'''&lt;/tt&gt;||align=center|same as &lt;tt&gt;'''char'''&lt;/tt&gt;
|
* Characters stored like for type &lt;tt&gt;'''char'''&lt;/tt&gt;.
* Can store integers in the range -127 ~ 127 portably&lt;ref&gt;-128 can be stored in two's-complement machines (i.e. most machines in existence). Very old compilers may not recognize the &lt;tt&gt;'''signed'''&lt;/tt&gt; keyword&lt;/ref&gt;.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''unsigned''' '''char'''&lt;/tt&gt;||align=center|same as &lt;tt&gt;'''char'''&lt;/tt&gt;
|
* Characters stored like for type &lt;tt&gt;'''char'''&lt;/tt&gt;.
* Can store integers in the range 0 ~ 255 portably.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''short'''&lt;/tt&gt;||align=center|&amp;ge; 16, &amp;ge; size of &lt;tt&gt;'''char'''&lt;/tt&gt;
|
* Can store integers in the range -32767 ~ 32767 portably&lt;ref name="ref_1"&gt;-32768 can be stored in two's-complement machines (i.e. most machines in existence). Very old compilers may not recognize the &lt;tt&gt;'''signed'''&lt;/tt&gt; keyword&lt;/ref&gt;.
* Used to reduce memory usage (although the resulting executable may be larger and probably slower as compared to using &lt;tt&gt;'''int'''&lt;/tt&gt;.
|align=center|&lt;tt&gt;'''short''' '''int'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''short'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''short''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''unsigned''' '''short'''&lt;/tt&gt;||align=center|same as &lt;tt&gt;'''short'''&lt;/tt&gt;
|
* Can store integers in the range 0 ~ 65535 portably.
* Used to reduce memory usage (although the resulting executable may be larger and probably slower as compared to using &lt;tt&gt;'''int'''&lt;/tt&gt;.
|align=center|&lt;tt&gt;'''unsigned''' '''short''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''int'''&lt;/tt&gt;||align=center|&amp;ge; 16, &amp;ge; size of &lt;tt&gt;'''short'''&lt;/tt&gt;
|
* Represents the "normal" size of data the processor deals with (the word-size); this is the integral data-type used normally.
* Can store integers in the range -32767 ~ 32767 portably&lt;ref name="ref_1" /&gt;.
|align=center|&lt;tt&gt;'''signed'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''unsigned''' '''int'''&lt;/tt&gt;||align=center|same as &lt;tt&gt;'''int'''&lt;/tt&gt;
|
* Can store integers in the range 0 ~ 65535 portably.
|align=center|&lt;tt&gt;'''unsigned'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''long'''&lt;/tt&gt;||align=center|&amp;ge; 32, &amp;ge; size of &lt;tt&gt;'''int'''&lt;/tt&gt;
|
* Can store integers in the range -2147483647 ~ 2147483647 portably&lt;ref&gt;-2147483648 can be stored in two's-complement machines (i.e. most machines in existence). Very old compilers may not recognize the &lt;tt&gt;'''signed'''&lt;/tt&gt; keyword&lt;/ref&gt;.
|align=center|&lt;tt&gt;'''long''' '''int'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''long'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''long''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''unsigned''' '''long'''&lt;/tt&gt;||align=center|same as &lt;tt&gt;'''long'''&lt;/tt&gt;
|
* Can store integers in the range 0 ~ 4294967295 portably.
|align=center|&lt;tt&gt;'''unsigned''' '''long''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''float'''&lt;/tt&gt;||align=center|&amp;ge; size of &lt;tt&gt;'''char'''&lt;/tt&gt;
|
* Used to reduce memory usage when the values used do not vary widely.
* The floating-point format used is implementation defined and need not be the IEEE single-precision format.
* &lt;tt&gt;'''unsigned'''&lt;/tt&gt; cannot be specified.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''double'''&lt;/tt&gt;||align=center|&amp;ge; size of &lt;tt&gt;'''float'''&lt;/tt&gt;
|
* Represents the "normal" size of data the processor deals with; this is the floating-point data-type used normally.
* The floating-point format used is implementation defined and need not be the IEEE double-precision format.
* &lt;tt&gt;'''unsigned'''&lt;/tt&gt; cannot be specified.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''long''' '''double'''&lt;/tt&gt;||align=center|&amp;ge; size of &lt;tt&gt;'''double'''&lt;/tt&gt;
|
* &lt;tt&gt;'''unsigned'''&lt;/tt&gt; cannot be specified.
|align=center|&amp;mdash;
|-
|&lt;br&gt;
|-
!colspan=4 align=center|Primitive Types added to ISO C (C99)
|-
|&lt;tt&gt;'''long''' '''long'''&lt;/tt&gt;||align=center|&amp;ge; 64, &amp;ge; size of &lt;tt&gt;'''long'''&lt;/tt&gt;
|
* Can store integers in the range -9223372036854775807 ~ 9223372036854775807 portably&lt;ref&gt;-9223372036854775808 can be stored in two's-complement machines (i.e. most machines in existence)&lt;/ref&gt;.
|align=center|&lt;tt&gt;'''long''' '''long''' '''int'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''long''' '''long'''&lt;/tt&gt;, &lt;tt&gt;'''signed''' '''long''' '''long''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''unsigned''' '''long''' '''long'''&lt;/tt&gt;||align=center|same as &lt;tt&gt;'''long''' '''long'''&lt;/tt&gt;
|
* Can store integers in the range 0 ~ 18446744073709551615 portably.
|align=center|&lt;tt&gt;'''unsigned''' '''long''' '''long''' '''int'''&lt;/tt&gt;
|-
|&lt;tt&gt;'''intmax_t'''&lt;/tt&gt;||align=center| the maximum width supported by the platform
|
* Can store integers in the range -(1 &lt;&lt; n-1)+1 ~ (1 &lt;&lt; n-1)-1, with 'n' the width of intmax_t.
* Used by the "j" length modifier in the [[C Programming/File IO#Formatted output functions: the printf family of functions]].
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''uintmax_t'''&lt;/tt&gt;||align=center| same as &lt;tt&gt;'''intmax_t'''&lt;/tt&gt;
|
* Can store integers in the range 0 ~ (1 &lt;&lt; n)-1, with 'n' the width of uintmax_t.
|align=center|&amp;mdash;
|-
|&lt;br&gt;
|-
!colspan=4 align=center|User Defined Types
|-
|&lt;tt&gt;'''struct'''&lt;/tt&gt;||align=center|&amp;ge; sum of size of each member
|
* Said to be an ''aggregate type''.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''union'''&lt;/tt&gt;||align=center|&amp;ge; size of the largest member
|
* Said to be an ''aggregate type''.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''enum'''&lt;/tt&gt;||align=center|&amp;ge; size of &lt;tt&gt;'''char'''&lt;/tt&gt;
|
* Enumerations are a separate type from &lt;tt&gt;'''int'''&lt;/tt&gt;s, though they are mutually convertible.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;'''typedef'''&lt;/tt&gt;||align=center|same as the type being given a name
|
* &lt;tt&gt;'''typedef'''&lt;/tt&gt; has syntax similar to a storage class like &lt;tt&gt;'''static'''&lt;/tt&gt;, &lt;tt&gt;'''register'''&lt;/tt&gt; or &lt;tt&gt;'''extern'''&lt;/tt&gt;.
|align=center|&amp;mdash;
|-
|&lt;br&gt;
|-
!colspan=4 align=center|Derived Types&lt;ref&gt;The precedences in a declaration are:
{|
|-
|| &lt;tt&gt;[]&lt;/tt&gt;, &lt;tt&gt;()&lt;/tt&gt; (left associative)      &amp;mdash; Highest 
|- 
|| &lt;tt&gt;*&lt;/tt&gt; (right associative)                   &amp;mdash; Lowest  
|}
&lt;/ref&gt;
|-
|&lt;tt&gt;''type''*&lt;/tt&gt;&lt;br&gt;&lt;br&gt;(pointer)||align=center|&amp;ge; size of &lt;tt&gt;'''char'''&lt;/tt&gt;
|
* &lt;tt&gt;0&lt;/tt&gt; always represents the null pointer (an address where no data can be placed), irrespective of what bit sequence represents the value of a null pointer.
* Pointers to different types may have different representations, which means they could also be of different sizes. So they are not convertible to one another.
* Even in an implementation which guarantess all data pointers to be of the same size, function pointers and data pointers are in general incompatible with each other.
* For functions taking variable number of arguments, the arguments passed must be of appropriate type, so even &lt;tt&gt;0&lt;/tt&gt; must be cast to the appropriate type in such function-calls.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;''type'' [''integer''&lt;ref&gt;The standards do NOT place any restriction on the size/type of the integer, it's implementation dependent.  The only mention in the standards is a reference that an implementation may have limits to the maximum size of memory block which can be allocated, and as such the limit on integer will be size_of_max_block/sizeof(type)&lt;/ref&gt;]&lt;/tt&gt;&lt;br&gt;&lt;br&gt;(array)||align=center|&amp;ge; ''integer'' &amp;times; size of &lt;tt&gt;''type''&lt;/tt&gt;
|
* The brackets (&lt;tt&gt;[]&lt;/tt&gt;) ''follow'' the identifier name in a declaration.
* In a declaration which also initializes the array (including a function parameter declaration), the size of the array (the ''integer'') can be omitted.
* &lt;tt&gt;''type'' []&lt;/tt&gt; is not the same as &lt;tt&gt;''type''*&lt;/tt&gt;. Only under some circumstances one can be converted to the other.
|align=center|&amp;mdash;
|-
|&lt;tt&gt;''type'' (''comma-delimited list of types/declarations'')&lt;/tt&gt;&lt;br&gt;&lt;br&gt;(function)||align=center|&amp;mdash;
|
* Functions declared without any storage class are &lt;tt&gt;'''extern'''&lt;/tt&gt;.
* The parentheses (&lt;tt&gt;()&lt;/tt&gt;) ''follow'' the identifier name in a declaration, e.g. a 2-arg function pointer: &lt;tt&gt;'''int''' (* fptr) ('''int''' arg1, '''int''' arg2)&lt;/tt&gt;.
|align=center|&amp;mdash;
|}

== Character sets ==
Programs written in C can read and write any character set, provided the libraries that support them are included/used.

The source code for C programs, however, is usually limited to the ASCII character set.

In a file containing source code, the end of a line is sometimes, depending on the operating system it was created on not a newline character but compilers treat the end of each line as if it were a single newline character.

Virtually all compilers allow the '''$''', '''@''', and '''`''' characters in string constants.  Many compilers also allow literal multibyte Unicode characters, but they are not portable.

Certain characters must be escaped with a backslash to represent themselves in a string or character constant.  These are:

{|
|
* &lt;tt&gt;'''\\'''&lt;/tt&gt; Literal backslash
* &lt;tt&gt;'''\"'''&lt;/tt&gt; Literal double quote
* &lt;tt&gt;'''\''''&lt;/tt&gt; Literal single quote
|
* &lt;tt&gt;'''\n'''&lt;/tt&gt; Newline
* &lt;tt&gt;'''\t'''&lt;/tt&gt; Horizontal tab
* &lt;tt&gt;'''\f'''&lt;/tt&gt; Form feed
|
* &lt;tt&gt;'''\v'''&lt;/tt&gt; Vertical tab
|}

Additionally, some compilers allow these characters:

* &lt;tt&gt;'''\r'''&lt;/tt&gt; Carriage return
* &lt;tt&gt;'''\a'''&lt;/tt&gt; Alert (audible bell)
* &lt;tt&gt;'''\b'''&lt;/tt&gt; Backspace

'''\xhh''', where the 'h' characters are hexadecimal digits, is used to represent arbitrary bytes (including '''\x00''', the zero byte).

'''\uhhhh''' or '''\Uhhhhhhhh''', where the 'h' characters are hexadecimal digits, is used to portably represent Unicode characters.

== References ==
{{reflist}}

[[et:Programmeerimiskeel C/Operaatorid]]
[[fr:Programmation C/Types de base]]
[[pl:C/Składnia]]
{{C Programming/Navigation|Code library|Compilers}}</text>
      <sha1>6fjeh1b3hvkg5g7clh3md1lz59zo9y7</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Language overloading and extensions</title>
    <ns>0</ns>
    <id>31460</id>
    <revision>
      <id>3354753</id>
      <parentid>2064810</parentid>
      <timestamp>2017-12-28T09:33:55Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <minor/>
      <comment>Strange quark moved page [[C Programming/Language extensions]] to [[C Programming/Language overloading and extensions]]: Reflect TOC list name</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1398" xml:space="preserve">{{C Programming/Navigation|Common practices|Mixing languages}}

Most C compilers have one or more "extensions" to the standard C language, to do things that are inconvenient to do in standard, portable C.

Some examples of language extensions:

* in-line assembly language
* interrupt service routines
* variable-length data structure (a structure whose last item is a "zero-length array").&lt;ref&gt;
[http://c-faq.com/struct/structhack.html comp.lang.c FAQ list: Question 2.6]: "C99 introduces the concept of a flexible array member, which allows the size of an array to be omitted if it is the last member in a structure, thus providing a well-defined solution."
&lt;/ref&gt;
* re-sizeable multidimensional arrays
* various "#pragma" settings to compile quickly, to generate fast code, or to generate compact code.
* bit manipulation, especially bit-rotations and things involving the "carry" bit
* storage alignment
* Arrays whose length is computed at run time.

== External links ==

* [http://gcc.gnu.org/onlinedocs/gcc-4.0.2/gcc/C-Extensions.html#C-Extensions GNU C: Extensions to the C Language]
* [http://www.softintegration.com/support/faq/general.html#4 C/C++ interpreter Ch extensions to the C language for scripting]
* [http://sdcc.sourceforge.net/doc/sdccman.html/node56.html SDCC: Storage Class Language Extensions]

&lt;references /&gt;
{{C Programming/Navigation|Common practices|Mixing languages}}</text>
      <sha1>m6979t4kiiv49cz8j53gd469kqqtn5a</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Libraries</title>
    <ns>0</ns>
    <id>5772</id>
    <revision>
      <id>3652948</id>
      <parentid>3583122</parentid>
      <timestamp>2020-01-14T01:17:41Z</timestamp>
      <contributor>
        <ip>2601:8B:C303:7E30:8583:EC32:BB0A:8350</ip>
      </contributor>
      <comment>Added a point</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8618" xml:space="preserve">{{C Programming/Navigation|Further math|Networking in UNIX}}

A ''library'' in C is a collection of header files, exposed for use by other programs. The library therefore consists of an ''interface'' expressed in a &lt;code&gt;.h&lt;/code&gt; file (named the "header") and an ''implementation'' expressed in a &lt;code&gt;.c&lt;/code&gt; file. This &lt;code&gt;.c&lt;/code&gt; file might be precompiled or otherwise inaccessible, or it might be available to the programmer. (Note: Libraries may call functions in other libraries such as the Standard C or math libraries to do various tasks.)

The format of a library varies with the operating system and compiler one is using. For example, in the Unix and Linux operating systems, a library consists of one or more ''object files'', which consist of object code that is usually the output of a compiler (if the source language is C or something similar) or an assembler (if the source language is assembly language). These object files are then turned into a library in the form of an archive by the ''ar'' archiver (a program that takes files and stores them in a bigger file without regard to compression). The filename for the library usually starts with "lib" and ends with ".a"; e.g. the ''libc.a'' file contains the Standard C library and the "libm.a" the mathematics routines, which the linker would then link in. Other operating systems such as Microsoft Windows use a ".lib" extension for libraries and an ".obj" extension for object files. Some programs in the Unix environment such as lex and yacc generate C code that can be linked with the libl and liby libraries to create an executable.

We're going to use as an example a library that contains one function: a function to [[w:Parsing|parse]] arguments from the command line. Arguments on the command line could be by themselves:

     -i

have an optional argument that is [http://en.wikipedia.org/wiki/Concatenate concatenated] to the letter:

     -ioptarg

or have the argument in a separate argv-element:

     -i optarg

The library also has four declarations that it exports in addition to the function: three integers and a pointer to the optional argument. If the argument does not have an optional argument, the pointer to the optional argument will be null.

In order to parse all these types of arguments, we have written the following "getopt.c" file:

&lt;source lang=c&gt;
#include &lt;stdio.h&gt;              /* for fprintf() and EOF */
#include &lt;string.h&gt;             /* for strchr() */
#include "getopt.h"             /* consistency check */

/* variables */
int opterr = 1;                 /* getopt prints errors if this is on */
int optind = 1;                 /* token pointer */
int optopt;                     /* option character passed back to user */
char *optarg;                   /* flag argument (or value) */

/* function */
/* return option character, EOF if no more or ? if problem.
	The arguments to the function:
	argc, argv - the arguments to the main() function. An argument of "--"
	stops the processing.
	opts - a string containing the valid option characters.
	an option character followed by a colon (:) indicates that
	the option has a required argument.
*/
int
getopt (int argc, char **argv, char *opts)
{
	static int sp = 1;            /* character index into current token */
	register char *cp;            /* pointer into current token */
	
	if (sp == 1)
	{
		/* check for more flag-like tokens */
		if (optind &gt;= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
			return EOF;
		else if (strcmp (argv[optind], "--") == 0)
		{
			optind++;
			return EOF;
		}
	}
	
	optopt = argv[optind][sp];
	
	if (optopt == ':' || (cp = strchr (opts, optopt)) == NULL)
	{
		if (opterr)
			fprintf (stderr, "%s: invalid option -- '%c'\n", argv[0], optopt);
		
		/* if no characters left in this token, move to next token */
		if (argv[optind][++sp] == '\0')
		{
			optind++;
			sp = 1;
		}
		
		return '?';
	}
	
	if (*++cp == ':')
	{
		/* if a value is expected, get it */
		if (argv[optind][sp + 1] != '\0')
			/* flag value is rest of current token */
			optarg = argv[optind++] + (sp + 1);
		else if (++optind &gt;= argc)
		{
			if (opterr)
				fprintf (stderr, "%s: option requires an argument -- '%c'\n",
							argv[0], optopt);
			sp = 1;
			return '?';
		}
		else
	                /* flag value is next token */
		        optarg = argv[optind++];
		sp = 1;
	}
	else
	{
		/* set up to look at next char in token, next time */
		if (argv[optind][++sp] == '\0')
		{
			/* no more in current token, so setup next token */
			sp = 1;
			optind++;
		}
		optarg = 0;
	}
	return optopt;
} 
/* END OF FILE */
&lt;/source&gt;

The interface would be the following "getopt.h" file:

&lt;source lang=c&gt;
#ifndef GETOPT_H
	#define GETOPT_H

	/* exported variables */
	extern int opterr, optind, optopt;
	extern char *optarg;

	/* exported function */
	int getopt(int, char **, char *);
#endif

/* END OF FILE */
&lt;/source&gt;

At a minimum, a programmer has the interface file to figure out how to use a library, although, in general, the library programmer also wrote documentation on how to use the library. In the above case, the documentation should say that the provided arguments &lt;code&gt;**argv&lt;/code&gt; and &lt;code&gt;*opts&lt;/code&gt; both shouldn't be null pointers (or why would you be using the &lt;code&gt;getopt&lt;/code&gt; function anyway?). Specifically, it typically states what each parameter is for and what return values can be expected in which conditions. Programmers that use a library, are normally not interested in the implementation of the library -- unless the implementation has a bug, in which case he would want to complain somehow.

Both the implementation of the getopts library, and programs that use the library should state &lt;code&gt;#include "getopt.h"&lt;/code&gt;, in order to refer to the corresponding interface. Now the library is "linked" to the program -- the one that contains the main() function. The program may refer to dozens of interfaces.

In some cases, just placing &lt;code&gt;#include "getopt.h"&lt;/code&gt; may appear correct but will still fail to link properly. This indicates that the library is not installed correctly, or there may be some additional configuration required. You will have to check either the compiler's documentation or library's documentation on how to resolve this issue.

== What to put in header files ==

As a general rule, headers should contain any declarations and macro definitions (preprocessor &lt;code&gt;#define&lt;/code&gt;s) to be "seen" by the other modules in a program.

Possible declarations:
* struct, union, and enum declarations
* typedef declarations
* external function declarations
* global variable declarations

In the above &lt;code&gt;getopt.h&lt;/code&gt; example file, one function (&lt;code&gt;getopt&lt;/code&gt;) is declared and four global variables (&lt;code&gt;optind&lt;/code&gt;, &lt;code&gt;optopt&lt;/code&gt;, &lt;code&gt;optarg&lt;/code&gt;, and &lt;code&gt;opterr&lt;/code&gt;) are also declared. The variables are declared with the storage class specifier &lt;code&gt;extern&lt;/code&gt; in the header file because that keyword specifies that the "real" variables are stored elsewhere (i.e. the &lt;code&gt;getopt.c&lt;/code&gt; file) and not within the header file.

The &lt;code&gt;#ifndef GETOPT_H/#define GETOPT_H&lt;/code&gt; trick is colloquially called &lt;b&gt;include guards&lt;/b&gt;. This is used so that if the &lt;code&gt;getopt.h&lt;/code&gt; file were included more than once in a translation unit, the unit would only see the contents once. Alternatively, &lt;code&gt;[[w:Pragma_once|#pragma once]]&lt;/code&gt; in a header file can also be used to achieve the same thing in some compilers (&lt;code&gt;#pragma&lt;/code&gt; is an unportable catchall).

== Linking Libraries Into Executables ==

Linking libraries into executables varies by operating system and compiler/linker used. In Unix, directories of linked object files can be specified with the &lt;tt&gt;-L&lt;/tt&gt; option to the cc command and individual libraries are specified with the &lt;tt&gt;-l&lt;/tt&gt; (small ell) option. The &lt;tt&gt;-lm&lt;/tt&gt; option specifies that the libm math library should be linked in, for example.

== References ==
{{reflist}}
* [http://c-faq.com/cpp/hfiles.html C FAQ: "I'm wondering what to put in .c files and what to put in .h files. (What does ".h" mean, anyway?)"]
* [http://www.piclist.com/techref/postbot.asp?by=time&amp;id=piclist\2007\10\25\073430a&amp;tgt=post PIClist thread: "Global variables in projects with many C files."]
* [http://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files-in-c "How do I use extern to share variables between source files in C?"].

{{C Programming/Navigation|Further math|Networking in UNIX}}

[[fr:Programmation C/Bibliothèque standard]]
[[pl:C/Biblioteki]]</text>
      <sha1>ly78lqhhj8la5pdxbnea8f3729tk9aq</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/MS Windows Reference</title>
    <ns>0</ns>
    <id>393587</id>
    <revision>
      <id>3427391</id>
      <parentid>3347296</parentid>
      <timestamp>2018-05-23T22:12:22Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <comment>/* Header files */ Fix formatting</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="575" xml:space="preserve">== Header files ==

{| class="wikitable"
|-
|&lt;tt&gt;[[#alloc.h|alloc.h]]&lt;/tt&gt; || Dynamic memory allocation.
|-
|&lt;tt&gt;[[#conio.h|conio.h]]&lt;/tt&gt; || Text user interfaces.
|-
|&lt;tt&gt;[[#process.h|process.h]]&lt;/tt&gt; || Threads and processes.
|}

== Table of functions ==

=== [[/alloc.h|alloc.h]] ===

{|
|
* &lt;tt&gt;[[/alloc.h/farmalloc|farmalloc]]&lt;/tt&gt;
|}

=== [[/conio.h|conio.h]] ===

{|
|
* &lt;tt&gt;[[/conio.h/getch|getch]]&lt;/tt&gt;
* &lt;tt&gt;[[/conio.h/getche|getche]]&lt;/tt&gt;
* &lt;tt&gt;[[/conio.h/gotoxy|gotoxy]]&lt;/tt&gt;
* &lt;tt&gt;[[/conio.h/clrscr|clrscr]]&lt;/tt&gt;
|}

=== [[/process.h|process.h]] ===

{{BookCat}}</text>
      <sha1>q2j363b296g0rebhbjr803h7ow0iyhb</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Memory management</title>
    <ns>0</ns>
    <id>927</id>
    <revision>
      <id>3436981</id>
      <parentid>3400496</parentid>
      <timestamp>2018-06-19T23:41:52Z</timestamp>
      <contributor>
        <ip>2A00:23C4:150C:5700:7979:D87B:5A7C:5E1D</ip>
      </contributor>
      <comment>replaced faulty example with code that actually frees the whole tree</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="11263" xml:space="preserve">{{C Programming/Navigation|Pointers and arrays|Error handling}}

In C, you have already considered creating variables for use in the program. You have created some arrays for use, but you may have already noticed some limitations:
* the size of the array must be known beforehand 
* the size of the array cannot be changed in the duration of your program

''Dynamic memory allocation'' in C is a way of circumventing these problems.

==The &lt;code&gt;malloc&lt;/code&gt; function==
&lt;source lang=c&gt;
#include &lt;stdlib.h&gt;
void *calloc(size_t nmemb, size_t size);
void free(void *ptr);
void *malloc(size_t size);
void *realloc(void *ptr, size_t size);
&lt;/source&gt;
The standard C function &lt;code&gt;malloc&lt;/code&gt; is the means of implementing dynamic memory allocation. It is defined in stdlib.h or malloc.h, depending on what operating system you may be using. Malloc.h contains only the definitions for the memory allocation functions and not the rest of the other functions defined in stdlib.h. Usually you will not need to be so specific in your program, and if both are supported, you should use &lt;stdlib.h&gt;, since that is ANSI C, and what we will use here.

The corresponding call to release allocated memory back to the operating system is &lt;code&gt;free&lt;/code&gt;.

When dynamically allocated memory is no longer needed, &lt;code&gt;free&lt;/code&gt; should be called to release it back to the memory pool.  Overwriting a pointer that points to dynamically allocated memory can result in that data becoming inaccessible.  If this happens frequently, eventually the operating system will no longer be able to allocate more memory for the process.  Once the process exits, the operating system is able to free all dynamically allocated memory associated with the process.

Let's look at how dynamic memory allocation can be used for arrays.

Normally when we wish to create an array we use a declaration such as
&lt;source lang=c&gt;
int array[10];
&lt;/source&gt;

Recall &lt;code&gt;array&lt;/code&gt; can be considered a pointer which we use as an array. We specify the length of this array is 10 &lt;code&gt;int&lt;/code&gt;s. After &lt;code&gt;array[0]&lt;/code&gt;, nine other integers have space to be stored consecutively.

Sometimes it is not known at the time the program is written how much memory will be needed for some data. In this case we would want to dynamically allocate required memory after the program has started executing.
To do this we only need to declare a pointer, and invoke &lt;code&gt;malloc&lt;/code&gt; when we wish to make space for the  elements in our array, ''or'', we can tell &lt;code&gt;malloc&lt;/code&gt; to make space when we first initialize the array. Either way is acceptable and useful.

We also need to know how much an int takes up in memory in order to make room for it; fortunately this is not difficult, we can use C's builtin &lt;code&gt;sizeof&lt;/code&gt; operator. For example, if &lt;code&gt;sizeof(int)&lt;/code&gt; yields 4, then one &lt;code&gt;int&lt;/code&gt; takes up 4 bytes. Naturally, &lt;code&gt;2*sizeof(int)&lt;/code&gt; is how much memory we need for 2 &lt;code&gt;int&lt;/code&gt;s, and so on.

So how do we &lt;code&gt;malloc&lt;/code&gt; an array of ten &lt;code&gt;int&lt;/code&gt;s like before? If we wish to declare and make room in one hit, we can simply say
&lt;source lang=c&gt;
int *array = malloc(10*sizeof(int));
&lt;/source&gt;
We only need to declare the pointer; &lt;code&gt;malloc&lt;/code&gt; gives us some space to store the 10 &lt;code&gt;int&lt;/code&gt;s, and returns the pointer to the first element, which is assigned to that pointer.

'''Important note!''' &lt;code&gt;malloc&lt;/code&gt; does ''not'' initialize the array; this means that the array may contain random or unexpected values! Like creating arrays without dynamic allocation, the programmer must initialize the array with sensible values before using it. Make sure you do so, too. (''See later the function &lt;code&gt;memset&lt;/code&gt; for a simple method.)

It is not necessary to immediately call &lt;code&gt;malloc&lt;/code&gt; after declaring a pointer for the allocated memory.
Often a number of statements exist between the declaration and the call to &lt;code&gt;malloc&lt;/code&gt;, as follows:

&lt;source lang=c&gt;
int *array = NULL;
printf("Hello World!!!");
/* more statements */
array = malloc(10*sizeof(int)); /* delayed allocation */
/* use the array */
&lt;/source&gt;
=== Error checking ===
When we want to use &lt;code&gt;malloc&lt;/code&gt;, we have to be mindful that the pool of memory available to the programmer is ''finite''. As such, we can conceivably run out of memory! In this case, &lt;code&gt;malloc&lt;/code&gt; will return &lt;code&gt;NULL&lt;/code&gt;. In order to stop the program crashing from having no more memory to use, one should always check that malloc has not returned &lt;code&gt;NULL&lt;/code&gt; before attempting to use the memory; we can do this by 
&lt;source lang=c&gt;
int *pt = malloc(3 * sizeof(int));
if(pt == NULL)
{
   fprintf(stderr, "Out of memory, exiting\n");
   exit(1);
}
&lt;/source&gt;

Of course, suddenly quitting as in the above example is not always appropriate, and depends on the problem you are trying to solve and the architecture you are programming for. For example, if the program is a small, non critical application that's running on a desktop quitting may be appropriate. However if the program is some type of editor running on a desktop, you may want to give the operator the option of saving their tediously entered information instead of just exiting the program.  A memory allocation failure in an embedded processor, such as might be in a washing machine, could cause an automatic reset of the machine.  For this reason, many embedded systems designers avoid dynamic memory allocation altogether.

==The &lt;code&gt;calloc&lt;/code&gt; function==
The &lt;code&gt;calloc&lt;/code&gt; function allocates space for an array of items and initializes the memory to zeros.  The call &lt;code&gt;mArray = calloc( count, sizeof(struct V))&lt;/code&gt; allocates &lt;code&gt;count&lt;/code&gt; objects, each of whose size is sufficient to contain an instance of the structure &lt;code&gt;struct V&lt;/code&gt;. The space is initialized to all bits zero. The function returns either a pointer to the allocated memory or, if the allocation fails, &lt;code&gt;NULL&lt;/code&gt;.

==The &lt;code&gt;realloc&lt;/code&gt; function==


&lt;source lang=c&gt; void * realloc ( void * ptr, size_t size ); &lt;/source&gt;
 
The &lt;code&gt;realloc&lt;/code&gt; function changes the size of the object pointed to by &lt;code&gt;ptr&lt;/code&gt; to the size specified by &lt;code&gt;size&lt;/code&gt;. The contents of the object shall be unchanged up to the lesser of the new and old sizes. If the new size is larger, the value of the newly allocated portion of the object is indeterminate. If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the &lt;code&gt;realloc&lt;/code&gt; function behaves like the &lt;code&gt;malloc&lt;/code&gt; function for the specified size. Otherwise, if &lt;code&gt;ptr&lt;/code&gt; does not match a pointer earlier returned by the &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, or &lt;code&gt;realloc&lt;/code&gt; function, or if the space has been deallocated by a call to the &lt;code&gt;free&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt; function, the behavior is undefined.  If the space cannot be allocated, the object pointed to by &lt;code&gt;ptr&lt;/code&gt; is unchanged. If &lt;code&gt;size&lt;/code&gt; is zero and &lt;code&gt;ptr&lt;/code&gt; is not a null pointer, the object pointed to is freed.  The &lt;code&gt;realloc&lt;/code&gt; function returns either a null pointer or a pointer to the possibly moved allocated object.

==The &lt;code&gt;free&lt;/code&gt; function==
Memory that has been allocated using &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, or &lt;code&gt;calloc&lt;/code&gt; must be released back to the system memory pool once it is no longer needed. This is done to avoid perpetually allocating more and more memory, which could result in an eventual memory allocation failure.  Memory that is not released with &lt;code&gt;free&lt;/code&gt; is however released when the current program terminates on most operating systems. Calls to &lt;code&gt;free&lt;/code&gt; are as in the following example.

&lt;source lang=c&gt;
int *myStuff = malloc( 20 * sizeof(int)); 
if (myStuff != NULL) 
{
   /* more statements here */
   /* time to release myStuff */
   free( myStuff );
}
&lt;/source&gt;

=== free with recursive data structures ===
It should be noted that &lt;code&gt;free&lt;/code&gt; is neither intelligent nor recursive.  The following code that depends on the recursive application of free to the internal variables of a [[C Programming/Complex types|struct]] does not work.

&lt;source lang=c&gt;
typedef struct BSTNode 
{
   int value; 
   struct BSTNode* left;
   struct BSTNode* right;
} BSTNode;

// Later: ... 

BSTNode* temp = (BSTNode*) calloc(1, sizeof(BSTNode));
temp-&gt;left = (BSTNode*) calloc(1, sizeof(BSTNode));

// Later: ... 

free(temp); // WRONG! don't do this!
&lt;/source&gt;
The statement "&lt;code&gt;free(temp);&lt;/code&gt;" will '''not''' free &lt;code&gt;temp-&gt;left&lt;/code&gt;, causing a memory leak. The correct way is to define a function that frees ''every'' node in the data structure:

&lt;source lang=c&gt;
void BSTFree(BSTNode* node){
    if (node != NULL) {
        BSTFree(node-&gt;left);
        BSTFree(node-&gt;right);
        free(node);
    }
}
&lt;/source&gt;

Because C does not have a garbage collector, C programmers are responsible for making sure there is a &lt;code&gt;free()&lt;/code&gt; exactly once for each time there is a &lt;code&gt;malloc()&lt;/code&gt;.
If a tree has been allocated one node at a time, then it needs to be freed one node at a time.

=== Don't free undefined pointers ===
Furthermore, using &lt;code&gt;free&lt;/code&gt; when the pointer in question was never allocated in the first place often crashes or leads to mysterious bugs further along.

To avoid this problem, always initialize pointers when they are declared.
Either use &lt;code&gt;malloc&lt;/code&gt; at the point they are declared (as in most examples in this chapter), or set them to &lt;code&gt;NULL&lt;/code&gt; when they are declared (as in the "delayed allocation" example in this chapter).
&lt;ref&gt;
[https://bugzilla.mozilla.org/show_bug.cgi?id=478901 "Bug 478901 ... libpng-1.2.34 and earlier might free undefined pointers"]
&lt;/ref&gt;

=== Write constructor/destructor functions ===
One way to get memory initialization and destruction right is to imitate object-oriented programming. In this paradigm, objects are constructed after raw memory is allocated for them, live their lives, and when it is time for them to be destructed, a special function called a destructor destroys the object's innards before the object itself is destroyed.

For example:

&lt;source lang=c&gt;
#include &lt;stdlib.h&gt; /* need malloc and friends */

/* this is the type of object we have, with a single int member */
typedef struct WIDGET_T {
  int member;
} WIDGET_T;

/* functions that deal with WIDGET_T */

/* constructor function */
void
WIDGETctor (WIDGET_T *this, int x)
{
  this-&gt;member = x;
}

/* destructor function */
void
WIDGETdtor (WIDGET_T *this)
{
  /* In this case, I really don't have to do anything, but
     if WIDGET_T had internal pointers, the objects they point to
     would be destroyed here.  */
  this-&gt;member = 0;
}

/* create function - this function returns a new WIDGET_T */
WIDGET_T *
WIDGETcreate (int m)
{
  WIDGET_T *x = 0;

  x = malloc (sizeof (WIDGET_T));
  if (x == 0)
    abort (); /* no memory */
  WIDGETctor (x, m);
  return x;
}

/* destroy function - calls the destructor, then frees the object */
void
WIDGETdestroy (WIDGET_T *this)
{
  WIDGETdtor (this);
  free (this);
}

/* END OF CODE */
&lt;/source&gt;

{{C Programming/Navigation|Pointers and arrays|Error handling}}

==References==
{{reflist}}

* [[Memory Management]]</text>
      <sha1>2eng4zle9bfz7grwvdiwhhmc8w5ajqz</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Mixing languages</title>
    <ns>0</ns>
    <id>31461</id>
    <revision>
      <id>3593718</id>
      <parentid>2763243</parentid>
      <timestamp>2019-11-04T21:04:02Z</timestamp>
      <contributor>
        <username>Comp.arch</username>
        <id>943323</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2767" xml:space="preserve">{{C Programming/Navigation|Language extensions|GObject}}

==Assembler==

See [[Embedded Systems/Mixed C and Assembly Programming]]

==Cg==
Make the main program (for CPU) in C, which loads and run the [[Cg_(programming_language)|Cg]] program ( for GPU ).&lt;ref&gt;[http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=47 Lesson: 47 from NeHe Productions]&lt;/ref&gt;&lt;ref&gt;[http://www.gamedev.net/reference/articles/article1903.asp Cg Bumpmapping by Razvan Surdulescu at GameDev]&lt;/ref&gt;&lt;ref&gt;[http://www.fusionindustries.com/default.asp?page=cg-hlsl-faq | Cg &amp; HLSL Shading Language FAQ
 by Fusion Industries]&lt;/ref&gt;

===Header files===
Add to C program:&lt;ref&gt;http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_b.html NVidia Cg tutorial. Appendix B. The Cg Runtime&lt;/ref&gt;
&lt;source lang="c"&gt;
#include &lt;Cg/cg.h&gt; /* To include the core Cg runtime API into your  program */
#include &lt;Cg/cgGL.h&gt;  /* to include the OpenGL-specific Cg runtime API */
&lt;/source&gt;

===Minimal program===
* by bobobobo&lt;ref&gt;[http://bobobobo.wordpress.com/2008/10/05/cg-1/ Absolutely minimal CG program for good fundamentals understanding]&lt;/ref&gt;

==Java==
Using the Java native interface (JNI), Java applications can call C libraries.

See also
* [[Java_Programming/Keywords/native]]

==Perl==
To mix Perl and C, we can use XS. XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl.

The basic procedure is very simple. We can create the necessary subdirectory structure by running "h2xs" application (e.g. "h2xs -A -n Modulename"). This will create - among others - a Makefile.PL, a .pm Perl module and a .xs XSUB file in the subdirectory tree. We can edit the .xs file by adding our code to that, let's say:
 void
 hello()
   CODE:
     printf("Hello, world!\n");
and we can successfully use our new command at Perl side, after running a "perl Makefile.PL" and "make".

Further details can be found on the [http://perldoc.perl.org/perlxstut.html perlxstut] [http://perldoc.perl.org perldoc] page.

==Python==
[http://docs.python.org/3/extending/extending.html Here can be found some details about extending Python with modules written in C]. You might read about [http://cython.org/ Cython] and [http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/ Pyrex] as well, that makes easier to create modules in C, translating a Python-like code into C.
{{sect-stub}}
Using the Python [https://docs.python.org/2/library/ctypes.html ctypes] module, one can write C code directly into Python.

==Further reading==
* [[Embedded Systems/Mixed C and Assembly Programming]]

==References==
&lt;references/&gt;

[[pl:C/Łączenie z innymi językami]]
{{C Programming/Navigation|Language extensions|Code library}}</text>
      <sha1>929kf7gwvyjaiuhv1ziefabvxo55f9s</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Networking in UNIX</title>
    <ns>0</ns>
    <id>12385</id>
    <revision>
      <id>3137542</id>
      <parentid>3131329</parentid>
      <timestamp>2016-10-21T17:37:33Z</timestamp>
      <contributor>
        <username>Fuxx</username>
        <id>99199</id>
      </contributor>
      <comment>man connect: The addrlen argument specifies the size of addr.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9840" xml:space="preserve">{{C Programming/Navigation|Complex types|Common practices}}

Network programming under UNIX is relatively simple in C.

This guide assumes you already have a good general idea about C, UNIX and networks.


==A simple client==

To start with, we'll look at one of the simplest things you can do: initialize a stream connection and receive a message from a remote server.
&lt;source lang=c&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
 
#define MAXRCVLEN 500
#define PORTNUM 2300
 
int main(int argc, char *argv[])
{
   char buffer[MAXRCVLEN + 1]; /* +1 so we can add null terminator */
   int len, mysocket;
   struct sockaddr_in dest; 
 
   mysocket = socket(AF_INET, SOCK_STREAM, 0);
  
   memset(&amp;dest, 0, sizeof(dest));                /* zero the struct */
   dest.sin_family = AF_INET;
   dest.sin_addr.s_addr = htonl(INADDR_LOOPBACK); /* set destination IP number - localhost, 127.0.0.1*/ 
   dest.sin_port = htons(PORTNUM);                /* set destination port number */
 
   connect(mysocket, (struct sockaddr *)&amp;dest, sizeof(struct sockaddr_in));
  
   len = recv(mysocket, buffer, MAXRCVLEN, 0);
 
   /* We have to null terminate the received data ourselves */
   buffer[len] = '\0';
 
   printf("Received %s (%d bytes).\n", buffer, len);
 
   close(mysocket);
   return EXIT_SUCCESS;
}
&lt;/source&gt;

This is the very bare bones of a client; in practice, we would check every function that we call for failure, however, error checking has been left out for clarity.

As you can see, the code mainly revolves around &lt;code&gt;dest&lt;/code&gt; which is a struct of type &lt;code&gt;sockaddr_in&lt;/code&gt;. This struct stores information about the machine we want to connect to.

&lt;source lang=c&gt;
mysocket = socket(AF_INET, SOCK_STREAM, 0);
&lt;/source&gt;

The &lt;code&gt;socket()&lt;/code&gt; function tells our OS that we want a file descriptor for a socket which we can use for a network stream connection; what the parameters mean is mostly irrelevant for now.

&lt;source lang=c&gt;
memset(&amp;dest, 0, sizeof(dest));                /* zero the struct */
dest.sin_family = AF_INET;
dest.sin_addr.s_addr = inet_addr("127.0.0.1"); /* set destination IP number */ 
dest.sin_port = htons(PORTNUM);                /* set destination port number */
&lt;/source&gt;

Now we get on to the interesting part:

The first line uses &lt;code&gt;memset()&lt;/code&gt; to zero the struct.

The second line sets the address family. This should be the same value that was passed as the first parameter to &lt;code&gt;socket()&lt;/code&gt;; for most purposes &lt;code&gt;AF_INET&lt;/code&gt; will serve.

The third line is where we set the IP of the machine we need to connect to. The variable &lt;code&gt;dest.sin_addr.s_addr&lt;/code&gt; is just an integer stored in Big Endian format, but we don't have to know that as the &lt;code&gt;inet_addr()&lt;/code&gt; function will do the conversion from string into Big Endian integer for us.

The fourth line sets the destination port number. The &lt;code&gt;htons()&lt;/code&gt; function converts the port number into a Big Endian short integer. If your program is going to be run solely on machines which use Big Endian numbers as default then &lt;code&gt;dest.sin_port = 21&lt;/code&gt; would work just as well. However, for portability reasons &lt;code&gt;htons()&lt;/code&gt; should always be used.

Now that all of the preliminary work is done, we can actually make the connection and use it:

&lt;source lang=c&gt;
connect(mysocket, (struct sockaddr *)&amp;dest, sizeof(struct sockaddr_in));
&lt;/source&gt;

This tells our OS to use the socket &lt;code&gt;mysocket&lt;/code&gt; to create a connection to the machine specified in &lt;code&gt;dest&lt;/code&gt;.

&lt;source lang=c&gt;
len = recv(mysocket, buffer, MAXRCVLEN, 0);
&lt;/source&gt;

Now this receives up to &lt;code&gt;MAXRCVLEN&lt;/code&gt; bytes of data from the connection and stores them in the buffer string. The number of characters received is returned by &lt;code&gt;recv()&lt;/code&gt;. It is important to note that the data received will not automatically be null terminated when stored in the buffer, so we need to do it ourselves with &lt;code&gt;buffer[len] = '\0'&lt;/code&gt;.

And that's about it!

The next step after learning how to receive data is learning how to send it. If you've understood the previous section then this is quite easy. All you have to do is use the &lt;code&gt;send()&lt;/code&gt; function, which uses the same parameters as &lt;code&gt;recv()&lt;/code&gt;. If in our previous example &lt;code&gt;buffer&lt;/code&gt; had the text we wanted to send and its length was stored in &lt;code&gt;len&lt;/code&gt; we would write &lt;code&gt;send(mysocket, buffer, len, 0)&lt;/code&gt;. &lt;code&gt;send()&lt;/code&gt; returns the number of bytes that were sent. It is important to remember that &lt;code&gt;send()&lt;/code&gt;, for various reasons, may not be able to send all of the bytes, so it is important to check that its return value is equal to the number of bytes you tried to send. In most cases this can be resolved by resending the unsent data.

==A simple server==
&lt;source lang=c&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
 
#define PORTNUM 2300
 
int main(int argc, char *argv[])
{
    char* msg = "Hello World !\n";
  
    struct sockaddr_in dest; /* socket info about the machine connecting to us */
    struct sockaddr_in serv; /* socket info about our server */
    int mysocket;            /* socket used to listen for incoming connections */
    socklen_t socksize = sizeof(struct sockaddr_in);

    memset(&amp;serv, 0, sizeof(serv));           /* zero the struct before filling the fields */
    serv.sin_family = AF_INET;                /* set the type of connection to TCP/IP */
    serv.sin_addr.s_addr = htonl(INADDR_ANY); /* set our address to any interface */
    serv.sin_port = htons(PORTNUM);           /* set the server port number */    

    mysocket = socket(AF_INET, SOCK_STREAM, 0);
  
    /* bind serv information to mysocket */
    bind(mysocket, (struct sockaddr *)&amp;serv, sizeof(struct sockaddr));

    /* start listening, allowing a queue of up to 1 pending connection */
    listen(mysocket, 1);
    int consocket = accept(mysocket, (struct sockaddr *)&amp;dest, &amp;socksize);
  
    while(consocket)
    {
        printf("Incoming connection from %s - sending welcome\n", inet_ntoa(dest.sin_addr));
        send(consocket, msg, strlen(msg), 0); 
        close(consocket);
        consocket = accept(mysocket, (struct sockaddr *)&amp;dest, &amp;socksize);
    }

    close(mysocket);
    return EXIT_SUCCESS;
}
&lt;/source&gt;

Superficially, this is very similar to the client. The first important difference is that rather than creating a &lt;code&gt;sockaddr_in&lt;/code&gt; with information about the machine we're connecting to, we create it with information about the server, and then we &lt;code&gt;bind()&lt;/code&gt; it to the socket. This allows the machine to know the data received on the port specified in the &lt;code&gt;sockaddr_in&lt;/code&gt; should be handled by our specified socket.

The &lt;code&gt;listen()&lt;/code&gt; function then tells our program to start listening using the given socket. The second parameter of &lt;code&gt;listen()&lt;/code&gt; allows us to specify the maximum number of connections that can be queued. Each time a connection is made to the server it is added to the queue. We take connections from the queue using the &lt;code&gt;accept()&lt;/code&gt; function. If there is no connection waiting on the queue the program waits until a connection is received. The &lt;code&gt;accept()&lt;/code&gt; function returns another socket. This socket is essentially a "session" socket, and can be used solely for communicating with connection we took off the queue. The original socket (&lt;code&gt;mysocket&lt;/code&gt;) continues to listen on the specified port for further connections.

Once we have "session" socket we can handle it in the same way as with the client, using &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; to handle data transfers.

Note that this server can only accept one connection at a time; if you want to simultaneously handle multiple clients then you'll need to &lt;code&gt;fork()&lt;/code&gt; off separate processes, or use threads, to handle the connections.

==Useful network functions==
&lt;source lang=c&gt;
int gethostname(char *hostname, size_t size);
&lt;/source&gt;

The parameters are a pointer to an array of chars and the size of that array. If possible, it finds the hostname and stores it in the array.  On failure it returns -1.

&lt;source lang=c&gt;
struct hostent *gethostbyname(const char *name);
&lt;/source&gt;

This function obtains information about a domain name and stores it in a &lt;code&gt;hostent&lt;/code&gt; struct. The most useful part of a &lt;code&gt;hostent&lt;/code&gt; structure is the &lt;code&gt;(char**) h_addr_list&lt;/code&gt; field, which is a null terminated array of the IP addresses associated with that domain. The field &lt;code&gt;h_addr&lt;/code&gt; is a pointer to the first IP address in the &lt;code&gt;h_addr_list&lt;/code&gt; array. Returns &lt;code&gt;NULL&lt;/code&gt; on failure.

==FAQs==

===What about stateless connections?===

If you don't want to exploit the properties of TCP in your program and would rather just use a UDP connection, then you can just replace &lt;code&gt;SOCK_STREAM&lt;/code&gt; with &lt;code&gt;SOCK_DGRAM&lt;/code&gt; in your call to &lt;code&gt;socket()&lt;/code&gt; and use the result in the same way. It is important to remember that UDP does not guarantee delivery of packets and order of delivery, so checking is important.

If you want to exploit the properties of UDP, then you can use &lt;code&gt;sendto()&lt;/code&gt; and &lt;code&gt;recvfrom()&lt;/code&gt;, which operate like &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; except you need to provide extra parameters specifying who you are communicating with.

===How do I check for errors?===

The functions &lt;code&gt;socket()&lt;/code&gt;, &lt;code&gt;recv()&lt;/code&gt; and &lt;code&gt;connect()&lt;/code&gt; all return -1 on failure and use errno for further details.
{{C Programming/Navigation|Complex types|Common practices}}</text>
      <sha1>fkbij4w6ebqwojwg5b3048tc22sd8ga</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Obtaining a compiler</title>
    <ns>0</ns>
    <id>31449</id>
    <revision>
      <id>3538686</id>
      <parentid>3438037</parentid>
      <timestamp>2019-04-21T20:11:57Z</timestamp>
      <contributor>
        <username>N3rd4i</username>
        <id>2976932</id>
      </contributor>
      <comment>added guide to install GCC within WSL in Windows</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9504" xml:space="preserve">{{C Programming/Navigation|What you need before you can learn|Intro exercise}}
{{expand}}
===Dev-C++===
{{ Wikipedia | Dev-C++ }}

[[w:Dev-C Plus Plus|Dev C++]] is an Integrated Development Environment(IDE) for the C++ programming language, available from [http://www.bloodshed.net/ Bloodshed Software]. An updated version is available at [http://orwelldevcpp.blogspot.com/ Orwell Dev-C++].&lt;br /&gt;
C++ is a programming language which contains within itself most of the C language, plus extensions. Most C++ compilers will compile C programs, sometimes with a few adjustments (like invoking them with a different name or command line switch). Therefore, you can use Dev C++ for C development.

However, Dev C++ is not the compiler. It is designed to use the [[w:MinGW|MinGW]] or [[w:Cygwin|Cygwin]] versions of [[Wikipedia:GCC|GCC]] - both of which can be obtained as part of the Dev C++ package, although they are completely different projects. &lt;br /&gt;
Dev C++ simply provides an editor, syntax highlighting, some facilities for the visualisation of code (like class and package browsing) and a graphical interface to the chosen compiler. Because Dev C++ analyses the error messages produced by the compiler and attempts to distinguish the line numbers from the errors themselves, the use of other compiler software is discouraged since the format of their error messages is likely to be different.

The latest version of Dev-C++ is a [[Wikipedia:beta version|beta]] for version 5. However, it still has a significant number of bugs. All the features are there, and it is quite usable. It is considered one of the best free software C IDEs available for Windows.

A version of Dev C++ for Linux is in the pipeline. It is not quite usable yet, however. Linux users already have a wealth of IDEs available. (e.g. [[w:KDevelop|KDevelop]] and [[w:Anjuta|Anjuta]].) Most of the graphical text editors, and other common editors such as ''emacs'' and ''vim'', support [[w:syntax highlighting|syntax highlighting]].


;Steps for Obtaining Dev-C++ if You're on Windows:
# Go to https://sourceforge.net/projects/orwelldevcpp/ and pick the download option.
# The setup is pretty straight forward. Make sure the compiler option is ticked.
# You can now use the environment provided by the software to write and run your code.
# OPTIONALLY: "C:\Program Files (x86)\Dev-Cpp\MinGW64\bin" can be added to the global PATH variable of the operating system to compile with gcc from a command prompt.



===GCC===
The [[w:GNU Compiler Collection|GNU Compiler Collection]] (GCC) is a [[w:free software|free/libre]] set of compilers developed by the [[w:Free Software Foundation|Free Software Foundation]].


;Steps for Obtaining the GCC Compiler if You're on GNU/Linux:
On '''GNU/Linux,''' Installing the GNU C Compiler can vary in method from [[w:Linux distribution|distribution]] to distribution. (Type in '''cc -v''' to see if it is installed already.)
* For [[w:Ubuntu|Ubuntu]], install the GCC compiler (along with other necessary tools) by using &lt;code&gt;sudo [[w:Advanced Packaging Tool|apt]] install build-essential&lt;/code&gt;,  or by using Synaptic. You do not need Universe enabled.
* For [[w:Debian|Debian]], install the GCC compiler (as root) by using &lt;code&gt;[[w:Advanced Packaging Tool|apt]] install gcc&lt;/code&gt;.
* For [[w:Fedora Core|Fedora Core]], install the GCC compiler (as root) by using &lt;code&gt;[[w:yum|yum]] install gcc&lt;/code&gt;.
* For [[w:Redhat|Redhat]], get a GCC [[w:RPM Package Manager|RPM]], e.g. using Rpmfind and then install (as root) using &lt;code&gt;rpm -ivh gcc-''version''-''release''.''arch''.rpm&lt;/code&gt;
* For [[w:Mandrake|Mandrake]], install the GCC compiler (as root) by using &lt;code&gt;[[w:urpmi|urpmi]] gcc&lt;/code&gt;
* For [[w:Slackware|Slackware]], the package is available on their [http://www.slackware.com/pb/ website] - simply download, and type &lt;code&gt;installpkg gcc-xxxxx.tgz&lt;/code&gt;
* For [[w:Gentoo|Gentoo]], you should already have GCC installed as it will have been used when you first installed.  To update it run (as root) &lt;code&gt;emerge -uav gcc&lt;/code&gt;.
* For [[w:Arch Linux|Arch Linux]], install the GCC compiler (as root) by using &lt;code&gt;pacman -S gcc&lt;/code&gt;.
* If you cannot become root, get the GCC tarball from ftp://ftp.gnu.org/ and follow the instructions in it to compile and install in your home directory. Be warned though, you need a C compiler to do that - yes, GCC itself is written in C.
* You can use a commercial C compiler/IDE.


;Steps for Obtaining the GCC Compiler if You're on BSD Family Systems:
* For [[w:Mac OS X|Mac OS X]], [[w:FreeBSD|FreeBSD]], [[w:NetBSD|NetBSD]], [[w:OpenBSD|OpenBSD]], [[w:DragonFly BSD|DragonFly BSD]], [[w:Darwin|Darwin]] the port of GNU gcc is available in the base system, or it could be obtained using the ports collection or [[w:pkgsrc|pkgsrc]].
* Homebrew is a commonly used package manager for Mac OS X.


;Steps for Obtaining the GCC Compiler if You're on Windows:
There are two ways to use GCC on Windows: Cygwin and MinGW. Applications compiled with Cygwin will not run on any computer without Cygwin, so MinGW is recommended. MinGW is simpler to install, and takes less disk space.

To get MinGW, do this:
# Go to http://sourceforge.net/projects/mingw/ download and save this to your hard drive.
# Once the download is finished, open it and follow the instructions. You can also choose to install additional compilers, or the tool Make, but these aren't necessary.
# Now you need to set your PATH. Right-click on "My computer" and click "Properties". Go to the "Advanced" tab and click on "Environment variables". Go to the "System variables" section and scroll down until you see "Path". Click on it, then click "edit". Add ";C:\mingw\bin\" (without the quotes) to the end.
# To test if GCC works, open a command prompt and type "gcc". You should get the message "gcc: fatal error: no input files compilation terminated.". If you get this message, GCC is installed correctly.

To get Cygwin, do this:
# Go to http://www.cygwin.com and click on the "Install Cygwin Now" button in the upper right corner of the page.
# Click "run" in the window that pops up, and click "next" several times, accepting all the default settings.
# Choose any of the Download sites ("ftp.easynet.be", etc.) when that window comes up; press "next" and the Cygwin installer should start downloading.
# When the "Select Packages" window appears, scroll down to the heading "Devel" and click on the "+" by it. In the list of packages that now displays, scroll down and find the "gcc-core" package; this is the compiler.  Click once on the word "Skip", and it should change to some number like "3.4" etc. (the version number), and an "X" will appear next to "gcc-core" and several other related packages that will now be downloaded.
# Click "next" and the compiler as well as the Cygwin tools should start downloading; this could take a while.  While you're waiting for the installation to finish, download any text-editor designed for programming.  While Cygwin does include some, you may prefer doing a web search to find other alternatives.  While using a stock text editor is possible, it is not ideal. 
# Once the Cygwin downloads are finished and you have clicked "next", etc. to finish the installation, double-click the Cygwin icon on your desktop to begin the Cygwin "command prompt".  Your home directory will automatically be set up in the Cygwin folder, which now should be at "C:\cygwin" (the Cygwin folder is in some ways like a small unix/linux computer on your Windows machine -- not technically of course, but it may be helpful to think of it that way).
# Type "gcc" at the Cygwin prompt and press "enter"; if "gcc: no input files" or something like it appears you have succeeded and now have the gcc compiler on your computer (and congratulations -- you have also just received your first error message!).

Third option is to use WSL:

# Go to http://aka.ms/wsldocs and follow the steps to install [https://docs.microsoft.com/en-us/windows/wsl/install-win10 WSL]
# Go to https://aka.ms/vscode and follow the steps to install [https://code.visualstudio.com/docs/setup/windows VSCode]
# Follow the [https://code.visualstudio.com/docs/languages/cpp#_getting-started guide] and choose [https://code.visualstudio.com/docs/cpp/config-wsl Get Started with C++ and WSL]
# As a result you will need to install possibly [https://code.visualstudio.com/docs/cpp/config-wsl#_set-up-your-linux-environment Ubuntu] and set-up accordingly installing GCC like the Linux guide above.

The current stable (usable) version of GCC is 4.9.1 published on 2014-07-16, which supports several platforms. In fact, GCC is not only a C compiler, but a family of compilers for several languages, such as C++, [[Ada Programming|Ada]], [[Java]], and [[Fortran]].

=== Embedded systems ===
* Most CPUs are microcontrollers in embedded systems, often programmed in C, but most of the compilers mentioned above (except GCC) do not support such CPUs. For specialized compilers that do support embedded systems, see [[Embedded Systems/C Programming]].

=== Other C compilers ===
We have a long [[C Programming/Compilers | list of C compilers]] in a much later section of this Wikibook.
''Which of those compilers would be suitable for beginning C programmers, that we should say a few words about getting started with that particular compiler in this section of this Wikibook?''

{{C Programming/Navigation|What you need before you can learn|Intro exercise}}

[[pl:C/Używanie kompilatora]]</text>
      <sha1>jvjkq72nje2p7r381nps4ax8r6u8548</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Operators and type casting</title>
    <ns>0</ns>
    <id>6529</id>
    <revision>
      <id>3624176</id>
      <parentid>3624074</parentid>
      <timestamp>2019-12-12T23:09:07Z</timestamp>
      <contributor>
        <username>Mrjulesd</username>
        <id>1779740</id>
      </contributor>
      <comment>Rejected the last text change (by [[Special:Contributions/14.139.60.12|14.139.60.12]]) and restored revision 3573311 by 68.15.36.215</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="18567" xml:space="preserve">{{C Programming/Navigation|Simple Input and Output|Arrays}}

==Operators and Assignments==

C has a wide range of operators that make simple math easy to handle. The list of operators grouped into precedence levels is as follows:

===Primary expressions===

''Identifiers'' are names of things in C, and consist of either a letter or an underscore ( &lt;tt&gt;_&lt;/tt&gt; ) optionally followed by letters, digits, or underscores. An identifier (or variable name) is a primary expression, provided that it has been declared as designating an object (in which case it is an lvalue [a value that can be used as the left side of an assignment expression]) or a function (in which case it is a function designator).

A ''constant'' is a primary expression. Its type depends on its form and value. The types of constants are character constants (e.g. &lt;code&gt;' '&lt;/code&gt; is a space), integer constants (e.g. &lt;code&gt;2&lt;/code&gt;), floating-point constants (e.g. &lt;code&gt;0.5&lt;/code&gt;), and enumerated constants that have been previously defined via &lt;code&gt;enum&lt;/code&gt;.

A ''string literal'' is a primary expression. It consists of a string of characters within double quotes ( &lt;tt&gt;"&lt;/tt&gt; ). 

A parenthesized expression is a primary expression. It consists of an expression within parentheses ( &lt;tt&gt;(&lt;/tt&gt; &lt;tt&gt;)&lt;/tt&gt; ). Its type and value are those of the non-parenthesized expression within the parentheses.

In C11, an expression that starts with &lt;tt&gt;_Generic&lt;/tt&gt; followed by (, an initial expression, a list of values of the form ''type: expression'' where type is either a named type or the keyword default, and ) constitute a primary expression. The value is the expression that follows the type of the initial expression or the default if not found.

===Postfix operators===

First, a primary expression is also a postfix expression. The following expressions are also postfix expressions:

A postfix expression followed by a left square bracket (&lt;code&gt;[&lt;/code&gt;), an expression, and a right square bracket (&lt;code&gt;]&lt;/code&gt;) in sequence constitutes an invocation of the ''array subscript operator''. One of the expressions shall have type "pointer to object &lt;i&gt;type&lt;/i&gt;" and the other shall have an integer type; the result type is &lt;i&gt;type&lt;/i&gt;. Successive array subscript operators designate an element of a multidimensional array.

A postfix expression followed by parentheses or an optional parenthesized argument list indicates an invocation of the ''function call operator''. The value of the function call operator is the return value of the function called with the provided arguments. The parameters to the function are copied on the stack '''by value''' (or at least the compiler acts as if that is what happens; if the programmer wanted the parameter to be copied by reference, then it is easier to pass the address of the area to be modified by value, then the called function can access the area through the respective pointer). The trend for compilers is to pass the parameters from right to left onto the stack, but this is not universal.

A postfix expression followed by a dot (&lt;code&gt;.&lt;/code&gt;) followed by an identifier selects a member from a structure or union; a postfix expression followed by an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) followed by an identifier selects a member from a structure or union who is pointed to by the pointer on the left-hand side of the expression.

A postfix expression followed by the increment or decrement operators (&lt;code&gt;++&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; respectively) indicates that the variable is to be incremented or decremented as a side effect. The value of the expression is the value of the postfix expression ''before'' the increment or decrement. These operators only work on integers and pointers.

===Unary expressions===

First, a postfix expression is a unary expression. The following expressions are all unary expressions:

The increment or decrement operators followed by a unary expression is a unary expression. The value of the expression is the value of the unary expression ''after'' the increment or decrement. These operators only work on integers and pointers.

The following operators followed by a cast expression are unary expressions:

 Operator     Meaning
 ========     =======
    &amp;         Address-of; value is the location of the operand
    *         Contents-of; value is what is stored at the location
    -         Negation
    +         Value-of operator
    !         Logical negation ( (!E) is equivalent to (0==E) )
    ~         Bit-wise complement

The keyword &lt;code&gt;sizeof&lt;/code&gt; followed by a unary expression is a unary expression. The value is the size of the type of the expression in bytes. The expression is not evaluated.

The keyword &lt;code&gt;sizeof&lt;/code&gt; followed by a parenthesized type name is a unary expression. The value is the size of the type in bytes.

===Cast operators===

A unary expression is also a cast expression.

A parenthesized type name followed by any expression, including literals, is a cast expression. The parenthesized type name has the effect of forcing the cast expression into the type specified by the type name in parentheses. For arithmetic types, this either does not change the value of the expression, or truncates the value of the expression if the expression is an integer and the new type is smaller than the previous type.

An example of casting a float as an int:

&lt;source lang="C"&gt;
float pi = 3.141592;
int truncated_pi = (int) pi; // truncated_pi == 3
&lt;/source&gt;

An example of casting a char as an int:

&lt;source lang="C"&gt;
char my_char = 'A';
int my_int = (int) my_char; // On machines which use ASCII as the character set, my_int == 65
&lt;/source&gt;

===Multiplicative and additive operators===

First, a multiplicative expression is also a cast expression, and an additive expression is also a multiplicative expression. This follows the precedence that multiplication happens before addition.

In C, simple math is very easy to handle. The following operators exist: '''+''' (addition), '''-''' (subtraction), '''*''' (multiplication), / (division), and '''%''' (modulus); You likely know all of them from your math classes - except, perhaps, modulus. It returns the '''remainder''' of a division (e.g. 5 % 2 = 1). (Modulus is not defined for floating-point numbers, but the ''math.h'' library has an ''fmod'' function.)

Care must be taken with the modulus, because it's not the equivalent of the mathematical modulus: (-5) % 2 is not 1, but -1. Division of integers will return an integer, and the division of a negative integer by a positive integer will round towards zero instead of rounding down (e.g. (-5) / 3 = -1 instead of -2). However, it is always true that for all integer a and nonzero integer b, &lt;tt&gt;((a / b) * b) + (a % b) == a&lt;/tt&gt;.

There is no inline operator to do exponentiation (e.g. 5 ^ 2 is '''not''' 25 [it is 7; '''^''' is the exclusive-or operator], and 5 ** 2 is an error), but there is a
[[C Programming/Further math#Power functions|power function]].

The mathematical order of operations does apply. For example (2 + 3) * 2 = 10 while 2 + 3 * 2 = 8. Multiplicative operators have precedence over additive operators.

&lt;source lang="c"&gt;
#include &lt;stdio.h&gt;

int main(void)
{
int i = 0, j = 0;

    /* while i is less than 5 AND j is less than 5, loop */
    while( (i &lt; 5) &amp;&amp; (j &lt; 5) )
    {
        /* postfix increment, i++
         *     the value of i is read and then incremented
         */
        printf("i: %d\t", i++);

        /*
         * prefix increment, ++j 
         *     the value of j is incremented and then read
         */
        printf("j: %d\n", ++j);
    }

    printf("At the end they have both equal values:\ni: %d\tj: %d\n", i, j);

    getchar(); /* pause */
    return 0;
}
&lt;/source&gt;

will display the following:

&lt;pre&gt;
i: 0    j: 1
i: 1    j: 2
i: 2    j: 3
i: 3    j: 4
i: 4    j: 5
At the end they have both equal values:
i: 5    j: 5
&lt;/pre&gt;

=== The shift operators (which may be used to rotate bits) ===

A shift expression is also an additive expression (meaning that the shift operators have a precedence just below addition and subtraction).

Shift functions are often used in low-level I/O hardware interfacing.
Shift and rotate functions are heavily used in cryptography and software floating point emulation.
Other than that, shifts can be used in place of division or multiplication by a power of two.
Many processors have dedicated function blocks to make these operations fast -- see [[Microprocessor Design/Shift and Rotate Blocks]].
On processors which have such blocks, most C compilers compile shift and rotate operators to a single assembly-language instruction -- see [[X86 Assembly/Shift and Rotate]].

==== shift left ====

The &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator shifts the binary representation to the left, dropping the most significant bits and appending it with zero bits.
The result is equivalent to multiplying the integer by a power of two.

==== unsigned shift right ====

The unsigned shift right operator, also sometimes called the logical right shift operator.
It shifts the binary representation to the right, dropping the least significant bits and prepending it with zeros.
The &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator is equivalent to division by a power of two for unsigned integers.

==== signed shift right ====

The signed shift right operator, also sometimes called the arithmetic right shift operator.
It shifts the binary representation to the right, dropping the least significant bit, but prepending it with copies of the original sign bit.
The &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator is not equivalent to division for signed integers.

In C, the behavior of the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator depends on the data type it acts on.
Therefore, a signed and an unsigned right shift looks exactly the same, but produces a different result in some cases.

==== rotate right ====

Contrary to popular belief, it is possible to write C code that compiles down to the "rotate" assembly language instruction (on CPUs that have such an instruction).

Most compilers recognize this idiom:

&lt;source lang=c&gt;
  unsigned int x;
  unsigned int y;
  /* ... */
  y = (x &gt;&gt; shift) | (x &lt;&lt; (32 - shift));
&lt;/source&gt;

and compile it to a single 32 bit rotate instruction.
&lt;ref&gt;
[http://gcc.gnu.org/ml/gcc-patches/2007-11/msg01112.html GCC: "Optimize common rotate constructs"]
&lt;/ref&gt;
&lt;ref&gt;
[http://www.mail-archive.com/llvm-commits@cs.uiuc.edu/msg17216.html "Cleanups in ROTL/ROTR DAG combiner code"] mentions that this code supports the "rotate" instruction in the CellSPU
&lt;/ref&gt;

On some systems, this may be "#define"ed as a macro or defined as an inline function called something like "rightrotate32" or "rotr32" or "ror32" in a standard header file like "bitops.h".
&lt;ref&gt;
[http://archive.is/20130415063059/kerneltrap.org/mailarchive/linux-kernel/2008/4/15/1440064 "replace private copy of bit rotation routines"] -- recommends including "bitops.h" and using its rol32 and ror32 rather than copy-and-paste into a new program.
&lt;/ref&gt;

==== rotate left  ====

Most compilers recognize this idiom:

&lt;source lang=c&gt;
  unsigned int x;
  unsigned int y;
  /* ... */
  y = (x &lt;&lt; shift) | (x &gt;&gt; (32 - shift));
&lt;/source&gt;

and compile it to a single 32 bit rotate instruction.

On some systems, this may be "#define"ed as a macro or defined as an inline function called something like "leftrotate32" or "rotl32" in a header file like "bitops.h".

=== Relational and equality operators ===

A relational expression is also a shift expression; an equality expression is also a relational expression.

The relational binary operators &lt;code&gt;&amp;lt;&lt;/code&gt; (less than), &lt;code&gt;&amp;gt;&lt;/code&gt; (greater than), &lt;code&gt;&amp;lt;=&lt;/code&gt; (less than or equal), and &lt;code&gt;&amp;gt;=&lt;/code&gt; (greater than or equal) operators return a value of 1 if the result of the operation is true, 0 if false. The result of these operators is type &lt;code&gt;int&lt;/code&gt;.

The equality binary operators &lt;code&gt;==&lt;/code&gt; (equals) and &lt;code&gt;!=&lt;/code&gt; (not equals) operators are similar to the relational operators except that their precedence is lower. They also return a value of 1 if the result of the operation is true and 0 if it is false.

One thing with floating-point numbers and equality operators: Because floating-point operations can produce approximations (e.g. 0.1 is a repeating decimal in binary, so 0.1 * 10.0 is hardly ever 1.0), is it unwise to use the &lt;code&gt;==&lt;/code&gt; operator with floating-point numbers. Instead, if a and b are the numbers to compare, compare &lt;code&gt;fabs (a - b)&lt;/code&gt; to a fudge factor.

=== Bitwise operators ===

The bitwise operators are &lt;code&gt;&amp;&lt;/code&gt; (and), &lt;code&gt;^&lt;/code&gt; (exclusive or) and &lt;code&gt;|&lt;/code&gt; (inclusive or). The &lt;code&gt;&amp;&lt;/code&gt; operator has higher precedence than &lt;code&gt;^&lt;/code&gt;, which has higher precedence than &lt;code&gt;|&lt;/code&gt;.

The values being operated upon must be integral; the result is integral.

One use for the bitwise operators is to emulate bit flags. These flags can be set with OR, tested with AND, flipped with XOR, and cleared with AND NOT. For example:&lt;syntaxhighlight lang="c"&gt;
/* This code is a sample for bitwise operations.  */
#define BITFLAG1    (1)
#define BITFLAG2    (2)
#define BITFLAG3    (4) /* They are powers of 2 */

unsigned bitbucket = 0U;    /* Clear all */
bitbucket |= BITFLAG1;      /* Set bit flag 1 */
bitbucket &amp;= ~BITFLAG2;     /* Clear bit flag 2 */
bitbucket ^= BITFLAG3;      /* Flip the state of bit flag 3 from off to on or
                               vice versa */
if (bitbucket &amp; BITFLAG3) {
  /* bit flag 3 is set */
} else {
  /* bit flag 3 is not set */
}

&lt;/syntaxhighlight&gt;

=== Logical operators ===

The logical operators are &lt;code&gt;&amp;&amp;&lt;/code&gt; (and), and &lt;code&gt;||&lt;/code&gt; (or). Both of these operators produce 1 if the relationship is true and 0 for false. Both of these operators short-circuit; if the result of the expression can be determined from the first operand, the second is ignored. The &lt;code&gt;&amp;&amp;&lt;/code&gt; operator has higher precedence than the &lt;code&gt;||&lt;/code&gt; operator.

&lt;code&gt;&amp;&amp;&lt;/code&gt; is used to evaluate expressions left to right, and returns a 1 if ''both'' statements are true, 0 if either of them are false. If the first expression is false, the second is not evaluated.
&lt;source lang=c&gt;  
  int x = 7;
  int y = 5;
  if(x == 7 &amp;&amp; y == 5) {
      ...
  }
&lt;/source&gt;
Here, the &lt;code&gt;&amp;&amp;&lt;/code&gt; operator checks the left-most expression, then the expression to its right. If there were more than two expressions chained (e.g. &lt;code&gt;x &amp;&amp; y &amp;&amp; z&lt;/code&gt;), the operator would check &lt;tt&gt;x&lt;/tt&gt; first, then y (if &lt;tt&gt;x&lt;/tt&gt; is nonzero), then continue rightwards to z if neither x or y is zero. 
Since both statements return true, the &lt;code&gt;&amp;&amp;&lt;/code&gt; operator returns true, and the code block is executed.

&lt;source lang=c&gt;  
    if(x == 5 &amp;&amp; y == 5) {
        ...
    }
&lt;/source&gt;
The &amp;&amp; operator checks in the same way as before, and finds that the first expression is false.
The &amp;&amp; operator stops evaluating as soon as it finds a statement to be false, and returns a false.


&lt;code&gt;||&lt;/code&gt; is used to evaluate expressions left to right, and returns a 1 if ''either'' of the expressions are true, 0 if both are false. If the first expression is true, the second expression is not evaluated.
&lt;source lang=c&gt;      
    /* Use the same variables as before. */
    if(x == 2 || y == 5) { // the || statement checks both expressions, finds that the latter is true, and returns true
        ...
    }
&lt;/source&gt;
The &lt;code&gt;||&lt;/code&gt; operator here checks the left-most expression, finds it false, but continues to evaluate the next expression.
It finds that the next expression returns true, stops, and returns a 1. 
Much how the &lt;code&gt;&amp;&amp;&lt;/code&gt; operator ceases when it finds an expression that returns false, the &lt;code&gt;||&lt;/code&gt; operator ceases when it finds an expression that returns true.

It is worth noting that C does not have Boolean values (true and false) commonly found in other languages. It instead interprets a 0 as false, and any nonzero value as true.

=== Conditional operators ===

The ternary &lt;code&gt;?:&lt;/code&gt; operator is the conditional operator. The expression &lt;code&gt;(x ? y : z)&lt;/code&gt; has the value of &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is nonzero, &lt;code&gt;z&lt;/code&gt; otherwise.

Example:
&lt;source lang="c"&gt;  
int x = 0;
int y;
y = (x ? 10 : 6); /* The parentheses are technically not necessary as assignment
                     has a lower precedence than the conditional operator, but
                     it's there for clarity.  */
&lt;/source&gt;
The expression &lt;code&gt;x&lt;/code&gt; evaluates to 0. The ternary operator then looks for the "if-false" value, which in this case, is 6. It returns that, so &lt;code&gt;y&lt;/code&gt; is equal to six. Had &lt;code&gt;x&lt;/code&gt; been a non-zero, then the expression would have returned a 10.

=== Assignment operators ===

The assignment operators are &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, and &lt;code&gt;|=&lt;/code&gt; . The &lt;code&gt;=&lt;/code&gt; operator stores the value of the right operand into the location determined by the left operand, which must be an [[lvalue]] (a value that has an address, and therefore can be assigned to).

For the others, &lt;code&gt;x op= y&lt;/code&gt; is shorthand for &lt;code&gt;x = x op (y)&lt;/code&gt; . Hence, the following expressions are the same:
     1. x += y     -     x = x+y
     2. x -= y     -     x = x-y
     3. x *= y     -     x = x*y
     4. x /= y     -     x = x/y
     5. x %= y     -     x = x%y

The value of the assignment expression is the value of the left operand after the assignment. Thus, assignments can be chained; e.g. the expression &lt;code&gt;a = b = c = 0;&lt;/code&gt; would assign the value zero to all three variables.

=== Comma operator ===

The operator with the least precedence is the comma operator. The value of the expression &lt;code&gt;x, y&lt;/code&gt; will evaluate both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, but provides the value of &lt;code&gt;y&lt;/code&gt;.  

This operator is useful for including multiple actions in one statement (e.g. within a for loop conditional). 

Here is a small example of the comma operator:
&lt;source lang=c&gt;
int i, x;      /* Declares two ints, i and x, in one declaration.
                  Technically, this is not the comma operator. */

/* this loop initializes x and i to 0, then runs the loop */
for (x = 0, i = 0; i &lt;= 6; i++) {
    printf("x = %d, and i = %d\n", x, i);
}
&lt;/source&gt;

== References ==
{{Reflist}}

{{C Programming/Navigation|Simple Input and Output|Arrays}}

[[fr:Programmation C/Opérateurs]]
[[pl:C/Operatory]]</text>
      <sha1>cs7dirhmfvfp6g1z1t00ro0pm3db8zs</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/POSIX Reference</title>
    <ns>0</ns>
    <id>258337</id>
    <revision>
      <id>3361159</id>
      <parentid>3358064</parentid>
      <timestamp>2018-01-12T18:09:22Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <comment>Split "Header" section</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6089" xml:space="preserve">The '''C POSIX library''' is a language-independent library (using C calling conventions) that adds functions specific to POSIX systems. POSIX (and the Single Unix Specification) specifies a number of routines that should be available over and above those in the C standard library proper. It was developed at the same time as the ANSI C standard and is closely related to C. Some effort was made to make the C and POSIX libraries compatible, but there are a few POSIX functions that were never introduced into ANSI C. 

Facilities are often implemented alongside the C standard library functionality, with varying degrees of closeness. For example, glibc implements functions such as fork within libc.so, but before NPTL was merged into glibc it constituted a separate library with its own linker flag. Often, this POSIX-specified functionality will be regarded as part of the library; the C library proper may be identified as the ANSI or ISO C library.

== Header files ==

{| class="wikitable"
|-
|'''aio.h''' || Asynchronous input and output.
|-
|'''arpa/inet.h''' || Definitions for internet operations.
|-
|'''cpio.h''' || Magic numbers for the cpio archive format.
|-
|'''dirent.h''' || Allows the opening and listing of directories.
|-
|'''fcntl.h''' || File opening, locking and other operations.
|-
|'''fmtmsg.h''' || Message display structures.
|-
|'''fnmatch.h''' || Filename-matching types.
|-
|'''ftw.h''' || File tree traversal.
|-
|'''glob.h''' || Pathname pattern-matching types.
|-
|'''grp.h''' || User group information and control.
|-
|'''iconv.h''' || Codeset conversion facility.
|-
|'''langinfo.h''' || Language information constants.
|-
|'''libgen.h''' || Definitions for pattern matching functions.
|-
|'''monetary.h''' || Monetary types.
|-
|'''mqueue.h''' || Message queues (REALTIME).
|-
|'''ndbm.h''' || Definitions for ndbm database operations.
|-
|'''net/if.h''' || Sockets local interfaces.
|-
|'''netdb.h''' || Definitions for network database operations.
|-
|'''netinet/in.h''' || Internet address family.
|-
|'''netinet/tcp.h''' || Definitions for the Internet Transmission Control Protocol (TCP).
|-
|'''nl_types.h''' || Data types.
|-
|'''poll.h''' || Definitions for the poll() function.
|-
|'''pthread.h''' || Defines an API for creating and manipulating POSIX threads.
|-
|'''pwd.h''' || Passwd (user information) access and control.
|-
|'''regex.h''' || Regular expression matching types.
|-
|'''sched.h''' || Execution scheduling.
|-
|'''search.h''' || Search tables.
|-
|'''semaphore.h''' || Semaphores.
|-
|'''spawn.h''' || Create a new process to run an executable program.
|-
|'''strings.h''' || String operations.
|-
|'''stropts.h''' || STREAMS interface (STREAMS).
|-
|'''sys/ipc.h''' || Inter-process communication (IPC).
|-
|'''sys/mman.h''' || POSIX memory management declarations.
|-
|'''sys/msg.h''' || POSIX message queues.
|-
|'''sys/resource.h''' || Definitions for XSI resource operations.
|-
|'''sys/select.h''' || Select types.
|-
|'''sys/sem.h''' || POSIX semaphores.
|-
|'''sys/shm.h''' || XSI shared memory facility.
|-
|'''sys/socket.h''' || Main sockets header.
|-
|'''sys/stat.h''' || File information (stat et al.).
|-
|'''sys/statvfs.h''' || VFS File System information structure.
|-
|'''sys/time.h''' || Time and date functions and structures.
|-
|'''sys/times.h''' || File access and modification times structure.
|-
|'''sys/types.h''' || Various data types used elsewhere.
|-
|'''sys/uio.h''' || Definitions for vector I/O operations.
|-
|'''sys/un.h''' || Definitions for UNIX domain sockets.
|-
|'''sys/utsname.h''' || uname and related structures.
|-
|'''sys/wait.h''' || Status of terminated child processes.
|-
|'''syslog.h''' || Definitions for system error logging.
|-
|'''tar.h''' || Magic numbers for the tar archive format.
|-
|'''termios.h''' || Allows terminal I/O interfaces.
|-
|'''trace.h''' || Tracing.
|-
|'''ulimit.h''' || ulimit commands.
|-
|'''unistd.h''' || Various essential POSIX functions and constants.
|-
|'''utime.h''' || File access and modification times.
|-
|'''utmpx.h''' || User accounting database definitions.
|-
|'''wordexp.h''' || Word-expansion types.
|}

== Standard overlap headers ==

Headers that overlap/extend the C standard.

{| class="wikitable"
|-
|'''assert.h''' || Verify program assertion.
|-
|'''complex.h''' || Complex arithmetic.
|-
|'''ctype.h''' || Character types.
|-
|'''fenv.h''' || Floating-point environment.
|-
|'''float.h''' || Floating types.
|-
|'''inttypes.h''' || Fixed size integer types.
|-
|'''iso646.h''' || Alternative spellings.
|-
|'''limits.h''' || Implementation-defined constants.
|-
|'''locale.h''' || Category macros.
|-
|'''math.h''' || Mathematical declarations.
|-
|'''setjmp.h''' || Stack environment declarations.
|-
|'''signal.h''' || Signals.
|-
|'''stdarg.h''' || Handle variable argument list.
|-
|'''stdbool.h''' || Boolean type and values.
|-
|'''stddef.h''' || Standard type definitions.
|-
|'''stdint.h''' || Integer types.
|-
|'''stdio.h''' || Standard buffered input/output.
|-
|'''stdlib.h''' || Standard library definitions.
|-
|'''string.h''' || String operations.
|-
|'''tgmath.h''' || Type-generic macros.
|-
|'''time.h''' || Time types.
|-
|'''wchar.h''' || Wide-character handling.
|-
|'''wctype.h''' || Wide-character classification and mapping utilities.
|}

==References==
* [http://www.opengroup.org/onlinepubs/9699919799/idx/head.html Official List of headers in the POSIX library on opengroup.org]
* [http://web.archive.org/web/*/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm Lists headers in the POSIX library]
* [http://www.cs.utah.edu/flux/oskit/html/oskit-wwwch20.html Description of the posix library from the Flux OSKit]

==Bibliography==
{{refbegin}}
*{{citation
| first1    = Bill
| last1     = Gallmeister
| date      = January 1, 1995
| title     = POSIX.4 Programmers Guide: Programming for the Real World
| edition   = 1st
| publisher = O'Reilly Media
| pages     = 564 
| isbn      = 1565920740
| url       = http://oreilly.com/catalog/9781565920743/
}}
{{refend}}

{{BookCat}}</text>
      <sha1>7qnyjvjjz0z0q2m6nv5xehpa7986tet</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Particularities of C</title>
    <ns>0</ns>
    <id>91325</id>
    <revision>
      <id>3223490</id>
      <parentid>2979780</parentid>
      <timestamp>2017-05-28T13:44:48Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7018" xml:space="preserve">
C is an efficient, minimalist language that has some peculiarities that a programmer must be aware of. To address these, sometimes a good solution is to combine another language with C for added flexibility and power, like the combination of Emacs-LISP and C used for Emacs. Sometimes they can be addressed at the cost of slower speed and increased complexity by using special constructs that will guarantee function and security. Mostly however, through practice, C programmers have no trouble with the things mentioned here,
and prefer using a language that closely models the general purpose, Von Neumann hardware architecture.

Below are several of these particularities of ANSI C (that sometimes are also its strengths), some minor and some major:

; Lack of differentiation between arrays and pointers : The very first C (around 1973) did not have arrays at all; modern implementations are contiguous areas in memory accessed with pointer arithmetic (note: a declared array cannot be assigned to like a pointer), which circumvents the need to declare arrays with a fixed size. This ability, however, can cause buffer overflow errors with careless use.

; Arrays do not store their length : A consequence of the above feature. This means that the program might need to explicitly perform a bounds check before accessing an array. Unless a function is passed an array of a fixed size, there is no way for it to discover the length of the array it was given: So the function must be given the length, perhaps passed to the function as a separate variable or in a structure. Because of this, most implementations do not provide automatic array bounds checking, and manual bounds checking is error prone.

: If a C (or C++) program attempts to access an array element outside of the actual allocated memory, then a buffer overflow occurs, typically crashing the program. Buffer overflow bugs are a common security vulnerability too. Many other computer languages provide automatic bounds checking, and so they are nearly immune to such bugs. &lt;ref&gt;http://projects.webappsec.org/Buffer-Overflow&lt;/ref&gt;&lt;ref&gt;http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/buffer-overflow.html&lt;/ref&gt;&lt;ref&gt;http://searchsecurity.techtarget.com/news/article/0,289142,sid14_gci860185,00.html&lt;/ref&gt;&lt;ref&gt;http://www.owasp.org/index.php/Buffer_Overflows&lt;/ref&gt;&lt;ref&gt;http://cyclone.thelanguage.org/wiki/Why%20Cyclone&lt;/ref&gt;

; Variable Length Arrays : A VLA ‒ variable length array ‒ can only be used for function parameters and auto variables. VLAs cannot be allocated on the heap{{fact}} or used inside a structure (except as the last item in the structure). It's not possible to define a structure that corresponds to the standard [[Forth]] dictionary definition (which has 2 variable-length parts), except as an undifferentiated array of &lt;code&gt;char&lt;/code&gt;.

; Arbitrary-size built-in 2D or 3D arrays are not widely supported : This feature has been added starting with the C99 specification for variable-length arrays, although many C compilers still do not support it. Without VLAs, there is no way for a function to accept 2D or 3D arrays of arbitrary size. In particular, it's impossible to define a function that accepts &lt;code&gt; int a[5][4][3]; &lt;/code&gt; on one call, and later accepts &lt;code&gt; int b[10][10][10]; &lt;/code&gt; in a later call. Instead of using the built-in 2D or 3D array data type, C programmers use some other data type to hold (mathematical) 2D or 3D arrays of arbitrary size (multi-dimensional arrays) -- see [[C Programming/Common practices#Dynamic multidimensional arrays]] for details.

; No formal String data type : Strings are character arrays (lacking any abstraction) and inherit all their constraints (structs can provide an abstraction, to an extent).

; Weak type safety : C is not very type-safe. The memory management functions operate on untyped pointers, there is no built-in run-time type enforcement, and the type system can be circumvented with pointers and casts. Additionally, typedef does not create a new type but only an alias, thus it serves solely for code legibility. However, it is possible to use single member structs to enforce type safety.

; No garbage collection :  As a low-level language designed for minimum overhead, C features only manual memory management, which can allow simple memory leaks to go on unchecked.

; Local variables are uninitialized upon declaration : Local (but not global) variables must be initialized manually; before this, they contain whatever was already in memory at the time. This is not unusual, but the C standard does not forbid access to uninitialized variables (which is).
&lt;!-- ; Tedious memory allocation : VLA - Variable Length Arrays are restricted in their use, VLS - Variable Length Structures do not exist at all. C89 requires all instances of a structure to be the same size; C99 allows various instances of a structure to have different sizes when they contain one "flexible array member".&lt;ref&gt;
[http://c-faq.com/struct/structhack.html comp.lang.c FAQ list: Question 2.6]: "C99 introduces the concept of a flexible array member, which allows the size of an array to be omitted if it is the last member in a structure, thus providing a well-defined solution."
&lt;/ref&gt; --&gt;

; Unwieldy function pointer syntax : Function pointers take the form of &lt;code&gt;    [return type] [name]([arg1 type])([arg2 type])&lt;/code&gt;, making them somewhat difficult to use. Typedefs can alleviate this burdensome syntax. For example, &lt;code&gt;typedef int fn(int i);&lt;/code&gt;. See [[C Programming/Pointers and arrays#Pointers to Functions]] for more details.

; No reflection : It is not possible for a C program -- at runtime -- to evaluate a string as if it were a source C code statement.

; Nested functions are not standard: However, many C compilers do support nested functions, including GNU C.&lt;ref&gt;
"A GNU Manual": "Extensions to the C Language: Nested Functions"
[http://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html]
&lt;/ref&gt;

; No formal exception handling : Some standard functions return special values that must be handled manually. For example, &lt;code&gt;malloc()&lt;/code&gt; returns null upon failure. For example, one must store the return value of &lt;code&gt;getchar()&lt;/code&gt; in an &lt;code&gt;int&lt;/code&gt; (not, as one might expect, in a &lt;code&gt;char&lt;/code&gt;) in order to reliably detect the end-of-file -- see [[C Programming/File IO#EOF pitfall | EOF pitfall]]. Programs that do not include appropriate error handling might work fine most of the time, but can crash or otherwise malfunction when exceptional cases occur. POSIX systems often use &lt;code&gt;signal()&lt;/code&gt; to handle some kinds of exceptions. (See ''{where can I read more about signal()?}'' for details). Some programs use &lt;code&gt;setjmp()&lt;/code&gt;, &lt;code&gt;longjmp()&lt;/code&gt; or &lt;code&gt;goto&lt;/code&gt; to manually handle some kinds of exceptions. (See [[C Programming/Control#One last thing: goto]] and [[C Programming/Coroutines]] for details).

; No anonymous function definitions

==References==
{{reflist}}

{{BookCat}}</text>
      <sha1>7cksuvvzpexvqn9zlydgbcxafv5ipil</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Pointers and arrays</title>
    <ns>0</ns>
    <id>10337</id>
    <revision>
      <id>3569929</id>
      <parentid>3559567</parentid>
      <timestamp>2019-09-07T21:40:16Z</timestamp>
      <contributor>
        <ip>47.24.151.68</ip>
      </contributor>
      <comment>Removed dead link</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="29440" xml:space="preserve">{{C Programming/Navigation|Composite data types|Memory management}}

[[File:Zeiger.PNG|thumb|180px|Pointer ''a'' pointing to variable ''b''. Note that ''b'' stores a number, whereas ''a'' stores the address of ''b'' in memory (1462)]]
A '''[[w:Pointer (computing)|pointer]]''' is a value that designates the address (i.e., the location in memory), of some value. Pointers are variables that hold a memory location.

There are four fundamental things you need to know about pointers:
* How to declare them (with the address operator '&lt;code&gt;&amp;&lt;/code&gt;': &lt;code&gt;int *pointer = &amp;variable;&lt;/code&gt;)
* How to assign to them (&lt;code&gt;pointer = NULL;&lt;/code&gt;)
* How to reference the value to which the pointer points (known as ''dereferencing'', by using the dereferencing operator '&lt;code&gt;*&lt;/code&gt;': &lt;code&gt;value = *pointer;&lt;/code&gt;)
* How they relate to arrays (the vast majority of arrays in C are simple lists, also called "1 dimensional arrays", but we will briefly  cover multi-dimensional arrays with some pointers in [[C Programming/Common practices#Dynamic multidimensional arrays|a later chapter]]).

Pointers can reference any data type, even functions. We'll also discuss the relationship of pointers with text strings and the more advanced concept of function pointers.

==Declaring pointers==

Consider the following snippet of code which declares two pointers:

&lt;source lang="c"&gt;
 struct MyStruct {
     int   m_aNumber;
     float num2;
 };
 
int main()
{
     int *pJ2;
     struct MyStruct *pAnItem;
}
&lt;/source&gt;

Lines 1-4 define a [[C Programming/Complex types#Structs|structure]].  Line 8 declares a variable which points to an &lt;tt&gt;int&lt;/tt&gt;, and line 9 declares a variable which points to something with structure MyStruct.  So to declare a variable as something which points to some type, rather than contains some type, the asterisk (&lt;code&gt;*&lt;/code&gt;) is placed before the variable name.  

In the following, line 1 declares &lt;code&gt;var1&lt;/code&gt; as a pointer to a long and &lt;code&gt;var2&lt;/code&gt; as a long and not a pointer to a long.  In line 2, &lt;code&gt;p3&lt;/code&gt; is declared as a pointer to a pointer to an int.

&lt;source lang="c"&gt;
long  *  var1, var2;
 int   ** p3;
&lt;/source&gt;

Pointer types are often used as parameters to function calls.  The following shows how to declare a function which uses a pointer as an argument. Since C passes function arguments by value, in order to allow a function to modify a value from the calling routine, a pointer to the value must be passed.  Pointers to structures are also used as function arguments even when nothing in the struct will be modified in the function.  This is done to avoid copying the complete contents of the structure onto the stack.  More about pointers as function arguments later.

&lt;syntaxhighlight lang="c"&gt;
int MyFunction( struct MyStruct *pStruct );
&lt;/syntaxhighlight&gt;

==Assigning values to pointers==

So far we've discussed how to declare pointers. The process of assigning values to pointers is next.  To assign the address of a variable to a pointer, the &lt;code&gt;&amp;&lt;/code&gt; or 'address of' operator is used. 

&lt;source lang="c"&gt;
 int   myInt;
 int  *pPointer;
 struct MyStruct   dvorak;
 struct MyStruct  *pKeyboard;
 
 pPointer = &amp;myInt;
 pKeyboard = &amp;dvorak;
&lt;/source&gt;

Here, pPointer will now reference myInt and pKeyboard will reference dvorak.

Pointers can also be assigned to reference dynamically allocated memory.  The malloc() and calloc() functions are often used to do this.

&lt;source lang="c"&gt;
 #include &lt;stdlib.h&gt;
 /* ... */
 struct MyStruct *pKeyboard;
 /* ... */
 pKeyboard = malloc(sizeof *pKeyboard);
&lt;/source&gt;

The malloc function returns a pointer to dynamically allocated memory (or NULL if unsuccessful). The size of this memory will be appropriately sized to contain the MyStruct structure.

The following is an example showing one pointer being assigned to another and of a pointer being assigned a return value from a function.

&lt;source lang="c"&gt;
 static struct MyStruct val1, val2, val3, val4;

 struct MyStruct *ASillyFunction( int b )
 {
    struct MyStruct *myReturn;
 
    if (b == 1) myReturn = &amp;val1;
    else if (b==2) myReturn = &amp;val2;
    else if (b==3) myReturn = &amp;val3;
    else myReturn = &amp;val4;
  
    return myReturn;
 }

 struct MyStruct *strPointer;
 int     *c, *d;
 int     j;

 c = &amp;j;                           /* pointer assigned using &amp; operator */
 d = c;                            /* assign one pointer to another     */
 strPointer = ASillyFunction( 3 ); /* pointer returned from a function. */
&lt;/source&gt;

When returning a pointer from a function, do not return a pointer that points to a value that is local to the function or that is a pointer to a function argument.  Pointers to local variables become invalid when the function exits. In the above function, the value returned points to a static variable.  Returning a pointer to dynamically allocated memory is also valid.

==Pointer dereferencing==
[[File:Pointers in programming.svg|thumb|300px|The pointer &lt;tt&gt;p&lt;/tt&gt; points to the variable &lt;tt&gt;a&lt;/tt&gt;.]]
To access a value to which a pointer points, the &lt;code&gt;*&lt;/code&gt; operator is used. Another operator, the &lt;code&gt;-&gt;&lt;/code&gt; operator is used in conjunction with pointers to structures.  Here's a short example.

&lt;source lang="c"&gt;
 int   c, d;
 int   *pj;
 struct MyStruct astruct;
 struct MyStruct *bb;
 
 c   = 10;
 pj  = &amp;c;             /* pj points to c */
 d   = *pj;            /* d is assigned the value to which pj points, 10 */
 pj  = &amp;d;             /* now points to d */
 *pj = 12;             /* d is now 12 */
 
 bb = &amp;astruct;
 (*bb).m_aNumber = 3;  /* assigns 3 to the m_aNumber member of astruct */
 bb-&gt;num2 = 44.3;      /* assigns 44.3 to the num2 member of astruct   */
 *pj = bb-&gt;m_aNumber;  /* equivalent to d = astruct.m_aNumber;          */
&lt;/source&gt;

The expression &lt;code&gt;bb-&gt;m_aNumber&lt;/code&gt; is entirely equivalent to &lt;code&gt;(*bb).m_aNumber&lt;/code&gt;. They both access the &lt;code&gt;m_aNumber&lt;/code&gt; element of the structure pointed to by &lt;code&gt;bb&lt;/code&gt;. There is one more way of dereferencing a pointer, which will be discussed in the following section.

When dereferencing a pointer that points to an invalid memory location, an error often occurs which results in the program terminating.  The error is often reported as a segmentation error.  A common cause of this is failure to initialize a pointer before trying to dereference it.
 
C is known for giving you just enough rope to hang yourself, and pointer dereferencing is a prime example.  You are quite free to write code that accesses memory outside that which you have explicitly requested from the system.  And many times, that memory may appear as available to your program due to the vagaries of system memory allocation.  However, even if 99 executions allow your program to run without fault, that 100th execution may be the time when your "memory pilfering" is caught by the system and the program fails.  Be careful to ensure that your pointer offsets are within the bounds of allocated memory!

The declaration &lt;code&gt;void *somePointer;&lt;/code&gt; is used to declare a pointer of some nonspecified type. You can assign a value to a void pointer, but you must cast the variable to point to some specified type before you can dereference it.  Pointer arithmetic is also not valid with &lt;code&gt;void *&lt;/code&gt; pointers.

==Pointers and Arrays==
Up to now, we've carefully been avoiding discussing arrays in the context of pointers. The interaction of pointers and arrays can be confusing but here are two fundamental statements about it:
* A variable declared as an array of some type acts as a pointer to that type.  When used by itself, it points to the first element of the array.
* A pointer can be indexed like an array name. 
 
The first case often is seen to occur when an array is passed as an argument to a function.  The function declares the parameter as a pointer, but the actual argument may be the name of an array.  The second case often occurs when accessing dynamically allocated memory. Let's look at examples of each. In the following code, the call to calloc() effectively allocates an array of struct MyStruct items.

&lt;source lang="c"&gt;
 float KrazyFunction( struct MyStruct *parm1, int p1size, int bb )
 { 
   int ix; //declaring an integer variable//
   for (ix=0; ix&lt;p1size; ix++) {
      if (parm1[ix].m_aNumber == bb )
          return parm1[ix].num2;
   }
   return 0.0f;
 }

 /* ... */
 struct MyStruct myArray[4];
 #define MY_ARRAY_SIZE (sizeof(myArray)/sizeof(*myArray))
 float v3;
 struct MyStruct *secondArray;
 int   someSize;
 int   ix;
 /* initialization of myArray ... */
 v3 = KrazyFunction( myArray, MY_ARRAY_SIZE, 4 );
 /* ... */
 secondArray = calloc( someSize, sizeof(MyStruct) );
 for (ix=0; ix&lt;someSize; ix++) {
     secondArray[ix].m_aNumber = ix *2;
     secondArray[ix].num2 = .304 * ix * ix;
 }
&lt;/source&gt;

Pointers and array names can pretty much be used interchangeably. There are exceptions. You cannot
assign a new pointer value to an array name. The array name will always point to the first element of the array.  In the function &lt;code&gt;KrazyFunction&lt;/code&gt; above, you could however assign a new value to parm1, as it is just a pointer to the first element of myArray.  It is also valid for a function to return a pointer to one of the array elements from an array passed as an argument to a function. A function should never return a pointer to a local variable, even though the compiler will probably not complain.

When declaring parameters to functions, declaring an array variable without a size is equivalent to declaring a pointer. Often this is done to emphasize the fact that the pointer variable will be used in a manner equivalent to an array. 
&lt;source lang="c"&gt;	
 /* two equivalent function definitions */
 int LittleFunction( int *paramN );
 int LittleFunction( int paramN[] );	 
&lt;/source&gt;

Now we're ready to discuss pointer arithmetic. You can add and subtract integer values to/from pointers. If myArray is declared to be some type of array, the expression &lt;code&gt;*(myArray+j)&lt;/code&gt;, where j is an integer, is equivalent to &lt;code&gt;myArray[j]&lt;/code&gt;. So for instance in the above example where we had the expression secondArray[i].num2, we could have written that as &lt;code&gt;*(secondArray+i).num2&lt;/code&gt; or more simply &lt;code&gt;(secondArray+i)-&gt;num2&lt;/code&gt;.

Note that for addition and subtraction of integers and pointers, the value of the pointer is not adjusted by the integer amount, but is adjusted by the amount multiplied by the size (in bytes) of the type to which the pointer refers.  One pointer may also be subtracted from another, provided they point to elements of the same array (or the position just beyond the end of the array). If you have a pointer that points to an element of an array, the index of the element is the result when the array name is subtracted from the pointer. Here's an example.

&lt;source lang="c"&gt;
 struct MyStruct someArray[20];
 struct MyStruct *p2;
 int idx;
 
 .
 /* array initialization .. */
 . 
 for (p2 = someArray; p2 &lt; someArray+20;  ++p2) {
    if (p2-&gt;num2 &gt; testValue) break;
 }
 idx = p2 - someArray;        
&lt;/source&gt;

You may be wondering how pointers and multidimensional arrays interact. Let's look at this a bit in detail.  Suppose A is declared as a two dimensional array of floats (&lt;code&gt;float A[D1][D2];&lt;/code&gt;) and that pf is declared a pointer to a float.  If pf is initialized to point to A[0][0], then *(pf+1) is equivalent to A[0][1] and *(pf+D2) is equivalent to A[1][0]. The elements of the array are stored in row-major order.

&lt;source lang="c"&gt;	
 float A[6][8];
 float *pf;
 pf = &amp;A[0][0]; 
 *(pf+1) = 1.3;   /* assigns 1.3 to A[0][1] */
 *(pf+8) = 2.3;   /* assigns 2.3 to A[1][0] */
&lt;/source&gt;	

Let's look at a slightly different problem.  We want to have a two dimensional array, but we don't need to have all the rows the same length. What we do is declare an array of pointers. The second line below declares A as an array of pointers. Each pointer points to a float. Here's some applicable code:

&lt;source lang=c&gt;
 float  linearA[30];
 float *A[6];
 
 A[0] = linearA;              /*  5 - 0 = 5 elements in row  */
 A[1] = linearA + 5;          /* 11 - 5 = 6 elements in row  */
 A[2] = linearA + 11;         /* 15 - 11 = 4 elements in row */
 A[3] = linearA + 15;         /* 21 - 15 = 6 elements        */
 A[4] = linearA + 21;         /* 25 - 21 = 4 elements        */
 A[5] = linearA + 25;         /* 30 - 25 = 5 elements        */
 
 *A[3][2] = 3.66;          /* assigns 3.66 to linearA[17];     */
 *A[3][-3] = 1.44;         /* refers to linearA[12];           
                             negative indices are sometimes useful. But avoid using them as much as possible. */
&lt;/source&gt;
   
We also note here something curious about array indexing. Suppose myArray is an array and idx is an integer value. The expression myArray[idx] is equivalent to idx[myArray]. The first is equivalent to *(myArray+idx), and the second is equivalent to *(idx+myArray). These turn out to be the same, since the addition is commutative.

Pointers can be used with preincrement or post decrement, which is sometimes done within a loop, as in the following example.  The increment and decrement applies to the pointer, not to the object to which the pointer refers.
In other words, *pArray++ is equivalent to *(pArray++).

&lt;source lang=c&gt;
 long  myArray[20];
 long  *pArray;
 int  i;
 
 /* Assign values to the entries of myArray */
 pArray = myArray;
 for (i=0; i&lt;10; ++i) {
   *pArray++ = 5 + 3*i + 12*i*i;
   *pArray++ = 6 + 2*i + 7*i*i;
 }
&lt;/source&gt;

==Pointers in Function Arguments==
Often we need to invoke a function with an argument that is itself a pointer. In many instances, the variable is itself a parameter for the current function and may be a pointer to some type of structure.  The [[w:Ampersand|ampersand]] character is not needed in this circumstance to obtain a pointer value, as the variable is itself a pointer. In the example below, the variable &lt;code&gt;pStruct&lt;/code&gt;, a pointer, is a parameter to function &lt;code&gt;FunctTwo&lt;/code&gt;, and is passed as an argument to &lt;code&gt;FunctOne&lt;/code&gt;.
The second parameter to &lt;code&gt;FunctOne&lt;/code&gt; is an int. Since in function &lt;code&gt;FunctTwo&lt;/code&gt;, &lt;code&gt;mValue&lt;/code&gt; is a pointer to an int, the pointer must first be dereferenced using the * operator, hence the second argument in the call is &lt;code&gt;*mValue&lt;/code&gt;.  The
third parameter to function &lt;code&gt;FunctOne&lt;/code&gt; is a pointer to a long. Since &lt;code&gt;pAA&lt;/code&gt; is itself a pointer to a long, no ampersand is needed when it is used as the third argument to the function.

&lt;source lang="c"&gt;
 int FunctOne( struct SomeStruct *pValue, int iValue, long *lValue )
 {
    /*  do some stuff ... */
    return 0;
 }
 int FunctTwo( struct someStruct *pStruct, int *mValue )
 {
    int j;
    long  AnArray[25];
    long *pAA;
     
    pAA = &amp;AnArray[13];
    j = FunctOne( pStruct, *mValue, pAA );
    return j;
 }
&lt;/source&gt;

==Pointers and Text Strings==

Historically, text strings in C have been implemented as arrays of characters, with the last byte in the string being a zero, or the null character '\0'.  Most C implementations come with a standard library of functions for manipulating strings.  Many of the more commonly used functions expect the strings to be null terminated strings of characters.
To use these functions requires the inclusion of the standard C header file "string.h". 

A statically declared, initialized string would look similar to the following:

&lt;syntaxhighlight lang="c"&gt;
static const char *myFormat = "Total Amount Due: %d";
&lt;/syntaxhighlight&gt;

The variable &lt;code&gt;myFormat&lt;/code&gt; can be viewed as an array of 21 characters. There is an implied null character ('\0') tacked on to the end of the string after the 'd' as the 21st item in the array. 
You can also initialize the individual characters of the array as follows:

&lt;syntaxhighlight lang="c"&gt;
static const char myFlower[] = { 'P', 'e', 't', 'u', 'n', 'i', 'a', '\0' };
&lt;/syntaxhighlight&gt;

An initialized array of strings would typically be done as follows:

&lt;syntaxhighlight lang="c"&gt;
static const char *myColors[] = {
    "Red", "Orange", "Yellow", "Green", "Blue", "Violet" };
&lt;/syntaxhighlight&gt;

The initialization of an especially long string can be split across lines of source code as follows.

&lt;syntaxhighlight lang="c"&gt;
static char *longString = "Hello. My name is Rudolph and I work as a reindeer "
    "around Christmas time up at the North Pole.  My boss is a really swell guy."
    " He likes to give everybody gifts.";
&lt;/syntaxhighlight&gt;

The library functions that are used with strings are discussed in a later chapter.

==Pointers to Functions==

C also allows you to create pointers to functions. Pointers to functions syntax can get rather messy. As an example of this, consider the following functions:

&lt;source lang=c&gt;
  static int Z = 0;

  int *pointer_to_Z (int x) {        /* function returning integer pointer, not pointer to function */
    return &amp;Z;
  }

  int get_Z (int x) {    
    return Z;                       
  }
  
  int (*function_pointer_to_Z)(int); /* proper pointer to function taking int as argument; */
  function_pointer_to_Z = &amp;get_Z;

  printf("pointer_to_Z output: %d\n", *pointer_to_Z(3));
  printf("function_pointer_to_Z output: %d", (*function_pointer_to_Z)(3));
&lt;/source&gt;

Declaring a typedef to a function pointer generally clarifies the code. Here's an example that uses a function pointer, and a void * pointer to implement what's known as a callback. The &lt;code&gt;DoSomethingNice&lt;/code&gt; function invokes a caller supplied function &lt;code&gt;TalkJive&lt;/code&gt; with caller data. Note that &lt;code&gt;DoSomethingNice&lt;/code&gt; really doesn't know anything about what &lt;code&gt;dataPointer&lt;/code&gt; refers to.

&lt;source lang=c&gt;
 typedef  int (*MyFunctionType)( int, void *);      /* a typedef for a function pointer */

 #define THE_BIGGEST 100

 int DoSomethingNice( int aVariable, MyFunctionType aFunction, void *dataPointer )
 {
     int rv = 0;
     if (aVariable &lt; THE_BIGGEST) {
        /* invoke function through function pointer (old style) */
        rv = (*aFunction)(aVariable, dataPointer );
      } else {
          /* invoke function through function pointer (new style) */
        rv = aFunction(aVariable, dataPointer );
     };
     return rv;
 }

 typedef struct {
     int    colorSpec;
     char   *phrase;
 } DataINeed;
 
 int TalkJive( int myNumber, void *someStuff )
 {
     /* recast void * to pointer type specifically needed for this function */
     DataINeed *myData = someStuff;
     /* talk jive. */
     return 5;
 }
 
 static DataINeed  sillyStuff = { BLUE, "Whatcha talkin 'bout Willis?" };
  
/* ... */
 DoSomethingNice( 41, &amp;TalkJive,  &amp;sillyStuff );
&lt;/source&gt; 

Some versions of C may not require an ampersand preceding the &lt;code&gt;TalkJive&lt;/code&gt; argument in the &lt;code&gt;DoSomethingNice&lt;/code&gt; call.  Some implementations may require specifically casting the argument to the &lt;code&gt;MyFunctionType&lt;/code&gt; type, even though the function signature exacly matches that of the typedef.

Function pointers can be useful for implementing a form of polymorphism in C. First one declares a structure having as elements function pointers for the various operations to that can be specified polymorphically.  A second base object structure containing a pointer to the previous
structure is also declared.  A class is defined by extending the second structure with the data specific for the class, and static variable of the type of the first structure, containing the addresses of the functions that are associated with the class. This type of polymorphism is used in the standard library when file I/O functions are called.

A similar mechanism can also be used for implementing a [[w:Finite-state_machine|state machine]] in C. A structure is defined which contains function pointers for handling events that may occur within state, and  for functions to be invoked upon entry to and exit from the state. An instance of this structure corresponds to a state. Each state is initialized with pointers to functions appropriate for the state.  The current state of the state machine is in effect a pointer to one of these states.  Changing the value of the current state pointer effectively changes the current state.  When some event occurs, the appropriate function is called through a function pointer in the current state.

===Practical use of function pointers in C===
Function pointers are mainly used to reduce the complexity of switch statement.
Example with switch statement: 
&lt;source lang="c"&gt;
#include &lt;stdio.h&gt;
int add(int a, int b);
int sub(int a, int b);
int mul(int a, int b);
int div(int a, int b);
int main()
{
    int i, result;
    int a=10;
    int b=5;
    printf("Enter the value between 0 and 3 : ");
    scanf("%d",&amp;i); 
    switch(i)
    {
        case 0:  result = add(a,b); break;
        case 1:  result = sub(a,b); break;
        case 2:  result = mul(a,b); break;
        case 3:  result = div(a,b); break;
    }
}
int add(int i, int j)
{
    return (i+j);
}
int sub(int i, int j)
{
    return (i-j);
}
 int mul(int i, int j)
{
    return (i*j);
}
int div(int i, int j)
{
    return (i/j);
}
&lt;/source&gt;

Without using a switch statement:

&lt;source lang=c&gt;
#include &lt;stdio.h&gt;
int add(int a, int b);
int sub(int a, int b);
int mul(int a, int b);
int div(int a, int b);
int (*oper[4])(int a, int b) = {add, sub, mul, div};
int main()
{
    int i,result;
    int a=10;
    int b=5;
    printf("Enter the value between 0 and 3 : ");
    scanf("%d",&amp;i); 
    result = oper[i](a,b);
}
int add(int i, int j)
{
    return (i+j);
}
int sub(int i, int j)
{
    return (i-j);
}
int mul(int i, int j)
{
    return (i*j);
}
int div(int i, int j)
{
    return (i/j);
}
&lt;/source&gt;

Function pointers may be used to create a struct member function:
&lt;source lang="c"&gt;
typedef struct
{
    int (*open)(void);
    void (*close)(void);
    int (*reg)(void);
} device;

int my_device_open(void)
{
    /* ... */
}

void my_device_close(void)
{
    /* ... */
}

void register_device(void)
{
    /* ... */
}

device create(void)
{
    device my_device;
    my_device.open = my_device_open;
    my_device.close = my_device_close;
    my_device.reg = register_device;
    my_device.reg();
    return my_device;
}
&lt;/source&gt;
Use to implement this pointer (following code must be placed in library).
&lt;source lang="c"&gt;
static struct device_data
{
    /* ... here goes data of structure ... */
};

static struct device_data obj;

typedef struct
{
    int (*open)(void);
    void (*close)(void);
    int (*reg)(void);
} device;

static struct device_data create_device_data(void)
{
    struct device_data my_device_data;
    /* ... here goes constructor ... */
    return my_device_data;
}

/* here I omit the my_device_open, my_device_close and register_device functions */

device create_device(void)
{
    device my_device;
    my_device.open = my_device_open;
    my_device.close = my_device_close;
    my_device.reg = register_device;
    my_device.reg();
    return my_device;
}
&lt;/source&gt;

==Examples of pointer constructs==

Below are some example constructs which may aid in creating your pointer.

&lt;syntaxhighlight lang="c"&gt;
int i;          // integer variable 'i'
int *p;         // pointer 'p' to an integer
int a[];        // array 'a' of integers
int f();        // function 'f' with return value of type integer
int **pp;       // pointer 'pp' to a pointer to an integer
int (*pa)[];    // pointer 'pa' to an array of integer
int (*pf)();    // pointer 'pf' to a function with return value integer
int *ap[];      // array 'ap' of pointers to an integer
int *fp();      // function 'fp' which returns a pointer to an integer
int ***ppp;     // pointer 'ppp' to a pointer to a pointer to an integer
int (**ppa)[];  // pointer 'ppa' to a pointer to an array of integers
int (**ppf)();  // pointer 'ppf' to a pointer to a function with return value of type integer
int *(*pap)[];  // pointer 'pap' to an array of pointers to an integer
int *(*pfp)();  // pointer 'pfp' to function with return value of type pointer to an integer
int **app[];    // array of pointers 'app' that point to pointers to integer values
int (*apa[])[]; // array of pointers 'apa' to arrays of integers
int (*apf[])(); // array of pointers 'apf' to functions with return values of type integer
int ***fpp();   // function 'fpp' which returns a pointer to a pointer to a pointer to an int
int (*fpa())[]; // function 'fpa' with return value of a pointer to array of integers
int (*fpf())(); // function 'fpf' with return value of a pointer to function which returns an integer
&lt;/syntaxhighlight&gt;

== sizeof ==

The sizeof operator is often used to refer to the size of a static array declared earlier in the same function.

To find the end of an array
(example from [[wikipedia:Buffer overflow]]):

&lt;source lang=c&gt;
/* better.c - demonstrates one method of fixing the problem */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
  char buffer[10];
  if (argc &lt; 2)
  {
    fprintf(stderr, "USAGE: %s string\n", argv[0]);
    return 1;
  }
  strncpy(buffer, argv[1], sizeof(buffer));
  buffer[sizeof(buffer) - 1] = '\0';
  return 0;
}
&lt;/source&gt;


To iterate over every element of an array, use

&lt;source lang=c&gt;
 #define NUM_ELEM(x) (sizeof (x) / sizeof (*(x)))

 for( i = 0; i &lt; NUM_ELEM(array); i++ )
 {
     /* do something with array[i] */
     ;
 }
&lt;/source&gt;


Note that the &lt;code&gt;sizeof&lt;/code&gt; operator only works on things defined earlier in the same function.
The compiler replaces it with some fixed constant number.
In this case, the &lt;code&gt;buffer&lt;/code&gt; was declared as an array of 10 char's earlier in the same function, and the compiler replaces &lt;code&gt;sizeof(buffer)&lt;/code&gt; with the number 10 at compile time (equivalent to us hard-coding 10 into the code in place of &lt;code&gt;sizeof(buffer)&lt;/code&gt;).
The information about the length of &lt;code&gt;buffer&lt;/code&gt; is not actually stored anywhere in memory (unless we keep track of it separately) and cannot be programmatically obtained at run time from the array/pointer itself.

Often a function needs to know the size of an array it was given -- an array defined in some other function.
For example,

&lt;source lang=c&gt;
/* broken.c - demonstrates a flaw */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define NUM_ELEM(x) (sizeof (x) / sizeof (*(x)))

int sum( int input_array[] ){
  int sum_so_far = 0;
  int i;
  for( i = 0; i &lt; NUM_ELEM(input_array); i++ ) // WON'T WORK -- input_array wasn't defined in this function.
  {
    sum_so_far += input_array[i];
  };
  return( sum_so_far );
}

int main(int argc, char *argv[])
{
  int left_array[] = { 1, 2, 3 };
  int right_array[] = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
  int the_sum = sum( left_array );
  printf( "the sum of left_array is: %d", the_sum );
  the_sum = sum( right_array );
  printf( "the sum of right_array is: %d", the_sum );

  return 0;
}
&lt;/source&gt;

Unfortunately, (in C and C++) the length of the array cannot be obtained from an array passed in at run time, because (as mentioned above) the size of an array is not stored anywhere.
The compiler always replaces sizeof with a constant.
This sum() routine needs to handle more than just one constant length of an array.

There are some common ways to work around this fact:
* Write the function to require, for each array parameter, a "length" parameter (which has type "size_t"). (Typically we use sizeof at the point where this function is called).
* Use of a convention, such as a [[wikipedia:null-terminated string|null-terminated string]] to mark the end of the array.
* Instead of passing raw arrays, pass a structure that includes the length of the array (such as ".length") as well as the array (or a pointer to the first element); similar to the &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt; classes in C++.

&lt;!-- FIXME: untested --&gt;
&lt;source lang=c&gt;
/* fixed.c - demonstrates one work-around */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define NUM_ELEM(x) (sizeof (x) / sizeof (*(x)))

int sum( int input_array[], size_t length ){
  int sum_so_far = 0;
  int i;
  for( i = 0; i &lt; length; i++ )
  {
    sum_so_far += input_array[i];
  };
  return( sum_so_far );
}

int main(int argc, char *argv[])
{
  int left_array[] = { 1, 2, 3, 4 };
  int right_array[] = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
  int the_sum = sum( left_array, NUM_ELEM(left_array) ); // works here, because left_array is defined in this function
  printf( "the sum of left_array is: %d", the_sum );
  the_sum = sum( right_array, NUM_ELEM(right_array) ); // works here, because right_array is defined in this function
  printf( "the sum of right_array is: %d", the_sum );

  return 0;
}
&lt;/source&gt;

It's worth mentioning that sizeof operator has two variations: &lt;tt&gt;sizeof (&lt;i&gt;type&lt;/i&gt;)&lt;/tt&gt; (for instance: &lt;tt&gt;sizeof (int)&lt;/tt&gt; or &lt;tt&gt;sizeof (struct some_structure)&lt;/tt&gt;) and &lt;tt&gt;sizeof &lt;i&gt;expression&lt;/i&gt;&lt;/tt&gt; (for instance: &lt;tt&gt;sizeof some_variable.some_field&lt;/tt&gt; or &lt;tt&gt;sizeof 1&lt;/tt&gt;).

== External Links ==
&lt;div class="noprint"&gt;
[[File:Pointer Fun with Binky (C).ogg|thumb|Pointer Fun with Binky]]
&lt;/div&gt;
* [http://www.cs.cf.ac.uk/Dave/C/node10.html#SECTION001080000000000000000 "Common Pointer Pitfalls"] by Dave Marshall

{{C Programming/Navigation|Composite data types|Memory management}}

[[de:C-Programmierung: Zeiger]]
[[fr:Programmation C/Pointeurs]]
[[it:C/Vettori e puntatori/Interscambiabilità tra puntatori e vettori]]
[[pl:C/Wskaźniki]]</text>
      <sha1>iwi0n5sdpdd7az7jisgmur5n32qxn49</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Preliminaries</title>
    <ns>0</ns>
    <id>3172</id>
    <revision>
      <id>3535013</id>
      <parentid>3535002</parentid>
      <timestamp>2019-04-04T14:15:06Z</timestamp>
      <contributor>
        <ip>2804:7F7:2382:F719:0:0:0:1</ip>
      </contributor>
      <comment>/* Basics of Using Functions */ Change 'caller' to 'function call', since that is clearer, as we did not defined what a 'caller' is beforehand</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8363" xml:space="preserve">{{C Programming/Navigation|Intro exercise|Compiling}}

Before learning C syntax and programming constructs, it is important to learn the meaning of a few key terms that are central in understanding C.

== Block Structure, Statements, Whitespace, and Scope ==

{{Side note|side=right|&lt;small&gt;Sentences delimited with '/*' and '*/' are comments, and the compiler ignores them.  They are described in [[C Programming/Structure and style|Programming Structure and Style]]&lt;/small&gt;}}

Next we'll discuss the '''basic structure''' of a C program. If you're familiar with [[w:Pascal (programming language)|PASCAL]], you may have heard it referred to as a '''block-structured''' language. C does not have complete block structure (and you'll find out why when you go over functions in detail) but it is still very important to understand what blocks are and how to use them. 

So what is in a '''block'''?  Generally, a block consists of executable '''statements'''.

But before we delve into blocks, let's examine statements. One way to describe statements is they are the text (and surrounding whitespace) the compiler will attempt to turn into executable instructions. A simpler definition is statements are bits of code that do things.
For example:


&lt;syntaxhighlight lang="c"&gt;
int i = 6;
&lt;/syntaxhighlight&gt;

This '''declares''' an integer variable, which can be '''accessed''' with the '''identifier''' 'i', and '''initializes''' it to the value 6.  The various data types are introduced in the chapter [[C Programming/Variables|Variables]].

You might have noticed the semicolon at the end of the statement. Statements in C always end with a semicolon (;). Leaving off the semicolon is a common mistake many people make, beginners and experts alike! So until it becomes second nature, be sure to double check your statements!

Since C is a "free-format" language, several statements can share a single line in the source file, like this:
&lt;syntaxhighlight lang="c"&gt;
/* this declares the variables 'i', 'test', 'foo', and 'bar'
    note that ONLY the variable named 'bar' is set to six! */
int i, test, foo, bar = 6;
&lt;/syntaxhighlight&gt;

There are several kinds of statements. You've already seen some of them, such as the assignment (&lt;code&gt;i = 6;&lt;/code&gt;). A substantial portion of this book deals with statement construction.

Back to our discussion of blocks. In C, blocks begin with an opening brace &lt;tt&gt;"{"&lt;/tt&gt; and end with a closing brace &lt;tt&gt;"}"&lt;/tt&gt;. Blocks can contain other blocks which can contain their own blocks, and so on.

Let's look at a block example.

&lt;syntaxhighlight lang="c"&gt;
int main(void)
{
    /* this is a 'block' */
    int i = 5;

    {
        /* this is also a 'block', nested inside the outer block */
        int i = 6;
    }

    return 0;
}
&lt;/syntaxhighlight&gt;

You can use blocks with the preceding statements, such as the main function declaration (and other statements we've not yet covered), but you can also use blocks by themselves.

'''Whitespace''' refers to the tab, space and newline characters that separate the text characters that make up the source code.&lt;br&gt;
Like many things in life, it's hard to appreciate whitespace until it's gone. To a C compiler, the source code

&lt;syntaxhighlight lang="c"&gt;
    printf("Hello world"); return 0;
&lt;/syntaxhighlight&gt;

is the same as

&lt;syntaxhighlight lang="c"&gt;
    printf("Hello world");
    return 0;
&lt;/syntaxhighlight&gt;

which is also the same as

&lt;syntaxhighlight lang="c"&gt;
    printf (
    "Hello world") ;



    return 0;
&lt;/syntaxhighlight&gt;

The compiler simply ignores most whitespace (except, for example, when it separates &lt;code&gt;return&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt;).  However, it is common practice to use spaces (or tabs) to organize source code for human readability.

Most of the time we do not want other functions or other programmer's [[w:Subroutine|routines]] accessing data we are currently manipulating, which is why it is important to understand the concept of scope.

'''Scope''' describes the level at which a piece of data or a function is visible. There are two types of scope in C, '''local''' and '''global'''. When we speak of '''global''' scope, we're referring to something that can be seen or manipulated from anywhere in the program. '''Local''' scope applies to a program element that can be seen or manipulated only within the block in which it was declared.

Let's look at some examples to get a better idea of scope.

&lt;syntaxhighlight lang="c"&gt;
int i = 5; /* this is a 'global' variable, it can be accessed from anywhere in the program */

/* this is a function, all variables inside of it
    are "local" to the function. */
int main(void)
{
    int i = 6; /* 'i' now equals 6 */
    printf("%d\n", i); /* prints a '6' to the screen, instead of the global variable of 'i', which is 5 */

    return 0;
}
&lt;/syntaxhighlight&gt;

That shows an example of local and global. But what about different scopes ''inside'' of functions?&lt;br&gt;
(you'll learn more about functions later, for now, just focus on the "main" part.)

&lt;syntaxhighlight lang="c"&gt;
/* the main function */
int main(void)
{
    /* this is the beginning of a 'block', you read about those above */

    int i = 6; /* this is the first variable of this 'block', 'i' */

    {
        /* this is a new 'block', and because it's a different block, it has its own scope */

        /* this is also a variable called 'i', but in a different 'block',
            because it's in a different 'block' than the first variable named 'i', it doesn't affect the first one! */
        int i = 5;
        printf("%d\n", i); /* prints a '5' onto the screen */
    }
    /* now we're back into the first block */

    printf("%d\n", i); /* prints a '6' onto the screen */

    return 0;
}
&lt;/syntaxhighlight&gt;

== Basics of Using Functions ==

'''Functions''' are a big part of programming. A function is a special kind of block that performs a well-defined task. If a function is well-designed, it can enable a programmer to perform a task without knowing anything about how the function works. The act of requesting a function to perform its task is called a '''function call'''. Many functions require a function call to hand it certain pieces of data needed to perform its task; these are called '''arguments'''. Many functions also return a value to the function call when they're finished; this is called a '''return value''' (the return value in the above program is '''0''').

The things you need to know before calling a function are:
* What the function does
* The data type (discussed later) of the arguments and what they mean
* The data type of the return value and what it means

Many functions use the return value for the result of a computation. Some functions use the return value to indicate whether they successfully completed their work. As you have seen in the intro exercise, the &lt;code&gt;main&lt;/code&gt; function uses the return value to provide an exit status to the operating system.

All code other than global data definitions and declarations needs to be a part of a function.

Usually, you're free to call a function whatever you wish to. The only restriction is that every executable program needs to have one, and only one, '''main''' function, which is where the program begins executing.

We will discuss functions in more detail in a later chapter, [[C Programming/Procedures and functions]].

== The Standard Library ==

In 1983, when C was in the process of becoming standardized, the [[w:American National Standards Institute|American National Standards Institute]] (ANSI) formed a committee to establish a standard specification of C known as "ANSI C". That standard specification created a basic set of functions common to each implementation of C, which is referred to as the [[w:C standard library|Standard Library]]. The Standard Library provides functions for tasks such as input/output, string manipulation, mathematics, files, and memory allocation. The Standard Library does not provide functions that are dependent on specific hardware or operating systems, like graphics, sound, or networking. In the "Hello, World" program, a Standard Library function is used (&lt;code&gt;printf&lt;/code&gt;) which outputs lines of text to the [[Wikipedia:standard output|standard output]] stream.

== References ==
{{reflist}}

{{C Programming/Navigation|Intro exercise|Compiling}}

[[pl:C/Podstawy]]</text>
      <sha1>isfsbptctk2q4kanavz1oqpozvyb5g7</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Preprocessor directives and macros</title>
    <ns>0</ns>
    <id>25829</id>
    <revision>
      <id>3378164</id>
      <parentid>3354749</parentid>
      <timestamp>2018-02-25T02:44:47Z</timestamp>
      <contributor>
        <ip>2601:8B:C300:F440:7CF6:AE6C:F0B9:4CD8</ip>
      </contributor>
      <comment>Added __LINE__</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="30145" xml:space="preserve">{{C Programming/Navigation|Networking in UNIX|Common practices}}

Preprocessors are a way of making text processing with your C program before they are actually compiled. Before the actual compilation of every C program it is passed through a Preprocessor. The Preprocessor looks through the program trying to find out specific instructions called Preprocessor directives that it can understand. All Preprocessor directives begin with the # (hash) symbol.
C++ compilers use the same C preprocessor.&lt;ref&gt;
[[Understanding C++/C Preprocessor]]
&lt;/ref&gt;

The [[w:Preprocessor|preprocessor]] is a part of the compiler which performs preliminary operations (conditionally compiling code, including  files etc...) to your code before the compiler sees it.  These transformations are lexical, meaning that the output of the preprocessor is still text. 

{| WIDTH="95%"
| style="background-color: #f2fff2; border: solid 1px #bfffbf; padding: 1em;" valign=top|
NOTE: Technically the output of the preprocessing phase for C consists of a sequence of tokens, rather than source text, but it is simple to output source text which is equivalent to the given token sequence, and that is commonly supported by compilers via a &lt;tt&gt;-E&lt;/tt&gt; or &lt;tt&gt;/E&lt;/tt&gt; option -- although command line options to C compilers aren't completely standard, many follow similar rules.
|}

==Directives==
Directives are special instructions directed to the preprocessor (preprocessor directive) or to the [[w:compiler|compiler]] (compiler directive) on how it should process part or all of your source code or set some flags on the final object and are used to make writing source code easier (more portable for instance) and to make the source code more understandable. Directives are handled by the preprocessor, which is either a separate program invoked by the compiler or part of the compiler itself.

===#include===
C has some features as part of the language and some others as part of a '''standard library''', which is a repository of code that is available alongside every standard-conformant C compiler. When the C compiler compiles your program it usually also links it with the standard C library. For example, on encountering a &lt;code&gt;#include &lt;stdio.h&gt;&lt;/code&gt; directive, it replaces the directive with the contents of the &lt;tt&gt;stdio.h&lt;/tt&gt; header file.

When you use features from the library, C requires you to ''declare'' what you would be using. The first line in the program is a '''preprocessing directive''' which should look like this:

 #include &lt;stdio.h&gt;

The above line causes the C declarations which are in the &lt;tt&gt;stdio.h&lt;/tt&gt; [[w:Header file|header]] to be included for use in your program. Usually this is implemented by just inserting into your program the contents of a '''header file''' called &lt;tt&gt;stdio.h&lt;/tt&gt;, located in a system-dependent location. The location of such files may be described in your compiler's documentation. A list of standard C header files is listed below in the Headers table.

The &lt;tt&gt;stdio.h&lt;/tt&gt; header contains various declarations for input/output (I/O) using an abstraction of I/O mechanisms called '''streams'''. For example there is an output stream object called &lt;tt&gt;stdout&lt;/tt&gt; which is used to output text to the standard output, which usually displays the text on the computer screen.

If using angle brackets like the example above, the preprocessor is instructed to search for the include file along the development environment path for the standard includes.

 #include "other.h"

If you use  quotation marks (&lt;tt&gt;" "&lt;/tt&gt;), the preprocessor is expected to search in some additional, usually user-defined, locations for the header file, and to fall back to the standard include paths only if it is not found in those additional locations.  It is common for this form to include searching in the same directory as the file containing the &lt;tt&gt;#include&lt;/tt&gt; directive.

{| WIDTH="95%"
| style="background-color: #f2fff2; border: solid 1px #bfffbf; padding: 1em;" valign=top|
NOTE: You should check the documentation of the development environment you are using for any vendor specific implementations of the &lt;tt&gt;#include&lt;/tt&gt; directive.
|}

====Headers====

&lt;b&gt;The C90 standard headers list:&lt;/b&gt;

&lt;table&gt;
&lt;td&gt;
* &lt;tt&gt;[[w:Assert.h|&lt;assert.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Ctype.h|&lt;ctype.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Errno.h|&lt;errno.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Float.h|&lt;float.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Limits.h|&lt;limits.h&gt;]]&lt;/tt&gt;
&lt;/td&gt;&lt;td&gt;
* &lt;tt&gt;[[w:Locale.h|&lt;locale.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Math.h|&lt;math.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Setjmp.h|&lt;setjmp.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Signal.h|&lt;signal.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Stdarg.h|&lt;stdarg.h&gt;]]&lt;/tt&gt;
&lt;/td&gt;&lt;td&gt;
* &lt;tt&gt;[[w:Stddef.h|&lt;stddef.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Stdio.h|&lt;stdio.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Stdlib.h|&lt;stdlib.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:String.h|&lt;string.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Time.h|&lt;time.h&gt;]]&lt;/tt&gt;
&lt;/td&gt;
&lt;/table&gt;

&lt;b&gt;Headers added since C90:&lt;/b&gt;

&lt;table&gt;
&lt;td&gt;
* &lt;tt&gt;[[w:Complex.h|&lt;complex.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Fenv.h|&lt;fenv.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Inttypes.h|&lt;inttypes.h&gt;]]&lt;/tt&gt;
&lt;/td&gt;&lt;td&gt;
* &lt;tt&gt;[[w:Iso646.h|&lt;iso646.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Stdbool.h|&lt;stdbool.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Stdint.h|&lt;stdint.h&gt;]]&lt;/tt&gt;
&lt;/td&gt;&lt;td&gt;
* &lt;tt&gt;[[w:Tgmath.h|&lt;tgmath.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Wchar.h|&lt;wchar.h&gt;]]&lt;/tt&gt;
* &lt;tt&gt;[[w:Wctype.h|&lt;wctype.h&gt;]]&lt;/tt&gt;
&lt;/td&gt;
&lt;/table&gt;

===#pragma===
The '''pragma''' (pragmatic information) directive is part of the standard, but the meaning of any pragma depends on the software implementation of the standard that is used. The #pragma directive provides a way to request special behavior from the compiler. This directive is most useful for programs that are unusually large or that need to take advantage of the capabilities of a particular compiler. 

Pragmas are used within the source program.

 #pragma token(s)

#pragma is usually followed by a single token, which represents a command for the compiler to obey. You should check the software implementation of the C standard you intend on using for a list of the supported tokens. Not surprisingly, the set of commands that can appear in #pragma directives is different for each compiler; you'll have to consult the documentation for your compiler to see which commands it allows and what those commands do. 

For instance one of the most implemented preprocessor directives, &lt;code&gt;#pragma once&lt;/code&gt; when placed at the beginning of a header file, indicates that the file where it resides will be skipped if included several times by the preprocessor.

{| WIDTH="95%"
| style="background-color: #f2fff2; border: solid 1px #bfffbf; padding: 1em;" valign=top|
NOTE: Other methods exist to do this action that is commonly referred as using '''include guards'''.
|}
&lt;br&gt;&lt;br&gt;

===&lt;tt&gt;#define&lt;/tt&gt;===

{| WIDTH="95%"
| style="background-color: #fff2f2; border: solid 1px #ffbfbf; padding: 1em;" valign=top|
WARNING: Preprocessor macros, although tempting, can produce quite unexpected results if not done right. Always keep in mind that macros are textual substitutions done to your source code before anything is compiled. The compiler does not know anything about the macros and never gets to see them. This can produce obscure errors, amongst other negative effects. Prefer to use language features, if there are equivalent (In example use &lt;code&gt;const int&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; instead of &lt;code&gt;#define&lt;/code&gt;d constants).

That said, there are cases, where macros are very useful (see the &lt;code&gt;debug&lt;/code&gt; macro below for an example).    
|}

The &lt;tt&gt;#define&lt;/tt&gt; directive is used to define values or macros that are used by the preprocessor to manipulate the program source code before it is compiled.  Because preprocessor definitions are substituted before the compiler acts on the source code, any errors that are introduced by &lt;tt&gt;#define&lt;/tt&gt; are difficult to trace.  

By convention, values defined using &lt;tt&gt;#define&lt;/tt&gt; are named in uppercase.  Although doing so is not a requirement, it is considered very bad practice to do otherwise.  This allows the values to be easily identified when reading the source code.

Today, &lt;tt&gt;#define&lt;/tt&gt; is primarily used to handle compiler and platform differences. E.g., a define might hold a constant which is the appropriate error code for a system call.  The use of &lt;tt&gt;#define&lt;/tt&gt; should thus be limited unless absolutely necessary; &lt;tt&gt;typedef&lt;/tt&gt; statements and constant variables can often perform the same functions more safely.  

Another feature of the &lt;tt&gt;#define&lt;/tt&gt; command is that it can take arguments, making it rather useful as a pseudo-function creator. Consider the following code: 

 #define ABSOLUTE_VALUE( x ) ( ((x) &lt; 0) ? -(x) : (x) )
 ...
 int x = -1;
 while( ABSOLUTE_VALUE( x ) ) {
 ...
 }
		
It's generally a good idea to use extra parentheses when using complex macros. Notice that in the above example, the variable "x" is always within its own set of parentheses. This way, it will be evaluated in whole, before being compared to 0 or multiplied by -1. Also, the entire macro is surrounded by parentheses, to prevent it from being contaminated by other code. If you're not careful, you run the risk of having the compiler misinterpret your code.

Because of side-effects it is considered a very bad idea to use macro functions as described above.

 int x = -10;
 int y = ABSOLUTE_VALUE( x++ );

If ABSOLUTE_VALUE() were a real function 'x' would now have the value of '-9', but because it was an argument in a macro it was expanded twice and thus has a value of -8.

{| WIDTH="95%"
| style="background-color: #fefefe; border: solid 1px black; padding: 1em;" valign=top|
Example:

To illustrate the dangers of macros, consider this naive macro
 #define MAX(a,b) a&gt;b?a:b
and the code
 i = MAX(2,3)+5;
 j = MAX(3,2)+5;
Take a look at this and consider what the value after execution might be.  The statements are turned into 
 int i = 2&gt;3?2:3+5;
 int j = 3&gt;2?3:2+5;
Thus, after execution &lt;tt&gt;i=8&lt;/tt&gt; and &lt;tt&gt;j=3&lt;/tt&gt; instead of the expected result of &lt;tt&gt;i=j=8&lt;/tt&gt;! This is why you were cautioned to use an extra set of parenthesis above, but even with these, the road is fraught with dangers. The alert reader might quickly realize that if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; contains expressions, the definition must parenthesize every use of &lt;tt&gt;a,b&lt;/tt&gt; in the macro definition, like this:
 #define MAX(a,b) ((a)&gt;(b)?(a):(b))
This works, provided &lt;tt&gt;a,b&lt;/tt&gt; have no side effects. Indeed, 
 i = 2;
 j = 3;
 k = MAX(i++, j++);
would result in &lt;tt&gt;k=4&lt;/tt&gt;, &lt;tt&gt;i=3&lt;/tt&gt; and &lt;tt&gt;j=5&lt;/tt&gt;. This would be highly surprising to anyone expecting &lt;tt&gt;MAX()&lt;/tt&gt; to behave like a function.

So what is the correct solution? The solution is not to use macro at all. A global, inline function, like this

 inline int max(int a, int b) { 
   return a&gt;b?a:b 
 }

has none of the pitfalls above, but will not work with all types.

{| WIDTH="95%"
| style="background-color: #f2fff2; border: solid 1px #bfffbf; padding: 1em;" valign=top|
NOTE: The explicit &lt;code&gt;inline&lt;/code&gt; declaration is not really necessary unless the definition is in a header file, since your compiler can inline functions for you (with gcc this can be done with &lt;code&gt;-finline-functions&lt;/code&gt; or &lt;code&gt;-O3&lt;/code&gt;). The compiler is often better than the programmer at predicting which functions are worth inlining. Also, function calls are not really expensive (they used to be). 

The compiler is actually free to ignore the &lt;code&gt;inline&lt;/code&gt; keyword. It is only a hint (except that &lt;code&gt;inline&lt;/code&gt; is necessary in order to allow a function to be defined in a header file without generating an error message due to the function being defined in more than one translation unit).
|}
|}


('''#, ##''')

The '''#''' and '''##''' operators are used with the &lt;tt&gt;#define&lt;/tt&gt; macro. Using # causes the first argument after the '''#''' to be returned as a string in quotes. For example, the command 

 #define as_string( s ) # s
		
will make the compiler turn this command 

 puts( as_string( Hello World! ) ) ;
		
into 

 puts( "Hello World!" );
		
Using '''##''' concatenates what's before the '''##''' with what's after it. For example, the command 

 #define concatenate( x, y ) x ## y
 ...
 int xy = 10;
 ...
	
will make the compiler turn 

 printf( "%d", concatenate( x, y ));
		
into 

 printf( "%d", xy);
		
which will, of course, display &lt;tt&gt;10&lt;/tt&gt; to standard output.

It is possible to concatenate a macro argument with a constant prefix or suffix to obtain a valid identifier as in

 #define make_function( name ) int my_ ## name (int foo) {}
 make_function( bar )

which will define a function called &lt;tt&gt;my_bar()&lt;/tt&gt;. But it isn't possible to integrate a macro argument into a constant string using the concatenation operator. In order to obtain such an effect, one can use the ANSI C property that two or more consecutive string constants are considered equivalent to a single string constant when encountered. Using this property, one can write

 #define eat( what ) puts( "I'm eating " #what " today." )
 eat( fruit )

which the macro-processor will turn into

 puts( "I'm eating " "fruit" " today." )

which in turn will be interpreted by the C parser as a single string constant.

The following trick can be used to turn a numeric constants into string literals

 #define num2str(x) str(x)
 #define str(x) #x
 #define CONST 23
 
 puts(num2str(CONST));

This is a bit tricky, since it is expanded in 2 steps. First &lt;code&gt;num2str(CONST)&lt;/code&gt; is replaced with &lt;code&gt;str(23)&lt;/code&gt;, which in turn is replaced with &lt;code&gt;"23"&lt;/code&gt;. This can be useful in the following example:

 #ifdef DEBUG
 #define debug(msg) fputs(__FILE__ ":" num2str(__LINE__) " - " msg, stderr)
 #else
 #define debug(msg)
 #endif

This will give you a nice debug message including the file and the line where the message was issued. If DEBUG is not defined however the debugging message will completely vanish from your code. Be careful not to use this sort of construct with anything that has side effects, since this can lead to bugs, that appear and disappear depending on the compilation parameters.

===macros===

Macros aren't type-checked and so they do not evaluate arguments. Also, they do not obey scope properly, but simply take the string passed to them and replace each occurrence of the macro argument in the text of the macro with the actual string for that parameter (the code is literally copied into the location it was called from).

An example on how to use a macro:
&lt;pre&gt;
 #include &lt;stdio.h&gt;

 #define SLICES 8
 #define ADD(x) ( (x) / SLICES )

 int main(void) 
 {
   int a = 0, b = 10, c = 6;

   a = ADD(b + c);
   printf("%d\n", a);
   return 0;
 }
&lt;/pre&gt;
-- the result of "a" should be "2" (b + c = 16 -&gt; passed to ADD -&gt; 16 / SLICES -&gt; result is "2")

{| WIDTH="95%"
| style="background-color: #f2fff2; border: solid 1px #bfffbf; padding: 1em;" valign=top|
NOTE:&lt;br&gt;
It is usually bad practice to define macros in headers.

A macro should be defined only when it is not possible to achieve the same result with a 
function or some other mechanism. Some compilers are able to optimize code to where calls to small functions are replaced with inline code, negating any possible speed advantage.
Using typedefs, enums, and &lt;tt&gt;inline&lt;/tt&gt; (in C99) is often a better option.
|}

One of the few situations where inline functions won't work -- so you are pretty much forced to use function-like macros instead -- is to initialize compile time constants (static initialization of structs).
This happens when the arguments to the macro are literals that the compiler can optimize to another literal.
&lt;ref&gt;
David Hart, Jon Reid.
[http://qualitycoding.org/preprocessor/ "9 Code Smells of Preprocessor Use"].
2012.
&lt;/ref&gt;

===#error===
The '''#error''' directive halts compilation.   When one is encountered the standard specifies that the compiler should emit a diagnostic containing the remaining tokens in the directive.  This is mostly used for debugging purposes.

Programmers use "#error" inside a conditional block, to immediately halt the compiler when the "#if" or "#ifdef" -- at the beginning of the block -- detects a compile-time problem.
Normally the compiler skips the block (and the "#error" directive inside it) and the compilation proceeds.

&lt;source lang="c"&gt;
  #error message
&lt;/source&gt;

===#warning===

Many compilers support a  '''#warning''' directive. When one is encountered, the compiler emits a diagnostic containing the remaining tokens in the directive.

&lt;source lang="c"&gt;
  #warning message
&lt;/source&gt;

===#undef===
The '''#undef''' directive undefines a macro.  The identifier need not have been previously defined.

===#if,#else,#elif,#endif (conditionals)===
The '''#if''' command checks whether a controlling conditional expression evaluates to zero or nonzero, and excludes or includes a block of code respectively. For example:

&lt;source lang="c"&gt;
 #if 1
    /* This block will be included */
 #endif
 #if 0
    /* This block will not be included */
 #endif
&lt;/source&gt;

The conditional expression could contain any C operator except for the assignment operators, the increment and decrement operators, the address-of operator, and the sizeof operator.

One unique operator used in preprocessing and nowhere else is the '''defined''' operator. It returns 1 if the macro name, optionally enclosed in parentheses, is currently defined; 0 if not.

The '''#endif''' command ends a block started by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, or &lt;code&gt;#ifndef&lt;/code&gt;.

The '''#elif''' command is similar to &lt;code&gt;#if&lt;/code&gt;, except that it is used to extract one from a series of blocks of code. E.g.:

&lt;pre&gt;
 #if /* some expression */
   :
   :
   :
 #elif /* another expression */
   :
 /* imagine many more #elifs here ... */
   :
 #else
 /* The optional #else block is selected if none of the previous #if or
    #elif blocks are selected */
   :
   :
 #endif /* The end of the #if block */
&lt;/pre&gt;

===#ifdef,#ifndef===

The '''#ifdef''' command is similar to &lt;code&gt;#if&lt;/code&gt;, except that the code block following it is selected if a macro name is defined. In this respect,

 #ifdef NAME

is equivalent to

 #if defined NAME



The '''#ifndef''' command is similar to '''#ifdef''', except that the test is reversed:

 #ifndef NAME

is equivalent to

 #if !defined NAME
=== #line ===
This preprocessor directive is used to set the file name and the line number of the line following the directive to new values. This is used to set the __FILE__ and __LINE__ macros.
== Useful Preprocessor Macros for Debugging ==
ANSI C defines some useful preprocessor macros and variables,&lt;ref&gt;
[http://docs.hp.com/en/B3901-90003/ch07s04.html HP C Compiler Reference Manual]
&lt;/ref&gt;&lt;ref&gt;
[http://www.cppreference.com/wiki/preprocessor/preprocessor_vars C++ reference: Predefined preprocessor variables]
&lt;/ref&gt;
also called "magic constants", include:

__FILE__   =&gt; The name of the current file, as a string literal&lt;br/&gt;
__LINE__   =&gt; Current line of the source file, as a numeric literal&lt;br/&gt;
__DATE__   =&gt; Current system date, as a string&lt;br/&gt;
__TIME__   =&gt; Current system time, as a string&lt;br/&gt;
__TIMESTAMP__ =&gt; Date and time (non-standard)&lt;br/&gt;
__cplusplus =&gt; undefined when your C code is being compiled by a C compiler; 199711L when your C code is being compiled by a C++ compiler compliant with 1998 C++ standard.&lt;br/&gt;
__func__ =&gt; Current function name of the source file, as a string (part of C99)&lt;br/&gt;
__PRETTY_FUNCTION__ =&gt; "decorated" Current function name of the source file, as a string (in GCC; non-standard)&lt;br/&gt;

==== Compile-time assertions ====

Compile-time assertions can help you debug faster than using only run-time assert() statements, because the compile-time assertions are all tested at compile time, while it is possible that a test run of a program may fail to exercise some run-time assert() statements.

Prior to the C11 standard, some people&lt;ref&gt;
[http://www.jaggersoft.com/pubs/CVu11_3.html "Compile Time Assertions in C"] by Jon Jagger 1999
&lt;/ref&gt;&lt;ref&gt;
Pádraig Brady.
[http://www.pixelbeat.org/programming/gcc/static_assert.html "static assertion"].
&lt;/ref&gt;&lt;ref&gt;
[http://stackoverflow.com/questions/27586311/ternary-operator-with-a-constant-true-value "ternary operator with a constant (true) value?"].
&lt;/ref&gt;
defined a preprocessor macro to allow compile-time assertions, something like:
&lt;source lang="c"&gt;
#define COMPILE_TIME_ASSERT(pred) switch(0){case 0:case pred:;}

COMPILE_TIME_ASSERT( BOOLEAN CONDITION );
&lt;/source&gt;

The &lt;code&gt;static_assert.hpp&lt;/code&gt; [[C++ Programming/Libraries/Boost | Boost library]] defines a similar macro.&lt;ref&gt;
[[Wikipedia: C++0x#Static assertions]]
&lt;/ref&gt;

Since C11, such macros are obsolete, as &lt;code&gt;_Static_assert&lt;/code&gt; and its macro equivalent &lt;code&gt;static_assert&lt;/code&gt; are standardized and built-in to the language.

==== X-Macros ====
{{merge to | C Programming/Serialization#X-Macros}}

One little-known usage pattern of the C preprocessor is known as "X-Macros".&lt;ref name="X_macros"&gt;Wirzenius, Lars. [http://liw.iki.fi/liw/texts/cpp-trick.html C Preprocessor Trick For Implementing Similar Data Types] Retrieved January 9, 2011.&lt;/ref&gt;&lt;ref&gt;{{cite journal
 | last = Meyers
 | first = Randy
 | year = 2001
 | month = May
 | title = The New C: X Macros
 | journal = Dr. Dobb's Journal
 | url = http://www.ddj.com/cpp/14401387
 |  accessdate = 1 May 2008
 }}
&lt;/ref&gt;&lt;ref&gt;{{cite journal
 | last = Beal
 | first = Stephan
 | month = August
 | year = 2004
 | title = Supermacros
 | url = http://wanderinghorse.net/computing/papers/#supermacros
 |  accessdate = 27 October 2008
}}&lt;/ref&gt;&lt;ref&gt;
Keith Schwarz.
[http://www.keithschwarz.com/cs106l/spring2009/handouts/080_Preprocessor_2.pdf "Advanced Preprocessor Techniques"].
2009.
Includes "Practical Applications of the Preprocessor II: The X Macro Trick".
&lt;/ref&gt;
An X-Macro is a [[C++ Programming‎/Programming Languages‎/C++‎/Code/File Organization#.h|header file]] or macro.  Commonly these use the extension ".def" instead of the traditional ".h". This file contains a list of similar macro calls, which can be referred to as "component macros".  The include file is then referenced repeatedly in the following pattern.  Here, the include file is "xmacro.def" and it contains a list of component macros of the style "foo(x, y, z)".

&lt;source lang="c"&gt;
#define foo(x, y, z) doSomethingWith(x, y, z);
#include "xmacro.def"
#undef foo

#define foo(x, y, z) doSomethingElseWith(x, y, z);
#include "xmacro.def"
#undef foo

(etc...)
&lt;/source&gt;

The most common usage of X-Macros is to establish a list of C objects and then automatically generate code for each of them. Some implementations also perform any &lt;code&gt;#undef&lt;/code&gt;s they need inside the X-Macro, as opposed to expecting the caller to undefine them.

Common sets of objects are a set of global configuration settings, a set of members of a [[struct (C programming language)|struct]], a list of possible [[XML]] tags for converting an XML file to a quickly-traversable tree, or the body of an [[enumerated type|enum]] declaration; other lists are possible.

Once the X-Macro has been processed to create the list of objects, the component macros can be redefined to generate, for instance, [[mutator method|accessor and/or mutator]] functions.  Structure [[serialization|serializing and deserializing]] are also commonly done.

Here is an example of an X-Macro that establishes a struct and automatically creates serialize/deserialize functions. For simplicity, this example doesn't account for endianness or buffer overflows.

File '''star.def''':
&lt;source lang="c"&gt;
EXPAND_EXPAND_STAR_MEMBER(x, int)
EXPAND_EXPAND_STAR_MEMBER(y, int)
EXPAND_EXPAND_STAR_MEMBER(z, int)
EXPAND_EXPAND_STAR_MEMBER(radius, double)
#undef EXPAND_EXPAND_STAR_MEMBER
&lt;/source&gt;

File '''star_table.c''':
&lt;source lang="c"&gt;
typedef struct {
  #define EXPAND_EXPAND_STAR_MEMBER(member, type) type member;
  #include "star.def"
  } starStruct;

void serialize_star(const starStruct *const star, unsigned char *buffer) {
  #define EXPAND_EXPAND_STAR_MEMBER(member, type) \
    memcpy(buffer, &amp;(star-&gt;member), sizeof(star-&gt;member)); \
    buffer += sizeof(star-&gt;member);
  #include "star.def"
  }

void deserialize_star(starStruct *const star, const unsigned char *buffer) {
  #define EXPAND_EXPAND_STAR_MEMBER(member, type) \
    memcpy(&amp;(star-&gt;member), buffer, sizeof(star-&gt;member)); \
    buffer += sizeof(star-&gt;member);
  #include "star.def"
  }
&lt;/source&gt;

Handlers for individual data types may be created and accessed using token concatenation ("&lt;code&gt;##&lt;/code&gt;") and quoting ("&lt;code&gt;#&lt;/code&gt;") operators.
For example, the following might be added to the above code:

&lt;source lang="c"&gt;
#define print_int(val)    printf("%d", val)
#define print_double(val) printf("%g", val)

void print_star(const starStruct *const star) {
  /* print_##type will be replaced with print_int or print_double */
  #define EXPAND_EXPAND_STAR_MEMBER(member, type) \
    printf("%s: ", #member); \
    print_##type(star-&gt;member); \
    printf("\n");
  #include "star.def"
  }
&lt;/source&gt;

Note that in this example you can also avoid the creation of separate handler functions for each datatype in this example by defining the print format for each supported type, with the additional benefit of reducing the expansion code produced by this header file:

&lt;source lang="c"&gt;
#define FORMAT_(type) FORMAT_##type
#define FORMAT_int    "%d"
#define FORMAT_double "%g"

void print_star(const starStruct *const star) {
  /* FORMAT_(type) will be replaced with FORMAT_int or FORMAT_double */
  #define EXPAND_EXPAND_STAR_MEMBER(member, type) \
    printf("%s: " FORMAT_(type) "\n", #member, star-&gt;member);
  #include "star.def"
  }
&lt;/source&gt;

The creation of a separate header file can be avoided by creating a single macro containing what would be the contents of the file.  For instance, the above file "star.def" could be replaced with this macro at the beginning of:

File '''star_table.c''':
&lt;source lang="c"&gt;
#define EXPAND_STAR \
  EXPAND_STAR_MEMBER(x, int) \
  EXPAND_STAR_MEMBER(y, int) \
  EXPAND_STAR_MEMBER(z, int) \
  EXPAND_STAR_MEMBER(radius, double)
&lt;/source&gt;

and then all calls to &lt;code&gt;#include "star.def"&lt;/code&gt; could be replaced with a simple &lt;code&gt;EXPAND_STAR&lt;/code&gt; statement.  The rest of the above file would become:

&lt;source lang="c"&gt;
typedef struct {
  #define EXPAND_STAR_MEMBER(member, type) type member;
  EXPAND_STAR
  #undef  EXPAND_STAR_MEMBER
  } starStruct;

void serialize_star(const starStruct *const star, unsigned char *buffer) {
  #define EXPAND_STAR_MEMBER(member, type) \
    memcpy(buffer, &amp;(star-&gt;member), sizeof(star-&gt;member)); \
    buffer += sizeof(star-&gt;member);
  EXPAND_STAR
  #undef  EXPAND_STAR_MEMBER
  }

void deserialize_star(starStruct *const star, const unsigned char *buffer) {
  #define EXPAND_STAR_MEMBER(member, type) \
    memcpy(&amp;(star-&gt;member), buffer, sizeof(star-&gt;member)); \
    buffer += sizeof(star-&gt;member);
  EXPAND_STAR
  #undef  EXPAND_STAR_MEMBER
  }
&lt;/source&gt;

and the print handler could be added as well as:

&lt;source lang="c"&gt;
#define print_int(val)    printf("%d", val)
#define print_double(val) printf("%g", val)

void print_star(const starStruct *const star) {
  /* print_##type will be replaced with print_int or print_double */
  #define EXPAND_STAR_MEMBER(member, type) \
    printf("%s: ", #member); \
    print_##type(star-&gt;member); \
    printf("\n");
  EXPAND_STAR
  #undef EXPAND_STAR_MEMBER
}
&lt;/source&gt;

or as:

&lt;source lang="c"&gt;
#define FORMAT_(type) FORMAT_##type
#define FORMAT_int    "%d"
#define FORMAT_double "%g"

void print_star(const starStruct *const star) {
  /* FORMAT_(type) will be replaced with FORMAT_int or FORMAT_double */
  #define EXPAND_STAR_MEMBER(member, type) \
    printf("%s: " FORMAT_(type) "\n", #member, star-&gt;member);
  EXPAND_STAR
  #undef EXPAND_STAR_MEMBER
  }
&lt;/source&gt;

A variant which avoids needing to know the members of any expanded sub-macros is to accept the operators as an argument to the list macro:

File '''star_table.c''':
&lt;source lang="c"&gt;
/*
 Generic
 */
#define STRUCT_MEMBER(member, type, dummy) type member;

#define SERIALIZE_MEMBER(member, type, obj, buffer) \
  memcpy(buffer, &amp;(obj-&gt;member), sizeof(obj-&gt;member)); \
  buffer += sizeof(obj-&gt;member);

#define DESERIALIZE_MEMBER(member, type, obj, buffer) \
  memcpy(&amp;(obj-&gt;member), buffer, sizeof(obj-&gt;member)); \
  buffer += sizeof(obj-&gt;member);

#define FORMAT_(type) FORMAT_##type
#define FORMAT_int    "%d"
#define FORMAT_double "%g"

/* FORMAT_(type) will be replaced with FORMAT_int or FORMAT_double */
#define PRINT_MEMBER(member, type, obj) \
  printf("%s: " FORMAT_(type) "\n", #member, obj-&gt;member);

/*
 starStruct
 */

#define EXPAND_STAR(_, ...) \
  _(x, int, __VA_ARGS__) \
  _(y, int, __VA_ARGS__) \
  _(z, int, __VA_ARGS__) \
  _(radius, double, __VA_ARGS__)

typedef struct {
  EXPAND_STAR(STRUCT_MEMBER, )
  } starStruct;

void serialize_star(const starStruct *const star, unsigned char *buffer) {
  EXPAND_STAR(SERIALIZE_MEMBER, star, buffer)
  }

void deserialize_star(starStruct *const star, const unsigned char *buffer) {
  EXPAND_STAR(DESERIALIZE_MEMBER, star, buffer)
  }

void print_star(const starStruct *const star) {
  EXPAND_STAR(PRINT_MEMBER, star)
  }
&lt;/source&gt;

This approach can be dangerous in that the entire macro set is always interpreted as if it was on a single source line, which could encounter compiler limits with complex component macros and/or long member lists.

This technique was reported by Lars Wirzenius&lt;ref&gt;Wirzenius, Lars. [http://liw.iki.fi/liw/texts/cpp-trick.html C Preprocessor Trick For Implementing Similar Data Types] Retrieved January 9, 2011.&lt;/ref&gt; in a web page dated January 17, 2000, in which he gives credit to Kenneth Oksanen for "refining and developing" the technique prior to 1997.  The other references describe it as a method from at least a decade before the turn of the century.


We discuss X-Macros more in a later section, [[C Programming/Serialization|Serialization and X-Macros]].

{{Wikipediapar||C preprocessor}}
{{reflist}}

[[de:C-Programmierung: Präprozessor]]
[[fr:Programmation C/Préprocesseur]]
[[it:C/Compilatore e precompilatore/Direttive]]
[[pl:C/Preprocesor]]

{{C Programming/Navigation|Error handling|Common practices}}</text>
      <sha1>p2rwsw7749jlje9f3oyyo8p9xu107ds</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Program flow control</title>
    <ns>0</ns>
    <id>2131</id>
    <revision>
      <id>3578620</id>
      <parentid>3578615</parentid>
      <timestamp>2019-09-23T10:51:22Z</timestamp>
      <contributor>
        <username>Minorax</username>
        <id>3226541</id>
      </contributor>
      <comment>Undid revision 3578615 by [[Special:Contributions/112.20.175.212|112.20.175.212]] ([[User talk:112.20.175.212|discuss]]) ?</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27277" xml:space="preserve">{{C Programming/Navigation|Arrays|Procedures and functions}}

Very few programs follow exactly one control path and have each instruction stated explicitly. In order to program effectively, it is necessary to understand how one can alter the steps taken by a program due to user input or other conditions, how some steps can be executed many times with few lines of code, and how programs can appear to demonstrate a rudimentary grasp of logic. C constructs known as conditionals and loops grant this power.

From this point forward, it is necessary to understand what is usually meant by the word ''block''. A block is a group of code statements that are associated and intended to be executed as a unit. In C, the beginning of a block of code is denoted with { (left curly), and the end of a block is denoted with }. It is not necessary to place a semicolon after the end of a block. Blocks can be empty, as in {}. Blocks can also be nested; i.e. there can be blocks of code within larger blocks.

== Conditionals==

There is likely no meaningful program written in which a computer does not demonstrate basic decision-making skills. It can actually be argued that there is no meaningful human activity in which some sort of decision-making, instinctual or otherwise, does not take place. For example, when driving a car and approaching a traffic light, one does not think, "I will continue driving through the intersection." Rather, one thinks, "I will stop if the light is red, go if the light is green, and if yellow go only if I am traveling at a certain speed a certain distance from the intersection." These kinds of processes can be simulated in C using conditionals.

A conditional is a statement that instructs the computer to execute a certain block of code or alter certain data only if a specific condition has been met. The most common conditional is the If-Else statement, with conditional expressions and Switch-Case statements typically used as more shorthanded methods.

Before one can understand conditional statements, it is first necessary to understand how C expresses logical relations. C treats logic as being arithmetic. The value 0 (zero) represents false, and '''''all other values''''' represent true. If you chose some particular value to represent true and then compare values against it, sooner or later your code will fail when your assumed value (often 1) turns out to be incorrect. Code written by people uncomfortable with the C language can often be identified by the usage of #define to make a "TRUE" value.
&lt;ref&gt;
[http://www.c-faq.com/bool/bool2.html C FAQ]
&lt;/ref&gt;

Because logic is arithmetic in C, arithmetic operators and logical operators are one and the same. Nevertheless, there are a number of operators that are typically associated with logic:

===Relational and Equivalence Expressions:===
; a &lt; b: 1 if '''a''' is less than '''b''', 0 otherwise.
; a &gt; b: 1 if '''a''' is greater than '''b''', 0 otherwise.
; a &lt;= b: 1 if '''a''' is less than or equal to '''b''', 0 otherwise.
; a &gt;= b: 1 if '''a''' is greater than or equal to '''b''', 0 otherwise.
; a == b: 1 if '''a''' is equal to '''b''', 0 otherwise.
; a != b: 1 if '''a''' is not equal to '''b''', 0 otherwise

New programmers should take special note of the fact that the "equal to" operator is ==, not =. This is the cause of numerous coding mistakes and is often a difficult-to-find bug, as the expression &lt;code&gt;(a = b)&lt;/code&gt; sets &lt;code&gt;a&lt;/code&gt; equal to &lt;code&gt;b&lt;/code&gt; and subsequently evaluates to &lt;code&gt;b&lt;/code&gt;; but the expression &lt;code&gt;(a == b)&lt;/code&gt;, which is usually intended, checks if &lt;code&gt;a&lt;/code&gt; is equal to &lt;code&gt;b&lt;/code&gt;. It needs to be pointed out that, if you confuse = with ==, your mistake will often not be brought to your attention by the compiler. A statement such as &lt;code&gt; if (c = 20) {}&lt;/code&gt; is considered perfectly valid by the language, but will always assign 20 to &lt;code&gt;c&lt;/code&gt; and evaluate as true. A simple technique to avoid this kind of bug (in many, not all cases) is to put the constant first. This will cause the compiler to issue an error, if == got misspelled with =.

Note that C does not have a dedicated boolean type as many other languages do. 0 means false and anything else true. So the following are equivalent:

&lt;source lang="c"&gt;
 if (foo()) {
   // do something
 }
&lt;/source&gt;

and

&lt;source lang="c"&gt;
 if (foo() != 0) {
   // do something
 }
&lt;/source&gt;

Often &lt;code&gt;#define TRUE 1&lt;/code&gt; and &lt;code&gt;#define FALSE 0&lt;/code&gt; are used to work around the lack of a boolean type. This is bad practice, since it makes assumptions that do not hold. It is a better idea to indicate what you are actually expecting as a result from a function call, as there are many different ways of indicating error conditions, depending on the situation.

&lt;source lang="c"&gt;
 if (strstr("foo", bar) &gt;= 0) {
   // bar contains "foo"
 } 
&lt;/source&gt;

Here, &lt;code&gt;strstr&lt;/code&gt; returns the index where the substring foo is found and -1 if it was not found. Note that this would fail with the &lt;code&gt;TRUE&lt;/code&gt; definition mentioned in the previous paragraph. It would also not produce the expected results if we omitted the &lt;code&gt; &gt;= 0&lt;/code&gt;.

One other thing to note is that the relational expressions do not evaluate as they would in mathematical texts. That is, an expression &lt;code&gt;myMin &lt; value &lt; myMax &lt;/code&gt; does not evaluate as you probably think it might. Mathematically, this would test whether or not ''value'' is between ''myMin'' and ''myMax''. But in C, what happens is that ''value'' is first compared with ''myMin''. This produces either a 0 or a 1. It is this value that is compared against myMax.  Example:
 
&lt;source lang="c"&gt;
 int value = 20;
 /* ... */
 if (0 &lt; value &lt; 10) { // don't do this! it always evaluates to "true"!
   /* do some stuff */
 }
&lt;/source&gt;

Because ''value'' is greater than 0, the first comparison produces a value of 1. Now 1 is compared to be less than 10, which is true, so the statements in the if are executed. This probably is not what the programmer expected.  The appropriate code would be

&lt;source lang="c"&gt;
 int value = 20;
 /* ... */
 if (0 &lt; value &amp;&amp; value &lt; 10) {   // the &amp;&amp; means "and"
   /* do some stuff */
 }
&lt;/source&gt;

===Logical Expressions===
; a || b: when EITHER '''a''' or '''b''' is true (or both), the result is 1, otherwise the result is 0.
; a &amp;&amp; b: when BOTH '''a''' and '''b''' are true, the result is 1, otherwise the result is 0.
; !a: when '''a''' is true, the result is 0, when '''a''' is 0, the result is 1.

Here's an example of a larger logical expression. In the statement:
   e = ((a &amp;&amp; b) || (c &gt; d));
e is set equal to 1 if a and b are non-zero, or if c is greater than d. In all other cases, e is set to 0.

C uses short circuit evaluation of logical expressions. That is to say, once it is
able to determine the truth of a logical expression, it does no further evaluation. This is often useful as in the following:

 int myArray[12];
 ....
 if (i &lt; 12 &amp;&amp; myArray[i] &gt; 3) { 
 ....

In the snippet of code, the comparison of i with 12 is done first.  If it evaluates to 0 (false), '''i''' would be out of bounds as an index to '''myArray'''.  In this case, the program never attempts to access '''myArray[i]''' since the truth of the expression is known to be false. Hence we need not worry here about trying to access an out-of-bounds array element if it is already known that i is greater than or equal to zero.
A similar thing happens with expressions involving the or || operator.

 while (doThis() || doThat()) ...

doThat() is never called if doThis() returns a non-zero (true) value.

===The If-Else statement ===

If-Else provides a way to instruct the computer to execute a block of code only if certain conditions have been met. The syntax of an If-Else construct is:

&lt;source lang="c"&gt;
 if (/* condition goes here */) {
   /* if the condition is non-zero (true), this code will execute */
 } else {
   /* if the condition is 0 (false), this code will execute */
 }
&lt;/source&gt;

The first block of code executes if the condition in parentheses directly after the ''if'' evaluates to non-zero (true); otherwise, the second block executes.

The ''else'' and following block of code are completely optional. If there is no need to execute code if a condition is not true, leave it out.

Also, keep in mind that an ''if'' can directly follow an ''else'' statement. While this can occasionally be useful, chaining more than two or three if-elses in this fashion is considered bad programming practice. We can get around this with the Switch-Case construct described later.

Two other general syntax notes need to be made that you will also see in other control constructs: First, note that there is no semicolon after ''if'' or ''else''. There could be, but the block (code enclosed in { and }) takes the place of that. Second, if you only intend to execute one statement as a result of an ''if'' or ''else'', curly braces are not needed. However, many programmers believe that inserting curly braces anyway in this case is good coding practice.

The following code sets a variable c equal to the greater of two variables a and b, or 0 if a and b are equal.

&lt;source lang="c"&gt;
 if (a &gt; b) {
   c = a;
 } else if (b &gt; a) {
   c = b;
 } else {
   c = 0;
 }
&lt;/source&gt;   

Consider this question: why can't you just forget about ''else'' and write the code like:

&lt;source lang="c"&gt;
 if (a &gt; b) {
   c = a;
 }
 
 if (a &lt; b) {
   c = b;
 }
 
 if (a == b) {
   c = 0;
 }
&lt;/source&gt;

There are several answers to this. Most importantly, if your conditionals are not mutually exclusive, ''two'' cases could execute instead of only one. If the code was different and the value of a or b changes somehow (e.g.: you reset the lesser of a and b to 0 after the comparison) during one of the blocks? You could end up with multiple ''if'' statements being invoked, which is not your intent. Also, evaluating ''if'' conditionals takes processor time. If you use ''else'' to handle these situations, in the case above assuming (a &gt; b) is non-zero (true), the program is spared the expense of evaluating additional ''if'' statements.  The bottom line is that it is usually best to insert an ''else'' clause for all cases in which a conditional will not evaluate to non-zero (true).

==== The conditional expression ====

A conditional expression is a way to set values conditionally in a more shorthand fashion than If-Else. The syntax is:

 (/* logical expression goes here */) ? (/* if non-zero (true) */) : (/* if 0 (false) */)

The logical expression is evaluated. If it is non-zero (true), the overall conditional expression evaluates to the expression placed between the ? and :, otherwise, it evaluates to the expression after the :. Therefore, the above example (changing its function slightly such that c is set to b when a and b are equal) becomes:

 c = (a &gt; b) ? a : b;

Conditional expressions can sometimes clarify the intent of the code. Nesting the conditional operator should usually be avoided.  It's best to use conditional expressions only when the expressions for a and b are simple. Also, contrary to a common beginner belief, conditional expressions do not make for faster code. As tempting as it is to assume that fewer lines of code result in faster execution times, there is no such correlation.

=== The Switch-Case statement ===

Say you write a program where the user inputs a number 1-5 (corresponding to student grades, A(represented as 1)-D(4) and F(5)), stores it in a variable '''grade''' and the program responds by printing to the screen the associated letter grade. If you implemented this using If-Else, your code would look something like this:

&lt;source lang="c"&gt;
 if (grade == 1) {
   printf("A\n");
 } else if (grade == 2) {
   printf("B\n");
 } else if /* etc. etc. */
&lt;/source&gt;

Having a long chain of if-else-if-else-if-else can be a pain, both for the programmer and anyone reading the code. Fortunately, there's a solution: the Switch-Case construct, of which the basic syntax is:

&lt;source lang="c"&gt;
 switch (/* integer or enum goes here */) {
 case /* potential value of the aforementioned int or enum */:
   /* code */
 case /* a different potential value */:
   /* different code */
 /* insert additional cases as needed */
 default: 
   /* more code */
 }
&lt;/source&gt;

The Switch-Case construct takes a variable, usually an int or an enum, placed after ''switch'', and compares it to the value following the ''case'' keyword. If the variable is equal to the value specified after ''case'', the construct "activates", or begins executing the code after the case statement. Once the construct has "activated", there will be no further evaluation of ''case''s. 

Switch-Case is syntactically "weird" in that no braces are required for code associated with a ''case''.

'''''Very important''''':
Typically, the last statement for each case is a break statement. This causes program execution to jump to the statement following the closing bracket of the switch statement, which is what one would normally want to happen.  However if the break statement is omitted, program execution continues with the first line of the next case, if any.  This is called a ''fall-through''.  When a programmer desires this action, a comment should be placed at the end of the block of statements indicating the desire to fall through. Otherwise another programmer maintaining the code could consider the omission of the 'break' to be an error, and inadvertently 'correct' the problem.  Here's an example:
 
&lt;source lang="c"&gt;
 switch (someVariable) {
 case 1:
   printf("This code handles case 1\n");
   break;
 case 2:
   printf("This prints when someVariable is 2, along with...\n");
   /* FALL THROUGH */
 case 3:
   printf("This prints when someVariable is either 2 or 3.\n" );
   break;
 }
&lt;/source&gt;

If a ''default'' case is specified, the associated statements are executed if none of the other cases match. A ''default'' case is optional.  Here's a switch statement that corresponds to the sequence of if - else if statements above.

Back to our example above. Here's what it would look like as Switch-Case:

&lt;source lang="c"&gt;
 switch (grade) {
 case 1:
   printf("A\n");
   break;
 case 2:
   printf("B\n");
   break;
 case 3:
   printf("C\n");
   break;
 case 4:
   printf("D\n");
   break;
 default:
   printf("F\n");
   break;
 }
&lt;/source&gt;

A set of statements to execute can be grouped with more than one value of the variable
as in the following example. (the fall-through comment is not necessary here because the intended behavior is obvious)

&lt;source lang="c"&gt;
 switch (something) {
 case 2:
 case 3:
 case 4:
   /* some statements to execute for 2, 3 or 4 */
   break;
 case 1:
 default:
   /* some statements to execute for 1 or other than 2,3,and 4 */
   break;
 } 
&lt;/source&gt;

Switch-Case constructs are particularly useful when used in conjunction with user defined ''enum'' data types. Some compilers are capable of warning about an unhandled enum value, which may be helpful for avoiding bugs.

== Loops ==

Often in computer programming, it is necessary to perform a certain action a certain number of times or until a certain condition is met. It is impractical and tedious to simply type a certain statement or group of statements a large number of times, not to mention that this approach is too inflexible and unintuitive to be counted on to stop when a certain event has happened. As a real-world analogy, someone asks a dishwasher at a restaurant what he did all night. He will respond, "I washed dishes all night long." He is not likely to respond, "I washed a dish, then washed a dish, then washed a dish, then...". The constructs that enable computers to perform certain repetitive tasks are called loops.

=== While loops ===

A while loop is the most basic type of loop.  It will run as long as the condition is non-zero (true). For example, if you try the following, the program will appear to lock up and you will have to manually close the program down. A situation where the conditions for exiting the loop will never become true is called an infinite loop. 

&lt;source lang="c"&gt;
 int a = 1;
 while (42) {
   a = a * 2;
 }
&lt;/source&gt;

Here is another example of a while loop. It prints out all the powers of two less
than 100.

&lt;source lang="c"&gt;
 int a = 1;
 while (a &lt; 100) {
   printf("a is %d \n", a);
   a = a * 2;
 }
&lt;/source&gt;

The flow of all loops can also be controlled by '''break''' and '''continue''' statements.  A break statement will immediately exit the enclosing loop.  A continue statement will skip the remainder of the block and start at the controlling conditional statement again.  For example:

&lt;source lang="c"&gt;
 int a = 1;
 while (42) { // loops until the break statement in the loop is executed
   printf("a is %d ", a);
   a = a * 2;
   if (a &gt; 100) {
     break;
   } else if (a == 64) {
     continue;  // Immediately restarts at while, skips next step
   }
   printf("a is not 64\n");
 }
&lt;/source&gt;

In this example, the computer prints the value of a as usual, and prints a notice that a is not 64 (unless it was skipped by the continue statement).

Similar to If above, braces for the block of code associated with a While loop can be omitted if the code consists of only one statement, for example:

&lt;source lang="c"&gt;
 int a = 1;
 while (a &lt; 100)
   a = a * 2;
&lt;/source&gt;

This will merely increase a until a is not less than 100.

When the computer reaches the end of the while loop, it always goes back to the while statement at the top of the loop, where it re-evaluates the controlling condition.
If that condition is "true" at that instant -- even if it was temporarily 0 for a few statements inside the loop -- then the computer begins executing the statements inside the loop again; otherwise the computer exits the loop.
The computer does not "continuously check" the controlling condition of a while loop during the execution of that loop.
It only "peeks" at the controlling condition each time it reaches the &lt;code&gt;while&lt;/code&gt; at the top of the loop.

It is very important to note, once the controlling condition of a While loop becomes 0 (false), the loop will not terminate until the block of code is finished and it is time to reevaluate the conditional. If you need to terminate a While loop immediately upon reaching a certain condition, consider using '''break'''.

A common idiom is to write:

&lt;source lang="c"&gt;
 int i = 5;
 while (i--) {
   printf("java and c# can't do this\n");
 }
&lt;/source&gt;

This executes the code in the while loop 5 times, with i having values that range from 4 down to 0 (inside the loop). Conveniently, these are the values needed to access every item of an array containing 5 elements.

=== For loops ===

For loops generally look something like this:

 for (''initialization''; ''test''; ''increment'') {
   /* code */
 }

The ''initialization'' statement is executed exactly once - before the first evaluation of the ''test'' condition.  Typically, it is used to assign an initial value to some variable, although this is not strictly necessary. The ''initialization'' statement can also be used to declare and initialize variables used in the loop.

The ''test'' expression is evaluated each time before the code in the ''for'' loop executes. If this expression evaluates as 0 (false) when it is checked (i.e. if the expression is not true), the loop is not (re)entered and execution continues normally at the code immediately following the FOR-loop.  If the expression is non-zero (true), the code within the braces of the loop is executed. 

After each iteration of the loop, the ''increment'' statement is executed. This often is used to increment the loop index for the loop, the variable initialized in the initialization expression and tested in the test expression.  Following this statement execution, control returns to the top of the loop, where the ''test'' action occurs. If a ''continue'' statement is executed within the ''for'' loop, the increment statement would be the next one executed. 

Each of these parts of the for statement is optional and may be omitted.  Because of the free-form nature of the for statement, some fairly fancy things can be done with it. Often a for loop is used to loop through items in an array, processing each item at a time. 
 
&lt;source lang="c"&gt;
 int myArray[12];
 int ix;
 for (ix = 0; ix &lt; 12; ix++) {
   myArray[ix] = 5 * ix + 3;
 }
&lt;/source&gt;

The above for loop initializes each of the 12 elements of myArray.
The loop index can start from any value. In the following case it starts from 1.

&lt;source lang="c"&gt;
 for (ix = 1; ix &lt;= 10; ix++) {
   printf("%d ", ix);
 }
&lt;/source&gt;

which will print
 '''1 2 3 4 5 6 7 8 9 10 '''

You will most often use loop indexes that start from 0, since arrays are indexed at zero, but you will sometimes use other values to initialize a loop index as well.

The ''increment'' action can do other things, such as ''decrement''.  So this kind of loop is common:

&lt;source lang="c"&gt;
 for (i = 5; i &gt; 0; i--) {
   printf("%d ", i);
 }
&lt;/source&gt;

which yields
 '''5 4 3 2 1 '''

Here's an example where the test condition is simply a variable. If the variable
has a value of 0 or NULL, the loop exits, otherwise the statements in the body of
the loop are executed.
 
&lt;source lang="c"&gt;
 for (t = list_head; t; t = NextItem(t)) {
   /* body of loop */
 }
&lt;/source&gt;

A WHILE loop can be used to do the same thing as a FOR loop, however a FOR loop is a more condensed way to perform a set number of repetitions since all of the necessary information is in a one line statement.

A FOR loop can also be given no conditions, for example:

&lt;source lang="c"&gt;
 for (;;) {
   /* block of statements */
 }
&lt;/source&gt;

This is called an infinite loop since it will loop forever unless there is a break statement within the statements of the for loop. The empty test condition effectively evaluates as true.

It is also common to use the comma operator in for loops to execute multiple statements. 
 
&lt;source lang="c"&gt;
 int i, j, n = 10;
 for (i = 0, j = 0; i &lt;= n; i++, j += 2) {
   printf("i = %d , j = %d \n", i, j);
 }
&lt;/source&gt;


Special care should be taken when designing or refactoring the conditional part, especially whether using &lt; or &lt;= , whether start and stop should be corrected by 1, and in case of prefix- and postfix-notations. ( On a 100 yards promenade with a tree every 10 yards there are 11 trees. )

&lt;source lang="c"&gt;
 int i, n = 10;
 for (i = 0; i &lt; n; i++)
   printf("%d ", i); // processed n times =&gt; 0 1 2 3 ... (n-1)
 printf("\n");
 for (i = 0; i &lt;= n; i++)
   printf("%d ", i); // processed (n+1) times =&gt; 0 1 2 3 ... n 
 printf("\n");
 for (i = n; i--;)
   printf("%d ", i); // processed n times =&gt; (n-1) ...3 2 1 0 
 printf("\n");
 for (i = n; --i;)
   printf("%d ", i); // processed (n-1) times =&gt; (n-1) ...4 3 2 1 
 printf("\n");
&lt;/source&gt;

=== Do-While loops ===

A DO-WHILE loop is a post-check while loop, which means that it checks the condition after each run.  As a result, even if the condition is zero (false), it will run at least once.  It follows the form of:

&lt;source lang="c"&gt;
 do {
   /* do stuff */
 } while (condition);
&lt;/source&gt;

Note the terminating semicolon.  This is required for correct syntax.  Since this is also a type of while loop,  '''break''' and '''continue''' statements within the loop function accordingly. A '''continue''' statement causes a jump to the test of the condition and a ''break'' statement exits the loop.

It is worth noting that Do-While and While are functionally almost identical, with one important difference: Do-While loops are always guaranteed to execute at least once, but While loops will not execute at all if their condition is 0 (false) on the first evaluation.

== One last thing: goto ==

'''goto''' is a very simple and traditional control mechanism. It is a statement used to immediately and unconditionally jump to another line of code. To use goto, you must place a label at a point in your program. A label consists of a name followed by a colon (:) on a line by itself. Then, you can type "goto ''label'';" at the desired point in your program. The code will then continue executing beginning with ''label''. This looks like:

&lt;source lang="c"&gt;
 MyLabel:
   /* some code */
   goto MyLabel;
&lt;/source&gt;

The ability to transfer the flow of control enabled by gotos is so powerful that, in addition to the simple if, all other control constructs can be written using gotos instead. Here, we can let "S" and "T" be any arbitrary statements:

&lt;source lang="c"&gt;
 if (''cond'') {
   S;
 } else {
   T;
 }
 /* ... */
&lt;/source&gt;

The same statement could be accomplished using two gotos and two labels:

&lt;source lang="c"&gt;
 if (''cond'') goto Label1;
   T;
   goto Label2;
 Label1:
   S;
 Label2:
   /* ... */
&lt;/source&gt;

Here, the first goto is conditional on the value of "cond". The second goto is unconditional. We can perform the same translation on a loop:

&lt;source lang="c"&gt;
 while (''cond1'') {
   S;
   if (''cond2'')
     break;
   T;
 }
 /* ... */
&lt;/source&gt;

Which can be written as:

&lt;source lang="c"&gt;
 Start:
   if (!''cond1'') goto End;
   S;
   if (''cond2'') goto End;
   T;
   goto Start;
 End:
   /* ... */
&lt;/source&gt;

As these cases demonstrate, often the structure of what your program is doing can usually be expressed without using gotos. Undisciplined use of gotos can create unreadable, unmaintainable code when more idiomatic alternatives (such as if-elses, or for loops) can better express your structure. Theoretically, the goto construct does not ever ''have'' to be used, but there are cases when it can increase readability, avoid code duplication, or make control variables unnecessary. You should consider first mastering the idiomatic solutions, and use goto only when necessary.  Keep in mind that many, if not most, C style guidelines ''strictly forbid'' use of '''goto''', with the  only common exceptions being the following examples.

One use of goto is to break out of a deeply nested loop. Since '''break''' will not work (it can only escape one loop), '''goto''' can be used to jump completely outside the loop. Breaking outside of deeply nested loops without the use of the goto is always possible, but often involves the creation and testing of extra variables that may make the resulting code far less readable than it would be with '''goto'''. The use of '''goto''' makes it easy to undo actions in an orderly fashion, typically to avoid failing to free memory that had been allocated.

Another accepted use is the creation of a state machine. This is a fairly advanced topic though, and not commonly needed.

== Examples ==
&lt;source lang="c"&gt;

#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
	int years;

	printf("Enter your age in years : ");
	fflush(stdout);
	errno = 0;
	if (scanf("%d", &amp;years) != 1 || errno)
		return EXIT_FAILURE;
	printf("Your age in days is %d\n", years * 365);
	return 0;
}

&lt;/source&gt;

== References ==
{{reflist}}

[[de:C-Programmierung: Kontrollstrukturen]]
[[et:Programmeerimiskeel C/Keelestruktuurid]]
[[fr:Programmation C/Tests]]
[[pl:C/Instrukcje sterujące]]
[[pt:Programar em C/Controle de fluxo]]
[[fi:C/Ohjausrakenteet]]
{{C Programming/Navigation|Arrays|Procedures and functions}}</text>
      <sha1>bvfuutkcsw3gqzxkr2wii5hs1thnyaz</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Serialization</title>
    <ns>0</ns>
    <id>141601</id>
    <revision>
      <id>3223737</id>
      <parentid>2983871</parentid>
      <timestamp>2017-05-28T18:51:32Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <minor/>
      <comment>Fix navigation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3577" xml:space="preserve">{{C Programming/Navigation|Side effects and sequence points|Coroutines}}

==Serialization==
It is often necessary to send or receive complex data structures to or from another program that may run on a different architecture or may have been designed for different version of the data structures in question. A typical example is a program that saves its state to a file on exit and then reads it back when started.

The 'send' function will typically start by writing a magic identifier and version to the file or network socket and then proceed to write all the data members one by one (i.e. in serial). If variable length arrays are encountered (e.g. strings), it will either write a length followed by the data or it will write the data followed by a special terminator. The format is often XML or binary; in the latter case the htonl() set of macros may come in handy.

The 'receive' function will be nearly identical: it will read all the items one by one. Variable length arrays are either handled by reading the count followed by the data, or by reading the data until the special terminator is reached.

Since these two functions often follow the same pattern as the declaration of the data(structures), it would be nice if they could all be generated from a common definition.

==X-Macros==
{{merge from | C Programming/Preprocessor#X-Macros }}

X-Macros uses the preprocessor to force the compiler to compile the same piece of text more than once. Sometimes a special file (with extension .def) is included multiple times. For example variables.def may look like this :
 INT(value)
 INT(shift)

In this example the C programming will then look like this :
 ...
 #define INT(var) int var;
 #include "variables.def"
 #undef INT
 ...
 printf ("version=1\n");
 #define INT(var) printf (#var "=%d\n", var);
 #include "variables.def"
 #undef INT
 ...

If including a separate file multiple times is undesirable, another macro can be used. For example :
 #define VARIABLES INT(value) \
                   INT(shift)
The &lt;tt&gt;#include&lt;/tt&gt;s can then be replaced with calls to the macro.

Using this method, one can also pass in the name(s) of (an)other macro(s) that can operate on the list of values. For example:
 #define VAR_LIST(_) _(value) \
                     _(shift)
 ...
 #define VAR_INT_DECL(var) int var;
 VAR_LIST(VAR_INT_DECL)
 ...
 printf ("version=1\n");
 #define VAR_INT_PRINTF(var) printf (#var "=%d\n", var);
 VAR_LIST(VAR_INT_PRINTF)
 ...

This does not require the redefinition of macros and can make the code easier to understand and maintain.

X-Macros are also particularly useful for keeping mappings between strings and enumerated types synchronized.

==Serialization with versioning==
Suppose we want to add additional variables to the above example, but we still want the program to be able to read the old version 1 files. Then we would add a version parameter and a default value parameter to the list processing macros:
 #define VAR_LIST(_) _(value,1,0) \
                     _(shift,1,0) \
                     _(mask,2,0xffff)
 ...
 int inputVer;
 #define VAR_INT_DECL(var,varVer,default) int var;
 VAR_LIST(VAR_INT_DECL)
 ...
 scanf ("version=%d", &amp;inputVer);
 #define VAR_INT_SCN(var,varVer,default) if (varVer &lt;= inputVer) scanf (#var "=%d", &amp;var); else var = default;
 VAR_LIST(VAR_INT_SCN)
 ...
 printf ("version=2\n"); /* Always output at highest known version */
 #define VAR_INT_PRT(var,varVer,default) printf (#var "=%d\n", var);
 VAR_LIST(VAR_INT_PRT)
 ...

{{C Programming/Navigation|Side effects and sequence points|Coroutines}}</text>
      <sha1>kgzdqdfg3z3iw7zh618dy5nbgjw3eky</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Simple input and output</title>
    <ns>0</ns>
    <id>2020</id>
    <revision>
      <id>3652094</id>
      <parentid>3651229</parentid>
      <timestamp>2020-01-08T22:12:37Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>Rejected the last 2 text changes (by [[Special:Contributions/94.205.63.23|94.205.63.23]]) and restored revision 3584988 by Tegel</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9904" xml:space="preserve">{{C Programming/Navigation|Variables|Simple math}}

When you take time to consider it, a computer would be pretty useless without some way to talk to the people who use it.  Just like we need information in order to accomplish tasks, so do computers.  And just as we supply information to others so that ''they'' can do tasks, so do computers.

These supplies and returns of information to a computer are called '''input''' and '''output'''.  'Input' is information supplied to a computer or program.  'Output' is information provided by a computer or program.  Frequently, computer programmers will lump the discussion in the more general term ''input/output'' or simply, '''I/O'''.

In C, there are many different ways for a program to communicate with the user.  Amazingly, the most simple methods usually taught to beginning programmers may also be the most powerful. In the [[../Intro exercise/|Hello, World!]] example at the beginning of this text, we were introduced to a Standard Library file &lt;code&gt;stdio.h&lt;/code&gt;, and one of its functions, &lt;code&gt;printf()&lt;/code&gt;. Here we discuss more of the functions that &lt;code&gt;stdio.h&lt;/code&gt; gives us.

== Output using &lt;code&gt;printf()&lt;/code&gt; ==

Recall from the beginning of this text the demonstration program duplicated below:

&lt;syntaxhighlight lang="c"&gt;
#include &lt;stdio.h&gt;

int main(void)
{
     printf("Hello, World!");
     return 0;
}

&lt;/syntaxhighlight&gt;

If you compile and run this program, you will see the sentence below show up on your screen:


{| cellspacing=3
|- valign="top"
|bgcolor=lightgrey|
   '''Hello, World!'''
|}

This amazing accomplishment was achieved by using the ''function'' &lt;code&gt;printf()&lt;/code&gt;. A function is like a "black box" that does something for you without exposing the internals inside. We can write functions ourselves in C, but we will cover that later.

You have seen that to use &lt;code&gt;printf()&lt;/code&gt; one puts text, surrounded by quotes, in between the parentheses. We call the text surrounded by quotes a ''literal string'' (or just a ''string''), and we call that string an ''argument'' to printf.

As a note of explanation, it is sometimes convenient to include the open and closing parentheses after a function name to remind us that it is, indeed, a function. However usually when the name of the function we are talking about is understood, it is not necessary.

As you can see in the example above, using &lt;code&gt;printf()&lt;/code&gt; can be as simple as typing in some text, surrounded by double quotes (note that these are double quotes and not two single quotes). So, for example, you can print any string by placing it as an argument to the &lt;code&gt;printf()&lt;/code&gt; function:


{| cellspacing=3
|- valign="top"
|bgcolor=lightgrey|
   printf("This sentence will print out exactly as you see it...");
|}

And once it is contained in a proper &lt;code&gt;main()&lt;/code&gt; function, it will show:


{| cellspacing=3
|- valign="top"
|bgcolor=lightgrey|
   '''This sentence will print out exactly as you see it...'''
|}

=== Printing numbers and escape sequences ===

==== Placeholder codes ====
The &lt;code&gt;printf()&lt;/code&gt; function is a powerful function, and is probably the most-used function in C programs. 

For example, let us look at a problem. Say we want to calculate: 19 + 31. Let's use C to get the answer.

We start writing

&lt;syntaxhighlight lang="c"&gt;
#include "stdio.h" // this is important, since printf
                   // can't be used without this header

int main(void)
{
    printf("19+31 is");
&lt;/syntaxhighlight&gt;

But here we are stuck! &lt;code&gt;printf()&lt;/code&gt; only prints strings! Thankfully, printf has methods for printing numbers. What we do is put a ''placeholder'' format code in the string. We write:

&lt;syntaxhighlight lang="c"&gt;
    printf("19+31 is '''%d'''", 19+31);
&lt;/syntaxhighlight&gt;

The placeholder &lt;code&gt;%d&lt;/code&gt; literally "holds the place" for the actual number that is the result of adding 19 to 31. 

These placeholders are called '''format specifiers'''. Many other format specifiers work with &lt;code&gt;printf()&lt;/code&gt;. If we have a floating-point number, we can use &lt;code&gt;%f&lt;/code&gt; to print out a floating-point number, decimal point and all. Other format specifiers are:

* &lt;code&gt;'''%d'''&lt;/code&gt;  - int      (same as %i)
* &lt;code&gt;'''%ld'''&lt;/code&gt; - long int (same as %li)
* &lt;code&gt;'''%f'''&lt;/code&gt;  - float
* &lt;code&gt;'''%lf'''&lt;/code&gt; - double&lt;ref&gt;Actually &lt;code&gt;%f&lt;/code&gt; prints &lt;code&gt;double&lt;/code&gt;s as well, but the use of &lt;code&gt;%f&lt;/code&gt; for input is different. For more details, see the [[w:C data types|Wikipedia article on C data types]].&lt;/ref&gt;
* &lt;code&gt;'''%c'''&lt;/code&gt;  - char
* &lt;code&gt;'''%s'''&lt;/code&gt;  - string
* &lt;code&gt;'''%x'''&lt;/code&gt;  - hexadecimal

A complete listing of all the format specifiers for &lt;code&gt;printf()&lt;/code&gt; is [[w:printf format string|on Wikipedia]].

==== Tabs and newlines ====
What if, we want to achieve some output that will look like:
    '''1905 '''
   '''312 +'''
   '''-----'''

&lt;code&gt;printf()&lt;/code&gt; will not put line breaks in at the end of each statement: we must do this ourselves. But how?

What we can do is use the newline ''escape character''. An escape character is a special character that we can write but will do something special onscreen, such as make a beep, write a tab, and so on. To write a newline we write &lt;code&gt;\n&lt;/code&gt;. All escape characters start with a backslash.

So to achieve the output above, we write

&lt;syntaxhighlight lang="c"&gt;
    printf(" 1905\n312 +\n-----\n");
&lt;/syntaxhighlight&gt;

or to be a bit clearer, we can break this long printf statement over several lines. So our program will be

&lt;syntaxhighlight lang="c"&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    printf(" 1905\n");
    printf("312 +\n");
    printf("-----\n");
    printf("%d", 1905+312);
    return 0;
}
&lt;/syntaxhighlight&gt;

There are [[C Programming/Strings#backslash escapes | other escape characters]] we can use. Another common one is to use &lt;code&gt;\t&lt;/code&gt; to write a tab. You can use &lt;code&gt;\a&lt;/code&gt; to ring the computer's bell, but you should not use this very much in your programs, as excessive use of sound is not very friendly to the user.

== Other output methods ==

=== &lt;code&gt;puts()&lt;/code&gt; ===
The &lt;code&gt;puts()&lt;/code&gt; function is a very simple way to send a string to the screen when you have no placeholders or variables to be concerned about.  It works very much like the &lt;code&gt;printf()&lt;/code&gt; function we saw in the "Hello, World!" example:

&lt;syntaxhighlight lang="c"&gt;
    puts("Print this string.");
&lt;/syntaxhighlight&gt;
will print to the screen:

   Print this string.

followed by the newline character (as discussed above).  (The &lt;code&gt;puts&lt;/code&gt; function appends a newline character to its output.)

== Input using &lt;code&gt;scanf()&lt;/code&gt; ==

The &lt;code&gt;scanf()&lt;/code&gt; function is the input method equivalent to the &lt;code&gt;printf()&lt;/code&gt; output function - simple yet powerful.  In its simplest invocation, the scanf ''format string'' holds a single ''placeholder'' representing the type of value that will be entered by the user.  These placeholders are mostly the same as the &lt;code&gt;printf()&lt;/code&gt; function - &lt;code&gt;%d&lt;/code&gt; for integers, &lt;code&gt;%f&lt;/code&gt; for floats, and &lt;code&gt;%lf&lt;/code&gt; for doubles.

There is, however, one variation to &lt;code&gt;scanf()&lt;/code&gt; as compared to &lt;code&gt;printf()&lt;/code&gt;.  The &lt;code&gt;scanf()&lt;/code&gt; function requires the memory address of the variable to which you want to save the input value.  While ''pointers'' (variables storing memory addresses) can be used here, this is a concept that won't be approached until later in the text.  Instead, the simple technique is to use the ''address-of'' operator, '''&amp;'''. For now it may be best to consider this "magic" before we discuss [[w:Pointer (computer programming)|pointers]].  

A typical application might be like this:

&lt;syntaxhighlight lang="c"&gt;
#include "stdio.h"

int main(void)
{
    int a;

    printf("Please input an integer value: ");
    scanf("%d", &amp;a);
    printf("You entered: %d\n", a);

    return 0;
}
&lt;/syntaxhighlight&gt;

If you were to describe the effect of the &lt;code&gt;scanf()&lt;/code&gt; function call above, it might read as: "Read in an integer from the user and store it at the address of variable ''a'' ".

If you are trying to input a ''string'' using ''scanf'', you should '''not''' include the &amp; operator. The code below will produce a runtime error and the program will likely crash.

&lt;syntaxhighlight lang="c"&gt;
    scanf("%s", &amp;a);
&lt;/syntaxhighlight&gt;

The correct usage would be:

&lt;syntaxhighlight lang="c"&gt;
    scanf("%s", a);
&lt;/syntaxhighlight&gt;

This is because, whenever you use a format specifier for a string (&lt;code&gt;%s&lt;/code&gt;), the variable that you use to store the value will be an array and, the array names (in this case - a) themselves point out to their base address and hence, the '''address of''' operator is not required.

(Although, this is vulnerable to [[w:Buffer overflow|Buffer overflow]]. &lt;code&gt;fgets()&lt;/code&gt; is preferred to &lt;code&gt;scanf()&lt;/code&gt;).

'''Note on inputs''':  When data is typed at a keyboard, the information does not go straight to the program that is running.  It is first stored in what is known as a '''buffer''' - a small amount of memory reserved for the input source.  Sometimes there will be data left in the buffer when the program wants to read from the input source, and the &lt;code&gt;scanf()&lt;/code&gt; function will read this data instead of waiting for the user to type something. Some may suggest you use the function &lt;code&gt;fflush(stdin)&lt;/code&gt;, which may work as desired on some computers, but isn't considered good practice, as you will see later. Doing this has the downfall that if you take your code to a different computer with a different compiler, your code may not work properly.

== References ==
{{reflist}}

{{C Programming/Navigation|Variables|Simple math}}

[[et:Programmeerimiskeel C/IO]]
[[pl:C/Podstawowe procedury wejścia i wyjścia]]
[[pt:Programar em C/Entrada e saída simples]]

{{BookCat}}</text>
      <sha1>cilyn8l0jrzc0al3d8nq5daaqjkjbvj</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Standard libraries</title>
    <ns>0</ns>
    <id>228437</id>
    <revision>
      <id>3400441</id>
      <parentid>3400430</parentid>
      <timestamp>2018-04-04T16:09:40Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13630" xml:space="preserve">{{C Programming/Navigation|Procedures and functions|Beginning exercises}}

The '''C standard library''' is a standardized collection of {{w|header file}}s and library routines used to implement common operations, such as input/output and character string handling. Unlike other languages (such as COBOL, Fortran, and PL/I) C does not include builtin keywords for these tasks, so nearly all C programs rely on the standard library to operate.

== History ==
The C programming language previously did not provide any elementary functions, such as I/O operations. Over time, user communities of C shared ideas and implementations to provide those functions. These ideas became common, and were eventually incorporated into the definition of the standardized C programming language in 1989. These are now called the '''C standard libraries'''.

Both Unix and C were created at AT&amp;T's Bell Laboratories in the late 1960s and early 1970s. During the 1970s the C programming language became increasingly popular, with many universities and organizations beginning to create their own variations of the language for their own projects. By the start of the 1980s compatibility problems between the various C implementations became apparent. In 1983 the American National Standards Institute (ANSI) formed a committee to establish a standard specification of C known as "ANSI C". This work culminated in the creation of the so-called '''C89''' standard in 1989. Part of the resulting standard was a set of software libraries called the '''ANSI C standard library'''.

Later revisions of the C standard have added several new required header files to the library. Support for these new extensions varies between implementations.

The headers '''&lt;iso646.h&gt;''', '''&lt;wchar.h&gt;''', and '''&lt;wctype.h&gt;''' were added with Normative Addendum 1 (hereafter abbreviated as '''NA1'''), an addition to the C Standard ratified in 1995.

The headers '''&lt;complex.h&gt;''', '''&lt;fenv.h&gt;''', '''&lt;inttypes.h&gt;''', '''&lt;stdbool.h&gt;''', '''&lt;stdint.h&gt;''', and '''&lt;tgmath.h&gt;''' were added with '''C99''', a revision to the C Standard published in 1999.

{{NOTE|The [[C++]] programming language includes the functions of the ANSI C 89 standard library, but has made several modifications, such as placing all identifiers into the &lt;code&gt;std&lt;/code&gt; namespace and changing the names of the header files from &lt;tt&gt;&lt;xxx.h&gt;&lt;/tt&gt; to &lt;tt&gt;&lt;cxxx&gt;&lt;/tt&gt; (however, the C-style names are still available, although deprecated).}}

== Design ==
The declaration of each function is kept in a header file, while the actual implementation of functions are separated into a library file. The naming and scope of headers have become common but the organization of libraries still remains diverse. The standard library is usually shipped along with a compiler. Since C compilers often provide extra functions that are not specified in ANSI C, a standard library with a particular compiler is mostly incompatible with standard libraries of other compilers.


Much of the C standard library has been shown to have been well-designed.  A few parts, with the benefit of hindsight, are regarded as mistakes.  The string input functions &lt;code&gt;gets()&lt;/code&gt; (and the use of &lt;code&gt;scanf()&lt;/code&gt; to read string input) are the source of many buffer overflows, and most programming guides recommend avoiding this usage.  Another oddity is &lt;code&gt;strtok()&lt;/code&gt;, a function that is designed as a primitive [[w:lexical analysis|lexical analyser]] but is highly "fragile" and difficult to use.

== ANSI Standard ==
The ANSI C standard library consists of 24 C header files which can be included into a programmer's project with a single directive. Each header file contains one or more function declarations, data type definitions and macros. The contents of these header files follows.

In comparison to some other languages (for example Java) the standard library is minuscule.  The library provides a basic set of mathematical functions, string manipulation, type conversions, and file and console-based I/O.  It does not include a standard set of "container types" like the C++ Standard Template Library, let alone the complete graphical user interface (GUI) toolkits, networking tools, and profusion of other functions that Java provides as standard.  The main advantage of the small standard library is that providing a working ANSI C environment is much easier than it is with other languages, and consequently porting C to a new platform is relatively easy.  

Many other libraries have been developed to supply equivalent functions to that provided by other languages in their standard library.  For instance, the GNOME desktop environment project has developed the GTK+ graphics toolkit and GLib, a library of container data structures, and there are many other well-known examples.  The variety of libraries available has meant that some superior toolkits have proven themselves through history.  The considerable downside is that they often do not work particularly well together, programmers are often familiar with different sets of libraries, and a different set of them may be available on any particular platform.

=== ANSI C library header files ===

{| class="wikitable"
|-
|''' [[w:Assert.h|&lt;assert.h&gt;]]''' || Contains the assert macro, used to assist with detecting logical errors and other types of bug in debugging versions of a program.
|-
|''' [[w:Complex.h|&lt;complex.h&gt;]]''' || A set of functions for manipulating complex numbers. (New with '''C99''')
|-
|''' [[w:Ctype.h|&lt;ctype.h&gt;]]''' || This header file contains functions used to classify characters by their types or to convert between upper and lower case in a way that is independent of the used character set (typically ASCII or one of its extensions, although implementations utilizing EBCDIC are also known).
|-
|''' [[w:Errno.h|&lt;errno.h&gt;]]''' || For testing error codes reported by library functions.
|-
|''' [[w:Fenv.h|&lt;fenv.h&gt;]]''' || For controlling floating-point environment. (New with '''C99''')
|-
|''' [[w:Float.h|&lt;float.h&gt;]]''' || Contains defined constants specifying the implementation-specific properties of the floating-point library, such as the minimum difference between two different floating-point numbers (_EPSILON), the maximum number of digits of accuracy (_DIG) and the range of numbers which can be represented (_MIN, _MAX).
|-
|''' [[w:Inttypes.h|&lt;inttypes.h&gt;]]''' || For precise conversion between integer types. (New with '''C99''')
|-
|''' [[w:Iso646.h|&lt;iso646.h&gt;]]''' || For programming in ISO 646 variant character sets. (New with '''NA1''')
|-
|''' [[w:Limits.h|&lt;limits.h&gt;]]''' || Contains defined constants specifying the implementation-specific properties of the integer types, such as the range of numbers which can be represented (_MIN, _MAX).
|-
|''' [[w:Locale.h|&lt;locale.h&gt;]]''' || For setlocale() and related constants. This is used to choose an appropriate locale.
|-
|''' [[w:Math.h|&lt;math.h&gt;]]''' || For computing common mathematical functions
-- see [[../Further math/]] or [[C++ Programming/Code/Standard C Library/Math]] for details.
|-
|''' [[w:Setjmp.h|&lt;setjmp.h&gt;]]''' || Declares the macros setjmp/longjmp|setjmp and longjmp, which are used for non-local exits
|-
|''' [[w:Signal.h|&lt;signal.h&gt;]]''' || For controlling various exceptional conditions
|-
|''' [[w:Stdarg.h|&lt;stdarg.h&gt;]]''' || For accessing a varying number of arguments passed to functions.
|-
|''' [[w:Stdbool.h|&lt;stdbool.h&gt;]]''' || For a boolean data type. (New with '''C99''')
|-
|''' [[w:Stdint.h|&lt;stdint.h&gt;]]''' || For defining various integer types. (New with '''C99''')
|-
|''' [[w:Stddef.h|&lt;stddef.h&gt;]]''' || For defining several useful types and macros.
|-
|''' [[w:Stdio.h|&lt;stdio.h&gt;]]''' || Provides the core input and output capabilities of the C language. This file includes the venerable &lt;code&gt;printf&lt;/code&gt; function.
|-
|''' [[w:Stdlib.h|&lt;stdlib.h&gt;]]''' || For performing a variety of operations, including conversion, pseudo-random numbers, memory allocation, process control, environment, signalling, searching, and sorting.
|-
|''' [[w:String.h|&lt;string.h&gt;]]''' || For manipulating several kinds of strings.
|-
|''' [[w:Tgmath.h|&lt;tgmath.h&gt;]]''' || For type-generic mathematical functions. (New with '''C99''')
|-
|''' [[w:Time.h|&lt;time.h&gt;]]''' || For converting between various time and date formats.
|-
|''' [[w:Wchar.h|&lt;wchar.h&gt;]]''' || For manipulating wide streams and several kinds of strings using wide characters - key to supporting a range of languages. (New with '''NA1''')
|-
|''' [[w:Wctype.h|&lt;wctype.h&gt;]]''' || For classifying wide characters. (New with '''NA1''')
|}

== Common support libraries ==

While not standardized, C programs may depend on a runtime library of routines which contain code the compiler uses at runtime. The code that initializes the process for the operating system, for example, before calling &lt;code&gt;main()&lt;/code&gt;, is implemented in the C Run-Time Library for a given vendor's compiler. The Run-Time Library code might help with other language feature implementations, like handling uncaught exceptions or implementing floating point code.

The C standard library only documents that the specific routines mentioned in this article are available, and how they behave. Because the compiler implementation might depend on these additional implementation-level functions to be available, it is likely the vendor-specific routines are packaged with the C Standard Library in the same module, because they're both likely to be needed by any program built with their toolset.

Though often confused with the C Standard Library because of this packaging, the C Runtime Library is not a standardized part of the language and is vendor-specific.

== Compiler built-in functions ==

Some compilers (for example, [[w:GCC|GCC]]) provide built-in versions of many of the functions in the C standard library; that is, the implementations of the functions are written into the compiled object file, and the program calls the built-in versions instead of the functions in the C library shared object file.  This reduces function call overhead, especially if function calls are replaced with inline variants, and allows other forms of optimization (as the compiler knows the control-flow characteristics of the built-in variants), but may cause confusion when debugging (for example, the built-in versions cannot be replaced with instrumented variants).

== POSIX standard library ==
POSIX, (along with the Single Unix Specification), specifies a number of routines that should be available over and above those in the C standard library proper; these are often implemented alongside the C standard library functions, with varying degrees of closeness. For example, glibc implements functions such as fork within libc.so, but before NPTL was merged into glibc it constituted a separate library with its own linker flag. Often, this POSIX-specified function will be regarded as part of the library; the C library proper may be identified as the ANSI or ISO C library.

The following libraries are recognized by POSIX:

{| class="wikitable"
|-
|'''c'''||
This option shall make available all interfaces referenced in the System Interfaces volume of POSIX.1-2008, with the possible exception of those interfaces listed as residing in &lt;aio.h&gt;, &lt;arpa/inet.h&gt;, &lt;complex.h&gt;, &lt;fenv.h&gt;, &lt;math.h&gt;, &lt;mqueue.h&gt;, &lt;netdb.h&gt;, &lt;net/if.h&gt;, &lt;netinet/in.h&gt;, &lt;pthread.h&gt;, &lt;sched.h&gt;, &lt;semaphore.h&gt;, &lt;spawn.h&gt;, &lt;sys/socket.h&gt;, pthread_kill(), and pthread_sigmask() in &lt;signal.h&gt;, &lt;trace.h&gt;, interfaces marked as optional in &lt;sys/mman.h&gt;, interfaces marked as ADV (Advisory Information) in &lt;fcntl.h&gt;, and interfaces beginning with the prefix clock_ or time_ in &lt;time.h&gt;. This option shall not be required to be present to cause a search of this library.
|-
|'''l'''||
This option shall make available all interfaces required by the C-language output of lex that are not made available through the -l c option. (The flex program, a clone of lex, uses fl instead of l.)
|-
|'''pthread'''||
This option shall make available all interfaces referenced in &lt;pthread.h&gt; and pthread_kill() and pthread_sigmask() referenced in &lt;signal.h&gt;. An implementation may search this library in the absence of this option.
|-
|'''m'''||
This option shall make available all interfaces referenced in &lt;math.h&gt;, &lt;complex.h&gt;, and &lt;fenv.h&gt;. An implementation may search this library in the absence of this option.
|-
|'''rt'''||
This option shall make available all interfaces referenced in &lt;aio.h&gt;, &lt;mqueue.h&gt;, &lt;sched.h&gt;, &lt;semaphore.h&gt;, and &lt;spawn.h&gt;, interfaces marked as optional in &lt;sys/mman.h&gt;, interfaces marked as ADV (Advisory Information) in &lt;fcntl.h&gt;, and interfaces beginning with the prefix clock_ and time_ in &lt;time.h&gt;. An implementation may search this library in the absence of this option.
|-
|'''trace'''||
This option shall make available all interfaces referenced in &lt;trace.h&gt;. An implementation may search this library in the absence of this option.
|-
|'''xnet'''||
This option shall make available all interfaces referenced in &lt;arpa/inet.h&gt;, &lt;netdb.h&gt;, &lt;net/if.h&gt;, &lt;netinet/in.h&gt;, and &lt;sys/socket.h&gt;. An implementation may search this library in the absence of this option.
|-
|'''y'''||
This option shall make available all interfaces required by the C-language output of yacc that are not made available through the -l c option. (Some clones of yacc, including bison and byacc, include the entire library in the generated file, so it is not necessary to use -l y.)
|}

== References ==
{{reflist}}

{{C Programming/Navigation|Procedures and functions|Beginning exercises}}

[[pl:C/Biblioteka standardowa]]</text>
      <sha1>cq00plnclzbif967a5yif0fc515auur</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Standard library reference</title>
    <ns>0</ns>
    <id>149265</id>
    <revision>
      <id>3589986</id>
      <parentid>3589985</parentid>
      <timestamp>2019-10-25T12:29:38Z</timestamp>
      <contributor>
        <username>Ogoorcs</username>
        <id>1722717</id>
      </contributor>
      <minor/>
      <comment>/* stdio.h */ fixed typo</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="24480" xml:space="preserve">== Headers ==

=== ANSI C (C89)/ISO C (C90) ===

{| class="wikitable"
|-
|&lt;tt&gt;[[#assert.h|assert.h]]&lt;/tt&gt; || Verify program assertion.
|-
|&lt;tt&gt;[[#ctype.h|ctype.h]]&lt;/tt&gt; || Character types.
|-
|&lt;tt&gt;[[../errno.h|'''errno.h''']]&lt;/tt&gt; || System error numbers.
|-
|&lt;tt&gt;[[../float.h|'''float.h''']]&lt;/tt&gt; || Floating types.
|-
|&lt;tt&gt;[[../limits.h|'''limits.h''']]&lt;/tt&gt; || Implementation-defined constants.
|-
|&lt;tt&gt;[[#locale.h|locale.h]]&lt;/tt&gt; || Category macros.
|-
|&lt;tt&gt;[[#math.h|math.h]]&lt;/tt&gt; || Mathematical declarations.
|-
|&lt;tt&gt;[[#setjmp.h|setjmp.h]]&lt;/tt&gt; || Stack environment declarations.
|-
|&lt;tt&gt;[[#signal.h|signal.h]]&lt;/tt&gt; || Signals.
|-
|&lt;tt&gt;[[#stdarg.h|stdarg.h]]&lt;/tt&gt; || Handle variable argument list.
|-
|&lt;tt&gt;[[#stddef.h|stddef.h]]&lt;/tt&gt; || Standard type definitions.
|-
|&lt;tt&gt;[[#stdio.h|stdio.h]]&lt;/tt&gt; || Standard buffered input/output.
|-
|&lt;tt&gt;[[#stdlib.h|stdlib.h]]&lt;/tt&gt; || Standard library definitions.
|-
|&lt;tt&gt;[[#string.h|string.h]]&lt;/tt&gt; || String operations.
|-
|&lt;tt&gt;[[#time.h|time.h]]&lt;/tt&gt; || Time types.
|}

=== ISO C (C94/C95), Amendment 1 (AMD1) ===

Very old compilers may not include some or all of these headers

{| class="wikitable"
|-
|&lt;tt&gt;[[../iso646.h|'''iso646.h''']]&lt;/tt&gt; || Alternative spellings.
|-
|&lt;tt&gt;[[#wchar.h|wchar.h]]&lt;/tt&gt; || Wide-character handling.
|-
|&lt;tt&gt;[[#wctype.h|wctype.h]]&lt;/tt&gt; || Wide-character classification and mapping utilities.
|}

=== ISO C (C99) ===

These are supported only in newer compilers

{| class="wikitable"
|-
|&lt;tt&gt;[[#complex.h|complex.h]]&lt;/tt&gt; || Complex arithmetic.
|-
|&lt;tt&gt;[[#fenv.h|fenv.h]]&lt;/tt&gt; || Floating-point environment.
|-
|&lt;tt&gt;[[#inttypes.h|inttypes.h]]&lt;/tt&gt; || Fixed size integer types.
|-
|&lt;tt&gt;[[../stdbool.h|'''stdbool.h''']]&lt;/tt&gt; || Boolean type and values.
|-
|&lt;tt&gt;[[../stdint.h|'''stdint.h''']]&lt;/tt&gt; || Integer types.
|-
|&lt;tt&gt;[[../tgmath.h|'''tgmath.h''']]&lt;/tt&gt; || Type-generic macros.
|}

=== ISO C (C11) ===

These are supported only in newer compilers

{| class="wikitable"
|-
|&lt;tt&gt;[[../stdalign.h|'''stdalign.h''']]&lt;/tt&gt; || Alignment keywords and macros.
|-
|&lt;tt&gt;[[#stdatomic.h|stdatomic.h]]&lt;/tt&gt; || Atomic operations on data shared between threads.
|-
|&lt;tt&gt;[[../stdnoreturn.h|'''stdnoreturn.h''']]&lt;/tt&gt; || _Noreturn function specifier macro.
|-
|&lt;tt&gt;[[#threads.h|threads.h]]&lt;/tt&gt; || Support for multiple threads of execution.
|-
|&lt;tt&gt;[[#uchar.h|uchar.h]]&lt;/tt&gt; || Types and functions for manipulating Unicode characters.
|}

== Table of functions ==

This table also includes function-like macros

=== [[C Programming/assert.h|assert.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/assert.h/Function reference#assert|assert]]&lt;/tt&gt;
|}

=== [[C Programming/complex.h|complex.h]] ===

{|
|
* &lt;tt&gt;[[../complex.h/Function reference#cacos|cacos]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cacos|cacosf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cacos|cacosl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#casin|casin]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#casin|casinf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#casin|casinl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#catan|catan]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#catan|catanf]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#catan|catanl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ccos|ccos]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ccos|ccosf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ccos|ccosl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csin|csin]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csin|csinf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csin|csinl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ctan|ctan]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#ctan|ctanf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ctan|ctanl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cacosh|cacosh]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cacosh|cacoshf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cacosh|cacoshl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#casinh|casinh]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#casinh|casinhf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#casinh|casinhl]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#catanh|catanh]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#catanh|catanhf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#catanh|catanhl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ccosh|ccosh]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ccosh|ccoshf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ccosh|ccoshl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csinh|csinh]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csinh|csinhf]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#csinh|csinhl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ctanh|ctanh]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ctanh|ctanhf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#ctanh|ctanhl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cexp|cexp]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cexp|cexpf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cexp|cexpl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#clog|clog]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#clog|clogf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#clog|clogl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cabs|cabs]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cabs|cabsf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cabs|cabsl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cpow|cpow]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cpow|cpowf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cpow|cpowl]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#csqrt|csqrt]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csqrt|csqrtf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#csqrt|csqrtl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#carg|carg]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#carg|cargf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#carg|cargl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cimag|cimag]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cimag|cimagf]]&lt;/tt&gt;
|
* &lt;tt&gt;[[../complex.h/Function reference#cimag|cimagl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#conj|conj]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#conj|conjf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#conj|conjl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cproj|cproj]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cproj|cprojf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#cproj|cprojl]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#creal|creal]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[../complex.h/Function reference#creal|crealf]]&lt;/tt&gt;
* &lt;tt&gt;[[../complex.h/Function reference#creal|creall]]&lt;/tt&gt;
|}

=== [[C Programming/ctype.h|ctype.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isalnum|isalnum]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isalpha|isalpha]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isblank|isblank]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#iscntrl|iscntrl]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isdigit|isdigit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isgraph|isgraph]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#islower|islower]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isprint|isprint]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#ispunct|ispunct]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isspace|isspace]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isupper|isupper]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#isxdigit|isxdigit]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#tolower|tolower]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/ctype.h/Function reference#toupper|toupper]]&lt;/tt&gt;
|}

=== [[C Programming/fenv.h|fenv.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/fenv.h/Function reference#feclearexcept|feclearexcept]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/Function reference#fegetenv|fegetenv]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/fegetexceptflag|fegetexceptflag]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/fegetround|fegetround]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/fenv.h/feholdexcept|feholdexcept]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/feraiseexcept|feraiseexcept]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/Function reference#fesetenv|fesetenv]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/fesetexceptflag|fesetexceptflag]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/fenv.h/fesetround|fesetround]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/fetestexcept|fetestexcept]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/fenv.h/feupdateenv|feupdateenv]]&lt;/tt&gt;
|}

=== [[C Programming/inttypes.h|inttypes.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/inttypes.h/imaxabs|imaxabs]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/inttypes.h/imaxdiv|imaxdiv]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/inttypes.h/strtoimax|strtoimax]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/inttypes.h/strtoumax|strtoumax]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/inttypes.h/wcstoimax|wcstoimax]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/inttypes.h/wcstoumax|wcstoumax]]&lt;/tt&gt;
|}

=== [[C Programming/locale.h|locale.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/locale.h/localeconv|localeconv]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/locale.h/setlocale|setlocale]]&lt;/tt&gt;
|}

=== [[C Programming/math.h|math.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/math.h/fpclassify|fpclassify]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/isfinite|isfinite]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/isgreater|isgreater]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/isgreaterequal|isgreaterequal]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/math.h/isinf|isinf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/isless|isless]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/islessequal|islessequal]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/islessgreater|islessgreater]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/math.h/isnan|isnan]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/isnormal|isnormal]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/isunordered|isunordered]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/math.h/signbit|signbit]]&lt;/tt&gt;
|}

=== [[C Programming/setjmp.h|setjmp.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/setjmp.h/longjmp|longjmp]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/setjmp.h/setjmp|setjmp]]&lt;/tt&gt;
|}

=== [[C Programming/signal.h|signal.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/signal.h/raise|raise]]&lt;/tt&gt;
|}

=== [[C Programming/stdarg.h|stdarg.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/stdarg.h/va arg|va_arg]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdarg.h/va copy|va_copy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdarg.h/va end|va_end]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdarg.h/va start|va_start]]&lt;/tt&gt;
|}

=== [[C Programming/stdatomic.h|stdatomic.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_init|atomic_init]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_thread_fence|atomic_thread_fence]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_signal_fence|atomic_signal_fence]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_is_lock_free|atomic_is_lock_free]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_store|atomic_store]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_store_explicit|atomic_store_explicit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_load|atomic_load]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_load_explicit|atomic_load_explicit]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_exchange|atomic_exchange]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_exchange_explicit|atomic_exchange_explicit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_compare_exchange_strong|atomic_compare_exchange_strong]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_compare_exchange_strong_explicit|atomic_compare_exchange_strong_explicit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_compare_exchange_weak|atomic_compare_exchange_weak]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_compare_exchange_weak_explicit|atomic_compare_exchange_weak_explicit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_fetch|atomic_fetch]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_fetch_key_explicit|atomic_fetch_key_explicit]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_flag_test_and_set|atomic_flag_test_and_set]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_flag_test_and_set_explicit|atomic_flag_test_and_set_explicit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_flag_clear|atomic_flag_clear]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdatomic.h/atomic_flag_clear_explicit|atomic_flag_clear_explicit]]&lt;/tt&gt;
|}

=== [[C Programming/stddef.h|stddef.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/stddef.h/Function reference#offsetof|offsetof]]&lt;/tt&gt;
|}

=== [[C Programming/stdio.h|stdio.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#clearerr|clearerr]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fclose|fclose]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#feof|feof]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fgetc|fgetc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fgetpos|fgetpos]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fgets|fgets]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fopen|fopen]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fprintf|fprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fputs|fputs]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fread|fread]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fscanf|fscanf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fseek|fseek]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fsetpos|fsetpos]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#ftell|ftell]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fwprintf|fwprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#fwrite|fwrite]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#getc|getc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#getchar|getchar]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#gets|gets]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#perror|perror]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#printf|printf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#putc|putc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#putchar|putchar]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#puts|puts]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#remove|remove]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#rename|rename]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#rewind|rewind]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#scanf|scanf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#setbuf|setbuf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#setvbuf|setvbuf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#sprintf|sprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#tmpfile|tmpfile]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#ungetc|ungetc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#vwprintf|vwprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#wprintf|wprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdio.h/Function reference#wscanf|wscanf]]&lt;/tt&gt;
|}

=== [[C Programming/stdlib.h|stdlib.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#abort|abort]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#abs|abs]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#abs|labs]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#atexit|atexit]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#atof|atof]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#atoi|atoi]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/atol|atol]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#bsearch|bsearch]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#div|div]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#div|ldiv]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#exit|exit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/free|free]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdlib.h/getenv|getenv]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#malloc|malloc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#malloc|calloc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#malloc|realloc]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#qsort|qsort]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/rand|rand]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/srand|srand]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#strtod|strtod]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#strtol|strtol]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/strtoul|strtoul]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/stdlib.h/Function reference#system|system]]&lt;/tt&gt;
|}

=== [[C Programming/string.h|string.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/string.h/memchr|memchr]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/memcmp|memcmp]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/memcpy|memcpy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/memmove|memmove]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/Function reference#memset|memset]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcat|strcat]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcat|strncat]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strchr|strchr]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcmp|strcmp]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcmp|strncmp]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/strcoll|strcoll]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcpy|strcpy]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcpy|strncpy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strcspn|strcspn]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strerror|strerror]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strlen|strlen]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/strpbrk|strpbrk]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strrchr|strrchr]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strspn|strspn]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strstr|strstr]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/string.h/Function reference#strtok|strtok]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/Function reference#strxfrm|strxfrm]]&lt;/tt&gt;
|}

=== [[C Programming/threads.h|threads.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/threads.h/call_once|call_once]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/cnd_broadcast|cnd_broadcast]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/cnd_destroy|cnd_destroy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/cnd_init|cnd_init]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/cnd_signal|cnd_signal]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/cnd_timedwait|cnd_timedwait]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/cnd_wait|cnd_wait]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/mtx_destroy|mtx_destroy]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/threads.h/mtx_init|mtx_init]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/mtx_lock|mtx_lock]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/mtx_timedlock|mtx_timedlock]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/mtx_trylock|mtx_trylock]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/mtx_unlock|mtx_unlock]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_create|thrd_create]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_current|thrd_current]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_detach|thrd_detach]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/threads.h/thrd_equal|thrd_equal]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_exit|thrd_exit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_join|thrd_join]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_sleep|thrd_sleep]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/thrd_yield|thrd_yield]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/tss_create|tss_create]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/tss_delete|tss_delete]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/threads.h/tss_get|tss_get]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/threads.h/tss_set|tss_set]]&lt;/tt&gt;
|}

=== [[C Programming/time.h|time.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/time.h/Function reference#asctime|asctime]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/time.h/Function reference#clock|clock]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/time.h/Function reference#ctime|ctime]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/time.h/Function reference#difftime|difftime]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/time.h/Function reference#gmtime|gmtime]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/time.h/Function reference#localtime|localtime]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/time.h/Function reference#mktime|mktime]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/time.h/strftime|strftime]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/time.h/time|time]]&lt;/tt&gt;
|}

=== [[C Programming/uchar.h|uchar.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/uchar.h/mbrtoc16|mbrtoc16]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/uchar.h/c16rtomb|c16rtomb]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/uchar.h/mbrtoc32|mbrtoc32]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/uchar.h/c32rtomb|c32rtomb]]&lt;/tt&gt;
|}

=== [[C Programming/wchar.h|wchar.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/wchar.h/btowc|btowc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/fgetwc|fgetwc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#fgetws|fgetws]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/fputwc|fputwc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/fwide|fwide]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/fwprintf|fwprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/fwscanf|fwscanf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/getwc|getwc]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/wchar.h/getwchar|getwchar]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#mbrlen|mbrlen]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#mbrtowc|mbrtowc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/mbsinit|mbsinit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/mbsrtowcs|mbsrtowcs]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#putwc|putwc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/putwchar|putwchar]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#swprintf|swprintf]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/wchar.h/swscanf|swscanf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/ungetwc|ungetwc]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/vfwprintf|vfwprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/vswprintf|vswprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/vwprintf|vwprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcrtomb|wcrtomb]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#wcscat|wcscat]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcschr|wcschr]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#wcscmp|wcscmp]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcscoll|wcscoll]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#wcscpy|wcscpy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcscspn|wcscspn]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsftime|wcsftime]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcslen|wcslen]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsncat|wcsncat]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/Function reference#wcscmp|wcsncmp]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/wchar.h/wcsncpy|wcsncpy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcspbrk|wcspbrk]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsrchr|wcsrchr]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsrtombs|wcsrtombs]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsspn|wcsspn]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsstr|wcsstr]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcstod|wcstod]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcstok|wcstok]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/wchar.h/wcstol|wcstol]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcstoul|wcstoul]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wcsxfrm|wcsxfrm]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wctob|wctob]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wmemchr|wmemchr]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wmemcmp|wmemcmp]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wmemcpy|wmemcpy]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wmemmove|wmemmove]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/wchar.h/wmemset|wmemset]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wprintf|wprintf]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/wchar.h/wscanf|wscanf]]&lt;/tt&gt;
|}

=== [[C Programming/wctype.h|wctype.h]] ===

{|
|
* &lt;tt&gt;[[C Programming/string.h/iswalnum|iswalnum]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswalpha|iswalpha]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswcntrl|iswcntrl]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswctype|iswctype]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/iswdigit|iswdigit]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswgraph|iswgraph]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswlower|iswlower]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswprint|iswprint]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/iswpunct|iswpunct]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswspace|iswspace]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswupper|iswupper]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/iswxdigit|iswxdigit]]&lt;/tt&gt;
|
* &lt;tt&gt;[[C Programming/string.h/towctrans|towctrans]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/towlower|towlower]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/towupper|towupper]]&lt;/tt&gt;
* &lt;tt&gt;[[C Programming/string.h/wctrans|wctrans]]&lt;/tt&gt;
| valign="top" |
* &lt;tt&gt;[[C Programming/string.h/wctype|wctype]]&lt;/tt&gt;
|}

{{BookCat}}</text>
      <sha1>6erop8rrv6vqjebvm90ih6bscerjzdb</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Statements</title>
    <ns>0</ns>
    <id>22589</id>
    <revision>
      <id>3624277</id>
      <parentid>3624189</parentid>
      <timestamp>2019-12-13T18:12:14Z</timestamp>
      <contributor>
        <ip>2601:8B:C303:7E30:F96D:A600:866C:4CE6</ip>
      </contributor>
      <comment>Removed vandalism</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7644" xml:space="preserve">{{C Programming/Navigation|Code library|C Language Reference}}

A '''statement''' is a command given to the computer that instructs the computer to take a specific action, such as display to the screen, or collect input. A computer program is made up of a series of statements.

&lt;noinclude&gt;__TOC__&lt;/noinclude&gt;

In C, a statement can be any of the following:

== Labeled Statements ==

A statement can be preceded by a label. Three types of labels exist in C.

A simple identifier followed by a colon (&lt;code&gt;:&lt;/code&gt;) is a label. Usually, this label is the target of a &lt;code&gt;goto&lt;/code&gt; statement.

Within &lt;code&gt;switch&lt;/code&gt; statements, &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; labeled statements exist. A statement of the form

&lt;code&gt;case&lt;/code&gt; ''constant-expression'' &lt;code&gt;:&lt;/code&gt; ''statement''

indicates that control will pass to this statement if the value of the control expression of the &lt;code&gt;switch&lt;/code&gt; statement matches the value of the ''constant-expression''. (In this case, the type of the ''constant-expression'' must be an integer or character.) A statement of the form

&lt;code&gt;default&lt;/code&gt; &lt;code&gt;:&lt;/code&gt; ''statement''

indicates that control will pass to this statement if the control expression of the &lt;code&gt;switch&lt;/code&gt; statement does not match any of the ''constant-expressions'' within the &lt;code&gt;switch&lt;/code&gt; statement. If the &lt;code&gt;default&lt;/code&gt; statement is omitted, the control will pass to the statement following the &lt;code&gt;switch&lt;/code&gt; statement. Within a &lt;code&gt;switch&lt;/code&gt; statement, there can be only one &lt;code&gt;default&lt;/code&gt; statement, unless the &lt;code&gt;switch&lt;/code&gt; statement is within another &lt;code&gt;switch&lt;/code&gt; statement.

== Compound Statements ==

A ''compound statement'' is the way C groups multiple statements into a single statement. It consists of multiple statements and declarations within braces (i.e. &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;). In the ANSI C Standard of 1989-1990, a compound statement contained an optional list of declarations followed by an optional list of statements; in more recent revisions of the Standard, declarations and statements can be freely interwoven through the code. The body of a function is also a compound statement by rule.

== Expression Statements ==

An ''expression statement'' consists of an optional expression followed by a semicolon (&lt;code&gt;;&lt;/code&gt;). If the expression is present, the statement may have a value. If no expression is present, the statement is often called the ''null statement''.

The &lt;code&gt;printf&lt;/code&gt; function calls are expressions, so statements such as &lt;code&gt;printf ("Hello World!\n");&lt;/code&gt; are expression statements.

== Selection Statements ==

Three types of selection statements exist in C:

&lt;code&gt;if&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; ''expression'' &lt;code&gt;)&lt;/code&gt; ''statement''

In this type of if-statement, the sub-statement will only be executed iff the expression is non-zero.

&lt;code&gt;if&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; ''expression'' &lt;code&gt;)&lt;/code&gt; ''statement'' &lt;code&gt;else&lt;/code&gt; ''statement''

In this type of if-statement, the first sub-statement will only be executed iff the expression is non-zero; otherwise, the second sub-statement will be executed. Each &lt;code&gt;else&lt;/code&gt; matches up with the closest unmatched &lt;code&gt;if&lt;/code&gt;, so that the following two snippets of code are not equal:

&lt;syntaxhighlight lang=c&gt;
 if (expression)
   if (secondexpression) statement1;
 else
   statement2;

 if (expression)
   {
     if (secondexpression) statement1;
   }
 else
   statement2;
&lt;/syntaxhighlight&gt;

because in the first, the &lt;code&gt;else&lt;/code&gt; statement matches up with the if statement that has &lt;code&gt;secondexpression&lt;/code&gt; for a control, but in the second, the braces force the &lt;code&gt;else&lt;/code&gt; to match up with the if that has &lt;code&gt;expression&lt;/code&gt; for a control.

Switch statements are also a type of selection statement. They have the format

&lt;code&gt;switch&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; ''expression'' &lt;code&gt;)&lt;/code&gt; ''statement''

The expression here is an integer or a character. The statement here is usually compound and it contains case-labeled statements and optionally a default-labeled statement. The compound statement should not have local variables as the jump to an internal label may skip over the initialization of such variables.

== Iteration Statements ==

C has three kinds of iteration statements. The first is a while-statement with the form

&lt;code&gt;while&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; ''expression'' &lt;code&gt;)&lt;/code&gt; ''statement''

The substatement of a while runs repeatedly as long as the control expression evaluates to non-zero at the beginning of each iteration. If the control expression evaluates to zero the first time through, the substatement may not run at all.

The second is a do-while statement of the form

&lt;code&gt;do&lt;/code&gt; ''statement'' &lt;code&gt;while&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; ''expression'' &lt;code&gt;)&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;

This is similar to a while loop, except that the controlling expression is evaluated at the end of the loop instead of the beginning and consequently the sub-statement must execute at least once.

The third type of iteration statement is the for-statement. In ANSI C 1989, it has the form

&lt;code&gt;for&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; ''expression&lt;sub&gt;opt&lt;/sub&gt;'' &lt;code&gt;;&lt;/code&gt; ''expression&lt;sub&gt;opt&lt;/sub&gt;'' &lt;code&gt;;&lt;/code&gt; ''expression&lt;sub&gt;opt&lt;/sub&gt;'' &lt;code&gt;)&lt;/code&gt; ''statement''

In more recent versions of the C standard, a declaration can substitute for the first expression. The ''opt'' subscript indicates that the expression is optional.

The statement

&lt;syntaxhighlight lang=c&gt;
  for (e1; e2; e3)
    s;
&lt;/syntaxhighlight&gt;

is the rough equivalent of

&lt;syntaxhighlight lang=c&gt;
  {
    e1;
    while (e2)
      {
        s;
        e3;
      }
  }
&lt;/syntaxhighlight&gt;

except for the behavior of &lt;code&gt;continue&lt;/code&gt; statements within &lt;code&gt;s&lt;/code&gt;.

The &lt;code&gt;e1&lt;/code&gt; expression represents an initial condition; &lt;code&gt;e2&lt;/code&gt; a control expression; and &lt;code&gt;e3&lt;/code&gt; what to happen on each iteration of the loop. If &lt;code&gt;e2&lt;/code&gt; is missing, the expression is considered to be non-zero on every iteration, and only a &lt;code&gt;break&lt;/code&gt; statement within &lt;code&gt;s&lt;/code&gt; (or a call to a non-returning function such as &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;abort&lt;/code&gt;) will end the loop.

== Jump Statements ==

C has four types of jump statements. The first, the &lt;code&gt;goto&lt;/code&gt; statement, is used sparingly and has the form

&lt;code&gt;goto&lt;/code&gt; ''identifier'' &lt;code&gt;;&lt;/code&gt;

This statement transfers control flow to the statement labeled with the given identifier. The statement must be within the same function as the &lt;code&gt;goto&lt;/code&gt;.

The second, the break statement, with the form

&lt;code&gt;break&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;

is used within iteration statements and &lt;code&gt;switch&lt;/code&gt; statements to pass control flow to the statement following the while, do-while, for, or switch.

The third, the continue statement, with the form

&lt;code&gt;continue&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;

is used within the substatement of iteration statements to transfer control flow to the place just before the end of the substatement. In &lt;code&gt;for&lt;/code&gt; statements the iteration expression (&lt;code&gt;e3&lt;/code&gt; above) will then be executed before the controlling expression (&lt;code&gt;e2&lt;/code&gt; above) is evaluated.

The fourth type of jump statement is the &lt;code&gt;return&lt;/code&gt; statement with the form

&lt;code&gt;return&lt;/code&gt; ''expression&lt;sub&gt;opt&lt;/sub&gt;'' &lt;code&gt;;&lt;/code&gt;

This statement returns from the function. If the function return type is &lt;code&gt;void&lt;/code&gt;, the function may not return a value; otherwise, the expression represents the value to be returned.

{{BookCat}}

{{C Programming/Navigation|Code library|C Language Reference}}</text>
      <sha1>84qa0642u5txyj33j1b0maigtchp174</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Stream IO</title>
    <ns>0</ns>
    <id>23135</id>
    <revision>
      <id>3594093</id>
      <parentid>3594090</parentid>
      <timestamp>2019-11-05T18:38:42Z</timestamp>
      <contributor>
        <ip>2601:8B:C303:7E30:7CF6:AE6C:F0B9:4CD8</ip>
      </contributor>
      <comment>added some details</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="74511" xml:space="preserve">{{C Programming/Navigation|Error handling|Strings}}

==Introduction==
The &lt;code&gt;stdio.h&lt;/code&gt; header declares a broad assortment of functions that perform input and output to files and devices such as the console. It was one of the earliest headers to appear in the C library. It declares more functions than any other standard header and also requires more explanation because of the complex machinery that underlies the functions.

The device-independent model of input and output has seen dramatic improvement over the years and has received little recognition for its success. FORTRAN II was touted as a machine-independent language in the 1960s, yet it was essentially impossible to move a FORTRAN program between architectures without some change. In FORTRAN II, you named the device you were talking to right in the FORTRAN statement in the middle of your FORTRAN code. So, you said &lt;code&gt;READ INPUT TAPE 5&lt;/code&gt; on a tape-oriented IBM 7090 but &lt;code&gt;READ CARD&lt;/code&gt; to read a card image on other machines. FORTRAN IV had more generic &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; statements, specifying a ''logical unit number'' (LUN) instead of the device name. The era of device-independent I/O had dawned.

Peripheral devices such as printers still had fairly strong notions about what they were asked to do. And then, ''peripheral interchange'' utilities were invented to handle bizarre devices. When cathode-ray tubes came onto the scene, each manufacturer of consoles solved problems such as console cursor movement in an independent manner, causing further headaches.

It was into this atmosphere that Unix was born. Ken Thompson and Dennis Ritchie, the developers of Unix, deserve credit for packing any number of bright ideas into the operating system. Their approach to device independence was one of the brightest.

The ANSI C &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt; library is based on the original Unix file I/O primitives but casts a wider net to accommodate the least-common denominator across varied systems.

==Streams==
Input and output, whether to or from physical devices such as terminals and tape drives, or whether to or from files supported on structured storage devices, are mapped into logical data streams, whose properties are more uniform than their various inputs and outputs.  Two forms of mapping are supported: text streams and binary streams.

A text stream consists of one or more lines. A line in a text stream consists of zero or more characters plus a terminating new-line character. (The only exception is that in some implementations the last line of a file does not require a terminating new-line character.) Unix adopted a standard internal format for all text streams. Each line of text is terminated by a new-line character. That's what any program expects when it reads text, and that's what any program produces when it writes text. (This is the most basic convention, and if it doesn't meet the needs of a text-oriented peripheral attached to a Unix machine, then the fix-up occurs out at the edges of the system. Nothing in between needs to change.) The string of characters that go into, or come out of a text stream may have to be modified to conform to specific conventions. This results in a possible difference between the data that go into a text stream and the data that come out. For instance, in some implementations when a space-character precedes a new-line character in the input, the space character gets removed out of the output. In general, when the data only consists of printable characters and control characters like horizontal tab and new-line, the input and output of a text stream are equal.

Compared to a text stream, a binary stream is pretty straight forward. A binary stream is an ordered sequence of characters that can transparently record internal data. Data written to a binary stream shall always equal the data that gets read out under the same implementation. Binary streams, however, may have an implementation-defined number of null characters appended to the end of the stream. There are no further conventions which need to be considered.

Nothing in Unix prevents the program from writing arbitrary 8-bit binary codes to any open file, or reading them back unchanged from an adequate repository. Thus, Unix obliterated the long-standing distinction between text streams and binary streams.

== Standard Streams ==
When a C program starts its execution the program automatically opens three standard streams named
&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt;. These are attached for every C program.

The first standard stream is used for input buffering and the other two are used for output. These streams are sequences of bytes.

Consider the following program:

&lt;source lang=c&gt;
 /* An example program. */
 int main()
 {
     int var;
     scanf ("%d", &amp;var); /* use stdin for scanning an integer from keyboard. */
     printf ("%d", var); /* use stdout for printing the integer that was just scanned in. */
     return 0;
 }
 /* end program. */
&lt;/source&gt;
    
By default &lt;code&gt;stdin&lt;/code&gt; points to the keyboard and &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; point to the screen. It is possible under Unix and may be possible under other operating systems to redirect input from or output to a file or both.

== Pointers to streams ==
{{Side note|side=right|&lt;small&gt;For historical reasons, the type of the C data structure that represents a stream is called &lt;code&gt;FILE&lt;/code&gt; rather than &lt;code&gt;stream&lt;/code&gt;.&lt;/small&gt;}}  The &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt; header contains a definition for a type &lt;code&gt;FILE&lt;/code&gt; (usually via a &lt;code&gt;typedef&lt;/code&gt;) which is capable of processing all the information needed to exercise control over a stream, including its file position indicator, a pointer to the associated buffer (if any), an error indicator that records whether a read/write error has occurred, and an end-of-file indicator that records whether the end of the file has been reached.

It is considered bad form to access the contents of &lt;code&gt;FILE&lt;/code&gt; directly unless the programmer is writing an implementation of &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt; and its contents. Better access to the contents of &lt;code&gt;FILE&lt;/code&gt; is provided via the functions in &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt;. It can be said that the &lt;code&gt;FILE&lt;/code&gt; type is an early example of [[w:Object-oriented programming|object-oriented programming]].

==Opening and Closing Files==
To open and close files, the &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt; library has three functions: &lt;code&gt;fopen&lt;/code&gt;, &lt;code&gt;freopen&lt;/code&gt;, and &lt;code&gt;fclose&lt;/code&gt;.
===Opening Files===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 FILE *fopen(const char *filename, const char *mode);
 FILE *freopen(const char *filename, const char *mode, FILE *stream);
&lt;/source&gt;

&lt;code&gt;fopen&lt;/code&gt; and &lt;code&gt;freopen&lt;/code&gt; opens the file whose name is in the string pointed to by &lt;code&gt;filename&lt;/code&gt; and associates a stream with it. Both return a pointer to the object controlling the stream, or, if the open operation fails, a null pointer. The error and end-of-file indicators are cleared, and if the open operation fails error is set. &lt;code&gt;freopen&lt;/code&gt; differs from &lt;code&gt;fopen&lt;/code&gt; in that the file pointed to by &lt;code&gt;stream&lt;/code&gt; is closed first when already open and any close errors are ignored.

&lt;code&gt;mode&lt;/code&gt; for both functions points to a string beginning with one of the following sequences (additional characters may follow the sequences):

 r           open a text file for reading
 w           truncate to zero length or create a text file for writing
 a           append; open or create text file for writing at end-of-file
 rb          open binary file for reading
 wb          truncate to zero length or create a binary file for writing
 ab          append; open or create binary file for writing at end-of-file
 r+          open text file for update (reading and writing)
 w+          truncate to zero length or create a text file for update
 a+          append; open or create text file for update
 r+b or rb+  open binary file for update (reading and writing)
 w+b or wb+  truncate to zero length or create a binary file for update
 a+b or ab+  append; open or create binary file for update

Opening a file with read mode ('&lt;code&gt;r&lt;/code&gt;' as the first character in the &lt;code&gt;mode&lt;/code&gt; argument) fails if the file does not exist or cannot be read.

Opening a file with append mode ('&lt;code&gt;a&lt;/code&gt;' as the first character in the &lt;code&gt;mode&lt;/code&gt; argument) causes all subsequent writes to the file to be forced to the then-current end-of-file, regardless of intervening calls to the &lt;code&gt;fseek&lt;/code&gt; function.  In some implementations, opening a binary file with append mode ('&lt;code&gt;b&lt;/code&gt;' as the second or third character in the above list of &lt;code&gt;mode&lt;/code&gt; arguments) may initially position the file position indicator for the stream beyond the last data written, because of null character padding.

When a file is opened with update mode ('&lt;code&gt;+&lt;/code&gt;' as the second or third character in the above list of &lt;code&gt;mode&lt;/code&gt; argument values), both input and output may be performed on the associated stream. However, output may not be directly followed by input without an intervening call to the &lt;code&gt;fflush&lt;/code&gt; function or to a file positioning function (&lt;code&gt;fseek&lt;/code&gt;, &lt;code&gt;fsetpos&lt;/code&gt;, or &lt;code&gt;rewind&lt;/code&gt;), and input may not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.

When opened, a stream is fully buffered if and only if it can be determined not to refer to an interactive device.

===Closing Files===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int fclose(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;fclose&lt;/code&gt; function causes the stream pointed to by &lt;code&gt;stream&lt;/code&gt; to be flushed and the associated file to be closed.  Any unwritten buffered data for the stream are delivered to the host environment to be written to the file; any unread buffered data are discarded. The stream is disassociated from the file.  If the associated buffer was automatically allocated, it is deallocated.  The function returns zero if the stream was successfully closed or &lt;code&gt;EOF&lt;/code&gt; if any errors were detected.

== Stream buffering functions==
===The &lt;code&gt;fflush&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int fflush(FILE *stream);
&lt;/source&gt;

If &lt;code&gt;stream&lt;/code&gt; points to an output stream or an update stream in which the most recent operation was not input, the &lt;code&gt;fflush&lt;/code&gt; function causes any unwritten data for that stream to be deferred to the host environment to be written to the file. The behavior of fflush is undefined for input stream.

If &lt;code&gt;stream&lt;/code&gt; is a null pointer, the &lt;code&gt;fflush&lt;/code&gt; function performs this flushing action on all streams for which the behavior is defined above.

The &lt;code&gt;fflush&lt;/code&gt; functions returns &lt;code&gt;EOF&lt;/code&gt; if a write error occurs, otherwise zero.

The reason for having a &lt;code&gt;fflush&lt;/code&gt; function is because streams in C can have buffered input/output; that is, functions that write to a file actually write to a buffer inside the &lt;code&gt;FILE&lt;/code&gt; structure.  If the buffer is filled to capacity, the write functions will call &lt;code&gt;fflush&lt;/code&gt; to actually "write" the data that is in the buffer to the file. Because &lt;code&gt;fflush&lt;/code&gt; is only called every once in a while, calls to the operating system to do a raw write are minimized.

===The &lt;code&gt;setbuf&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 void setbuf(FILE *stream, char *buf);
&lt;/source&gt;

Except that it returns no value, the &lt;code&gt;setbuf&lt;/code&gt; function is equivalent to the &lt;code&gt;setvbuf&lt;/code&gt; function invoked with the values &lt;code&gt;_IOFBF&lt;/code&gt; for &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;BUFSIZ&lt;/code&gt; for &lt;code&gt;size&lt;/code&gt;, or (if &lt;code&gt;buf&lt;/code&gt; is a null pointer) with the value &lt;code&gt;_IONBF&lt;/code&gt; for &lt;code&gt;mode&lt;/code&gt;.

===The &lt;code&gt;setvbuf&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int setvbuf(FILE *stream, char *buf, int mode, size_t size);
&lt;/source&gt;

The &lt;code&gt;setvbuf&lt;/code&gt; function may be used only after the stream pointed to by &lt;code&gt;stream&lt;/code&gt; has been associated with an open file and before any other operation is performed on the stream. The argument &lt;code&gt;mode&lt;/code&gt; determines how the stream will be buffered, as follows: &lt;code&gt;_IOFBF&lt;/code&gt; causes input/output to be fully buffered; &lt;code&gt;_IOLBF&lt;/code&gt; causes input/output to be line buffered; &lt;code&gt;_IONBF&lt;/code&gt; causes input/output to be unbuffered. If &lt;code&gt;buf&lt;/code&gt; is not a null pointer, the array it points to may be used instead of a buffer associated by the &lt;code&gt;setvbuf&lt;/code&gt; function. (The buffer must have a lifetime at least as great as the open stream, so the stream should be closed before a buffer that has automatic storage duration is deallocated upon block exit.) The argument &lt;code&gt;size&lt;/code&gt; specifies the size of the array. The contents of the array at any time are indeterminate.

The &lt;code&gt;setvbuf&lt;/code&gt; function returns zero on success, or nonzero if an invalid value is given for &lt;code&gt;mode&lt;/code&gt; or if the request cannot be honored.

==Functions that Modify the File Position Indicator==
The &lt;code&gt;stdio.h&lt;/code&gt; library has five functions that affect the file position indicator besides those that do reading or writing: &lt;code&gt;fgetpos&lt;/code&gt;, &lt;code&gt;fseek&lt;/code&gt;, &lt;code&gt;fsetpos&lt;/code&gt;, &lt;code&gt;ftell&lt;/code&gt;, and &lt;code&gt;rewind&lt;/code&gt;.

The &lt;code&gt;fseek&lt;/code&gt; and &lt;code&gt;ftell&lt;/code&gt; functions are older than &lt;code&gt;fgetpos&lt;/code&gt; and &lt;code&gt;fsetpos&lt;/code&gt;.
===The &lt;code&gt;fgetpos&lt;/code&gt; and &lt;code&gt;fsetpos&lt;/code&gt; functions===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int fgetpos(FILE *stream, fpos_t *pos);
 int fsetpos(FILE *stream, const fpos_t *pos);
&lt;/source&gt;

The &lt;code&gt;fgetpos&lt;/code&gt; function stores the current value of the file position indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt; in the object pointed to by &lt;code&gt;pos&lt;/code&gt;. The value stored contains unspecified information usable by the &lt;code&gt;fsetpos&lt;/code&gt; function for repositioning the stream to its position at the time of the call to the &lt;code&gt;fgetpos&lt;/code&gt; function.

If successful, the &lt;code&gt;fgetpos&lt;/code&gt; function returns zero; on failure, the &lt;code&gt;fgetpos&lt;/code&gt; function returns nonzero and stores an implementation-defined positive value in &lt;code&gt;errno&lt;/code&gt;.

The &lt;code&gt;fsetpos&lt;/code&gt; function sets the file position indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt; according to the value of the object pointed to by &lt;code&gt;pos&lt;/code&gt;, which shall be a value obtained from an earlier call to the &lt;code&gt;fgetpos&lt;/code&gt; function on the same stream.

A successful call to the &lt;code&gt;fsetpos&lt;/code&gt; function clears the end-of-file indicator for the stream and undoes any effects of the &lt;code&gt;ungetc&lt;/code&gt; function on the same stream.  After an &lt;code&gt;fsetpos&lt;/code&gt; call, the next operation on an update stream may be either input or output.

If successful, the &lt;code&gt;fsetpos&lt;/code&gt; function returns zero; on failure, the &lt;code&gt;fsetpos&lt;/code&gt; function returns nonzero and stores an implementation-defined positive value in &lt;code&gt;errno&lt;/code&gt;.

===The &lt;code&gt;fseek&lt;/code&gt; and &lt;code&gt;ftell&lt;/code&gt; functions===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int fseek(FILE *stream, long int offset, int whence);
 long int ftell(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;fseek&lt;/code&gt; function sets the file position indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt;.

For a binary stream, the new position, measured in characters from the beginning of the file, is obtained by adding &lt;code&gt;offset&lt;/code&gt; to the position specified by &lt;code&gt;whence&lt;/code&gt;.  Three macros in &lt;code&gt;stdio.h&lt;/code&gt; called &lt;code&gt;SEEK_SET&lt;/code&gt;, &lt;code&gt;SEEK_CUR&lt;/code&gt;, and &lt;code&gt;SEEK_END&lt;/code&gt; expand to unique values. If the position specified by &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;SEEK_SET&lt;/code&gt;, the specified position is the beginning of the file; if &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;SEEK_END&lt;/code&gt;, the specified position is the end of the file; and if &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;SEEK_CUR&lt;/code&gt;, the specified position is the current file position. A binary stream need not meaningfully support &lt;code&gt;fseek&lt;/code&gt; calls with a &lt;code&gt;whence&lt;/code&gt; value of &lt;code&gt;SEEK_END&lt;/code&gt;.

For a text stream, either &lt;code&gt;offset&lt;/code&gt; shall be zero, or &lt;code&gt;offset&lt;/code&gt; shall be a value returned by an earlier call to the &lt;code&gt;ftell&lt;/code&gt; function on the same stream and &lt;code&gt;whence&lt;/code&gt; shall be &lt;code&gt;SEEK_SET&lt;/code&gt;.

The &lt;code&gt;fseek&lt;/code&gt; function returns nonzero only for a request that cannot be satisfied.

The &lt;code&gt;ftell&lt;/code&gt; function obtains the current value of the file position indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt;.  For a binary stream, the value is the number of characters from the beginning of the file; for a text stream, its file position indicator contains unspecified information, usable by the &lt;code&gt;fseek&lt;/code&gt; function for returning the file position indicator for the stream to its position at the time of the &lt;code&gt;ftell&lt;/code&gt; call; the difference between two such return values is not necessarily a meaningful measure of the number of characters written or read.

If successful, the &lt;code&gt;ftell&lt;/code&gt; function returns the current value of the file position indicator for the stream. On failure, the &lt;code&gt;ftell&lt;/code&gt; function returns &lt;code&gt;-1L&lt;/code&gt; and stores an implementation-defined positive value in &lt;code&gt;errno&lt;/code&gt;.
===The &lt;code&gt;rewind&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 void rewind(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;rewind&lt;/code&gt; function sets the file position indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt; to the beginning of the file.  It is equivalent to

 (void)fseek(stream, 0L, SEEK_SET)

except that the error indicator for the stream is also cleared. 
==Error Handling Functions==
===The &lt;code&gt;clearerr&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 void clearerr(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;clearerr&lt;/code&gt; function clears the end-of-file and error indicators for the stream pointed to by &lt;code&gt;stream&lt;/code&gt;.
===The &lt;code&gt;feof&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int feof(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;feof&lt;/code&gt; function tests the end-of-file indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt; and returns nonzero if and only if the end-of-file indicator is set for &lt;code&gt;stream&lt;/code&gt;, otherwise it returns zero.

===The &lt;code&gt;ferror&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int ferror(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;ferror&lt;/code&gt; function tests the error indicator for the stream pointed to by &lt;code&gt;stream&lt;/code&gt; and returns nonzero if and only if the error indicator is set for &lt;code&gt;stream&lt;/code&gt;, otherwise it returns zero.
===The &lt;code&gt;perror&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 void perror(const char *s);
&lt;/source&gt;

The &lt;code&gt;perror&lt;/code&gt; function maps the error number in the integer expression &lt;code&gt;errno&lt;/code&gt; to an error message. It writes a sequence of characters to the standard error stream thus: first, if &lt;code&gt;s&lt;/code&gt; is not a null pointer and the character pointed to by &lt;code&gt;s&lt;/code&gt; is not the null character, the string pointed to by &lt;code&gt;s&lt;/code&gt; followed by a colon (&lt;tt&gt;:&lt;/tt&gt;) and a space; then an appropriate error message string followed by a new-line character. The contents of the error message are the same as those returned by the &lt;code&gt;strerror&lt;/code&gt; function with the argument &lt;code&gt;errno&lt;/code&gt;, which are implementation-defined.

==Other Operations on Files==
The &lt;code&gt;stdio.h&lt;/code&gt; library has a variety of functions that do some operation on files besides reading and writing.

===The &lt;code&gt;remove&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int remove(const char *filename);
&lt;/source&gt;

The &lt;code&gt;remove&lt;/code&gt; function causes the file whose name is the string pointed to by &lt;code&gt;filename&lt;/code&gt; to be no longer accessible by that name.  A subsequent attempt to open that file using that name will fail, unless it is created anew.  If the file is open, the behavior of the &lt;code&gt;remove&lt;/code&gt; function is implementation-defined.

The &lt;code&gt;remove&lt;/code&gt; function returns zero if the operation succeeds, nonzero if it fails.

===The &lt;code&gt;rename&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int rename(const char *old_filename, const char *new_filename);
&lt;/source&gt;

The &lt;code&gt;rename&lt;/code&gt; function causes the file whose name is the string pointed to by &lt;code&gt;old_filename&lt;/code&gt; to be henceforth known by the name given by the string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.  The file named &lt;code&gt;old_filename&lt;/code&gt; is no longer accessible by that name.  If a file named by the string pointed to by &lt;code&gt;new_filename&lt;/code&gt; exists prior to the call to the &lt;code&gt;rename&lt;/code&gt; function, the behavior is implementation-defined.

The &lt;code&gt;rename&lt;/code&gt; function returns zero if the operation succeeds, nonzero if it fails, in which case if the file existed previously it is still known by its original name.

===The &lt;code&gt;tmpfile&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 FILE *tmpfile(void);
&lt;/source&gt;

The &lt;code&gt;tmpfile&lt;/code&gt; function creates a temporary binary file that will automatically be removed when it is closed or at program termination.  If the program terminates abnormally, whether an open temporary file is removed is implementation-defined.  The file is opened for update with &lt;code&gt;"wb+"&lt;/code&gt; mode.

The &lt;code&gt;tmpfile&lt;/code&gt; function returns a pointer to the stream of the file that it created.  If the file cannot be created, the &lt;code&gt;tmpfile&lt;/code&gt; function returns a null pointer.

===The &lt;code&gt;tmpnam&lt;/code&gt; function===
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 char *tmpnam(char *s);
&lt;/source&gt;

The &lt;code&gt;tmpnam&lt;/code&gt; function generates a string that is a valid file name and that is not the name of an existing file.

The &lt;code&gt;tmpnam&lt;/code&gt; function generates a different string each time it is called, up to &lt;code&gt;TMP_MAX&lt;/code&gt; times. (&lt;code&gt;TMP_MAX&lt;/code&gt; is a macro defined in &lt;code&gt;stdio.h&lt;/code&gt;.) If it is called more than &lt;code&gt;TMP_MAX&lt;/code&gt; times, the behavior is implementation-defined.

The implementation shall behave as if no library function calls the &lt;code&gt;tmpnam&lt;/code&gt; function.

If the argument is a null pointer, the &lt;code&gt;tmpnam&lt;/code&gt; function leaves its result in an internal static object and returns a pointer to that object.  Subsequent calls to the &lt;code&gt;tmpnam&lt;/code&gt; function may modify the same object. If the argument is not a null pointer, it is assumed to point to an array of at least &lt;code&gt;L_tmpnam&lt;/code&gt; characters (&lt;code&gt;L_tmpnam&lt;/code&gt; is another macro in &lt;code&gt;stdio.h&lt;/code&gt;); the &lt;code&gt;tmpnam&lt;/code&gt; function writes its result in that array and returns the argument as its value.

The value of the macro &lt;code&gt;TMP_MAX&lt;/code&gt; must be at least 25.
 
==Reading from Files==
===Character Input Functions===
====The &lt;code&gt;fgetc&lt;/code&gt; function====
&lt;source lang=c&gt;
 #include &lt;stdio.h&gt;
 int fgetc(FILE *stream);
&lt;/source&gt;

The &lt;code&gt;fgetc&lt;/code&gt; function obtains the next character (if present) as an &lt;code&gt;unsigned char&lt;/code&gt; converted to an &lt;code&gt;int&lt;/code&gt;, from the stream pointed to by &lt;code&gt;stream&lt;/code&gt;, and advances the associated file position indicator for the stream (if defined). 

The &lt;code&gt;fgetc&lt;/code&gt; function returns the next character from the stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If the stream is at end-of-file or a read error occurs, &lt;code&gt;fgetc&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt; (&lt;code&gt;EOF&lt;/code&gt; is a negative value defined in &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt;, usually &lt;code&gt;(-1)&lt;/code&gt;). The routines &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;ferror&lt;/code&gt; must be used to distinguish between end-of-file and error.  If an error occurs, the global variable &lt;code&gt;errno&lt;/code&gt; is set to indicate the error.

====The &lt;code&gt;fgets&lt;/code&gt; function====
&lt;source lang="C"&gt;
 #include &lt;stdio.h&gt;
 char *fgets(char *s, int n, FILE *stream);
&lt;/source&gt;
The &lt;code&gt;fgets&lt;/code&gt; function reads at most one less than the number of characters specified by &lt;code&gt;n&lt;/code&gt; from the stream pointed to by &lt;code&gt;stream&lt;/code&gt; into the array pointed to by &lt;code&gt;s&lt;/code&gt;. No additional characters are read after a new-line character (which is retained) or after end-of-file. A null character is written immediately after the last character read into the array.

The &lt;code&gt;fgets&lt;/code&gt; function returns &lt;code&gt;s&lt;/code&gt; if successful. If end-of-file is encountered and no characters have been read into the array, the contents of the array remain unchanged and a null pointer is returned. If a read error occurs during the operation, the array contents are indeterminate and a null pointer is returned.

Warning: Different operating systems may use different character sequences to represent the end-of-line sequence. For example, some filesystems use the terminator &lt;code&gt;\r\n&lt;/code&gt; in text files; &lt;code&gt;fgets&lt;/code&gt; may read those lines, removing the &lt;code&gt;\n&lt;/code&gt; but keeping the &lt;code&gt;\r&lt;/code&gt; as the last character of &lt;code&gt;s&lt;/code&gt;. This expurious character should be removed in the string &lt;code&gt;s&lt;/code&gt; before the string is used for anything (unless the programmer doesn't care about it). Unixes typically use &lt;code&gt;\n&lt;/code&gt; as its end-of-line sequence, MS-DOS and Windows uses &lt;code&gt;\r\n&lt;/code&gt;, and Mac OSes used &lt;code&gt;\r&lt;/code&gt; before OS X. Many compilers on operating systems other than Unix or Linux map newline sequences to &lt;code&gt;\n&lt;/code&gt; on input for text files; check your compiler's documentation to discover what it does in this situation.

&lt;source lang=c&gt;
 /* An example program that reads from stdin and writes to stdout */
 #include &lt;stdio.h&gt;

 #define BUFFER_SIZE 100

 int main(void)
 {
     char buffer[BUFFER_SIZE]; /* a read buffer */
     while( fgets (buffer, BUFFER_SIZE, stdin) != NULL)
     {
          printf("%s",buffer);
     }
     return 0;
 }
 /* end program. */
&lt;/source&gt;

====The &lt;code&gt;getc&lt;/code&gt; function====
&lt;source lang=C&gt;
 #include &lt;stdio.h&gt;
 int getc(FILE *stream);
&lt;/source&gt;
The &lt;code&gt;getc&lt;/code&gt; function is equivalent to &lt;code&gt;fgetc&lt;/code&gt;, except that it may be implemented as a macro. If it is implemented as a macro, the &lt;code&gt;stream&lt;/code&gt; argument may be evaluated more than once, so the argument should never be an expression with side effects (i.e. have an assignment, increment, or decrement operators, or be a function call).

The &lt;code&gt;getc&lt;/code&gt; function returns the next character from the input stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If the stream is at end-of-file, the end-of-file indicator for the stream is set and &lt;code&gt;getc&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt; (&lt;code&gt;EOF&lt;/code&gt; is a negative value defined in &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt;, usually &lt;code&gt;(-1)&lt;/code&gt;). If a read error occurs, the error indicator for the stream is set and &lt;code&gt;getc&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt;.

====The &lt;code&gt;getchar&lt;/code&gt; function====
&lt;source lang="C"&gt;
 #include &lt;stdio.h&gt;
 int getchar(void);
&lt;/source&gt;
The &lt;code&gt;getchar&lt;/code&gt; function is equivalent to &lt;code&gt;getc&lt;/code&gt; with the argument &lt;code&gt;stdin&lt;/code&gt;.

The &lt;code&gt;getchar&lt;/code&gt; function returns the next character from the input stream pointed to by &lt;code&gt;stdin&lt;/code&gt;. If &lt;code&gt;stdin&lt;/code&gt; is at end-of-file, the end-of-file indicator for &lt;code&gt;stdin&lt;/code&gt; is set and &lt;code&gt;getchar&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt; (&lt;code&gt;EOF&lt;/code&gt; is a negative value defined in &lt;code&gt;&lt;stdio.h&gt;&lt;/code&gt;, usually &lt;code&gt;(-1)&lt;/code&gt;). If a read error occurs, the error indicator for &lt;code&gt;stdin&lt;/code&gt; is set and &lt;code&gt;getchar&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt;.

====The &lt;code&gt;gets&lt;/code&gt; function====
&lt;source lang="C"&gt;
 #include &lt;stdio.h&gt;
 char *gets(char *s);
&lt;/source&gt;
The &lt;code&gt;gets&lt;/code&gt; function reads characters from the input stream pointed to by &lt;code&gt;stdin&lt;/code&gt; into the array pointed to by &lt;code&gt;s&lt;/code&gt; until an end-of-file is encountered or a new-line character is read. Any new-line character is discarded, and a null character is written immediately after the last character read into the array.

The &lt;code&gt;gets&lt;/code&gt; function returns &lt;code&gt;s&lt;/code&gt; if successful. If the end-of-file is encountered and no characters have been read into the array, the contents of the array remain unchanged and a null pointer is returned. If a read error occurs during the operation, the array contents are indeterminate and a null pointer is returned.

This function and description is only included here for completeness. Most C programmers nowadays shy away from using &lt;code&gt;gets&lt;/code&gt;, as there is no way for the function to know how big the buffer is that the programmer wants to read into.

Commandment #5 of [[w:Henry Spencer | Henry Spencer]]'s ''The Ten Commandments for C Programmers (Annotated Edition)'' reads

{{Quote
|text=Thou shalt check the array bounds of all strings (indeed, all arrays), for surely where thou typest ''foo'' someone someday shall type ''supercalifragilisticexpialidocious''.
}}

It mentions &lt;code&gt;gets&lt;/code&gt; in the annotation: 

{{Quote
|text=As demonstrated by the deeds of the Great Worm, a consequence of this commandment is that robust production software should never make use of &lt;code&gt;gets()&lt;/code&gt;, for it is truly a tool of the Devil. Thy interfaces should always inform thy servants of the bounds of thy arrays, and servants who spurn such advice or quietly fail to follow it should be dispatched forthwith to the Land Of Rm, where they can do no further harm to thee.
}}

Before the 2018 version of the C standard, the &lt;code&gt;gets&lt;/code&gt; function was deprecated. It is hoped that programmers would use the &lt;code&gt;fgets&lt;/code&gt; function instead.

====The &lt;code&gt;ungetc&lt;/code&gt; function====
&lt;source lang="C"&gt;
 #include &lt;stdio.h&gt;
 int ungetc(int c, FILE *stream);
&lt;/source&gt;
The &lt;code&gt;ungetc&lt;/code&gt; function pushes the character specified by &lt;code&gt;c&lt;/code&gt; (converted to an &lt;code&gt;unsigned char&lt;/code&gt;) back onto the input stream pointed to by stream. The pushed-back characters will be returned by subsequent reads on that stream in the reverse order of their pushing. A successful intervening call (with the stream pointed to by &lt;code&gt;stream&lt;/code&gt;) to a file-positioning function (&lt;code&gt;fseek&lt;/code&gt;, &lt;code&gt;fsetpos&lt;/code&gt;, or &lt;code&gt;rewind&lt;/code&gt;) discards any pushed-back characters for the stream. The external storage corresponding to the stream is unchanged.

One character of pushback is guaranteed. If the &lt;code&gt;ungetc&lt;/code&gt; function is called too many times on the same stream without an intervening read or file positioning operation on that stream, the operation may fail.

If the value of &lt;code&gt;c&lt;/code&gt; equals that of the macro &lt;code&gt;EOF&lt;/code&gt;, the operation fails and the input stream is unchanged.

A successful call to the &lt;code&gt;ungetc&lt;/code&gt; function clears the end-of-file indicator for the stream. The value of the file position indicator for the stream after reading or discarding all pushed-back characters shall be the same as it was before the characters were pushed back. For a text stream, the value of its file-position indicator after a successful call to the &lt;code&gt;ungetc&lt;/code&gt; function is unspecified until all pushed-back characters are read or discarded. For a binary stream, its file position indicator is decremented by each successful call to the &lt;code&gt;ungetc&lt;/code&gt; function; if its value was zero before a call, it is indeterminate after the call.

The &lt;code&gt;ungetc&lt;/code&gt; function returns the character pushed back after conversion, or &lt;code&gt;EOF&lt;/code&gt; if the operation fails.

===EOF pitfall===
A mistake when using &lt;code&gt;fgetc&lt;/code&gt;, &lt;code&gt;getc&lt;/code&gt;, or &lt;code&gt;getchar&lt;/code&gt; is to assign the result to a variable of type &lt;code&gt;char&lt;/code&gt; ''before'' comparing it to &lt;code&gt;EOF&lt;/code&gt;. The following code fragments exhibit this mistake, and then show the correct approach (using type int):

&lt;center&gt;
{| width="80%" style="margin-left: auto; margin-right: auto; "
! Mistake
! Correction
|-
|
&lt;source lang="c"&gt;
char c;
while ((c = getchar()) != EOF)
    putchar(c);
&lt;/source&gt;
|
&lt;source lang="c"&gt;
int c;
while ((c = getchar()) != EOF)
    putchar(c);
&lt;/source&gt;
|}
&lt;/center&gt;

Consider a system in which the type &lt;code&gt;char&lt;/code&gt; is 8&amp;nbsp;bits wide, representing 256&amp;nbsp;different values. &lt;code&gt;getchar&lt;/code&gt; may return any of the 256&amp;nbsp;possible characters, and it also may return &lt;code&gt;EOF&lt;/code&gt; to indicate [[end-of-file]], for a total of 257 different possible return values.

When &lt;code&gt;getchar&lt;/code&gt;'s result is assigned to a &lt;code&gt;char&lt;/code&gt;, which can represent only 256 different values, there is necessarily some loss of information—when packing 257&amp;nbsp;items into 256&amp;nbsp;slots, there [[Pigeonhole principle|must be a collision]]. The &lt;code&gt;EOF&lt;/code&gt; value, when converted to &lt;code&gt;char&lt;/code&gt;, becomes indistinguishable from whichever one of the 256 characters shares its numerical value. If that character is found in the file, the above example may mistake it for an end-of-file indicator; or, just as bad, if type &lt;code&gt;char&lt;/code&gt; is unsigned, then because &lt;code&gt;EOF&lt;/code&gt; is negative, it can never be equal to any unsigned &lt;code&gt;char&lt;/code&gt;, so the above example will not terminate at end-of-file. It will loop forever, repeatedly printing the character which results from converting &lt;code&gt;EOF&lt;/code&gt; to &lt;code&gt;char&lt;/code&gt;.

However, this looping failure mode does not occur if the char definition is signed (C makes the signedness of the default char type implementation-dependent),&lt;ref&gt;C99 §6.2.5/15&lt;/ref&gt;  assuming the commonly used [[End-of-file|&lt;code&gt;EOF&lt;/code&gt; value of -1]].  However, the fundamental issue remains that if the &lt;code&gt;EOF&lt;/code&gt; value is defined outside of the range of the &lt;code&gt;char&lt;/code&gt; type, when assigned to a &lt;code&gt;char&lt;/code&gt; that value is sliced and will no longer match the full &lt;code&gt;EOF&lt;/code&gt; value necessary to exit the loop.  On the other hand, if &lt;code&gt;EOF&lt;/code&gt; is within range of &lt;code&gt;char&lt;/code&gt;, this guarantees a collision between &lt;code&gt;EOF&lt;/code&gt; and a char value.  Thus, regardless of how system types are defined, never use &lt;code&gt;char&lt;/code&gt; types when testing against &lt;code&gt;EOF&lt;/code&gt;.

On systems where &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; are the same size (i.e., systems incompatible with minimally the POSIX and C99 standards), even the "good" example will suffer from the indistinguishability of &lt;code&gt;EOF&lt;/code&gt; and some character's value. The proper way to handle this situation is to check &lt;code&gt;[[feof]]&lt;/code&gt; and &lt;code&gt;[[ferror]]&lt;/code&gt; after &lt;code&gt;getchar&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt;. If &lt;code&gt;feof&lt;/code&gt; indicates that end-of-file has not been reached, and &lt;code&gt;ferror&lt;/code&gt; indicates that no errors have occurred, then the &lt;code&gt;EOF&lt;/code&gt; returned by &lt;code&gt;getchar&lt;/code&gt; can be assumed to represent an actual character. These extra checks are rarely done, because most programmers assume that their code will never need to run on one of these "big &lt;code&gt;char&lt;/code&gt;" systems. Another way is to use a compile-time assertion to make sure that &lt;code&gt;UINT_MAX &gt; UCHAR_MAX&lt;/code&gt;, which at least prevents a program with such an assumption from compiling in such a system.


===Direct input function: the &lt;code&gt;fread&lt;/code&gt; function===
&lt;source lang="C"&gt;
 #include &lt;stdio.h&gt;
 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
&lt;/source&gt;
The &lt;code&gt;fread&lt;/code&gt; function reads, into the array pointed to by &lt;code&gt;ptr&lt;/code&gt;, up to &lt;code&gt;nmemb&lt;/code&gt; elements whose size is specified by &lt;code&gt;size&lt;/code&gt;, from the stream pointed to by &lt;code&gt;stream&lt;/code&gt;. The file position indicator for the stream (if defined) is advanced by the number of characters successfully read. If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.

The &lt;code&gt;fread&lt;/code&gt; function returns the number of elements successfully read, which may be less than &lt;code&gt;nmemb&lt;/code&gt; if a read error or end-of-file is encountered. If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;nmemb&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and the contents of the array and the state of the stream remain unchanged.

===Formatted input functions: the &lt;code&gt;scanf&lt;/code&gt; family of functions===
&lt;source lang="C"&gt;
 #include &lt;stdio.h&gt;
 int fscanf(FILE *stream, const char *format, ...);
 int scanf(const char *format, ...);
 int sscanf(const char *s, const char *format, ...);
&lt;/source&gt;
The &lt;code&gt;fscanf&lt;/code&gt; function reads input from the stream pointed to by &lt;code&gt;stream&lt;/code&gt;, under control of the string pointed to by &lt;code&gt;format&lt;/code&gt; that specifies the admissible sequences and how they are to be converted for assignment, using subsequent arguments as pointers to the objects to receive converted input. If there are insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored.

The format shall be a multibyte character sequence, beginning and ending in its initial shift state. The format is composed of zero or more directives: one or more white-space characters; an ordinary multibyte character (neither &lt;tt&gt;%&lt;/tt&gt; or a white-space character); or a conversion specification. Each conversion specification is introduced by the character &lt;tt&gt;%&lt;/tt&gt;. After the &lt;tt&gt;%&lt;/tt&gt;, the following appear in sequence:
*An optional assignment-suppressing character &lt;tt&gt;*&lt;/tt&gt;.
*An optional nonzero decimal integer that specifies the maximum field width.
*An optional &lt;tt&gt;h&lt;/tt&gt;, &lt;tt&gt;l&lt;/tt&gt; (ell) or &lt;tt&gt;L&lt;/tt&gt; indicating the size of the receiving object. The conversion specifiers &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, and &lt;tt&gt;n&lt;/tt&gt; shall be preceded by &lt;tt&gt;h&lt;/tt&gt; if the corresponding argument is a pointer to &lt;code&gt;short int&lt;/code&gt; rather than a pointer to &lt;code&gt;int&lt;/code&gt;, or by &lt;tt&gt;l&lt;/tt&gt; if it is a pointer to &lt;code&gt;long int&lt;/code&gt;. Similarly, the conversion specifiers &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, and &lt;tt&gt;x&lt;/tt&gt; shall be preceded by &lt;tt&gt;h&lt;/tt&gt; if the corresponding argument is a pointer to &lt;code&gt;unsigned short int&lt;/code&gt; rather than &lt;code&gt;unsigned int&lt;/code&gt;, or by &lt;tt&gt;l&lt;/tt&gt; if it is a pointer to &lt;code&gt;unsigned long int&lt;/code&gt;. Finally, the conversion specifiers &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, and &lt;tt&gt;g&lt;/tt&gt; shall be preceded by &lt;tt&gt;l&lt;/tt&gt; if the corresponding argument is a pointer to &lt;code&gt;double&lt;/code&gt; rather than a pointer to &lt;code&gt;float&lt;/code&gt;, or by &lt;tt&gt;L&lt;/tt&gt; if it is a pointer to &lt;code&gt;long double&lt;/code&gt;. If an &lt;tt&gt;h&lt;/tt&gt;, &lt;tt&gt;l&lt;/tt&gt;, or &lt;tt&gt;L&lt;/tt&gt; appears with any other format specifier, the behavior is undefined.
*A character that specifies the type of conversion to be applied. The valid conversion specifiers are described below.

The &lt;code&gt;fscanf&lt;/code&gt; function executes each directive of the format in turn. If a directive fails, as detailed below, the &lt;code&gt;fscanf&lt;/code&gt; function returns. Failures are described as input failures (due to the unavailability of input characters) or matching failures (due to inappropriate input).

A directive composed of white-space character(s) is executed by reading input up to the first non-white-space character (which remains unread) or until no more characters remain unread.

A directive that is an ordinary multibyte character is executed by reading the next characters of the stream. If one of the characters differs from one comprising the directive, the directive fails, and the differing and subsequent characters remain unread.

A directive that is a conversion specification defines a set of matching input sequences, as described below for each specifier. A conversion specification is executed in the following steps:

Input white-space characters (as specified by the &lt;code&gt;isspace&lt;/code&gt; function) are skipped, unless the specification includes a &lt;tt&gt;[&lt;/tt&gt;, &lt;tt&gt;c&lt;/tt&gt;, or &lt;tt&gt;n&lt;/tt&gt; specifier. (The white-space characters are not counted against the specified field width.)

An input item is read from the stream, unless the specification includes an &lt;tt&gt;n&lt;/tt&gt; specifier. An input item is defined as the longest matching sequences of input characters, unless that exceeds a specified field width, in which case it is the initial subsequence of that length in the sequence. The first character, if any, after the input item remains unread. If the length of the input item is zero, the execution of the directive fails; this condition is a matching failure, unless an error prevented input from the stream, in which case it is an input failure.

Except in the case of a &lt;tt&gt;%&lt;/tt&gt; specifier, the input item (or, in the case of a &lt;tt&gt;%n&lt;/tt&gt; directive, the count of input characters) is converted to a type appropriate to the conversion specifier. If the input item is not a matching sequence, the execution of the directive fails; this condition is a matching failure. Unless assignment suppression was indicated by a &lt;tt&gt;*&lt;/tt&gt;, the result of the conversion is placed in the object pointed to by the first argument following the &lt;code&gt;format&lt;/code&gt; argument that has not already received a conversion result. If this object does not have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is undefined.

The following conversion specifiers are valid:

; &lt;tt&gt;d&lt;/tt&gt; : Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of the &lt;code&gt;strtol&lt;/code&gt; function with the value 10 for the &lt;code&gt;base&lt;/code&gt; argument. The corresponding argument shall be a pointer to integer.

; &lt;tt&gt;i&lt;/tt&gt; : Matches an optionally signed integer, whose format is the same as expected for the subject sequence of the &lt;code&gt;strtol&lt;/code&gt; function with the value 0 for the &lt;code&gt;base&lt;/code&gt; argument. The corresponding argument shall be a pointer to integer.

; &lt;tt&gt;o&lt;/tt&gt; : Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of the &lt;code&gt;strtoul&lt;/code&gt; function with the value 8 for the &lt;code&gt;base&lt;/code&gt; argument. The corresponding argument shall be a pointer to unsigned integer.

; &lt;tt&gt;u&lt;/tt&gt; : Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of the &lt;code&gt;strtoul&lt;/code&gt; function with the value 10 for the &lt;code&gt;base&lt;/code&gt; argument. The corresponding argument shall be a pointer to unsigned integer.

; &lt;tt&gt;x&lt;/tt&gt; : Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of the &lt;code&gt;strtoul&lt;/code&gt; function with the value 16 for the &lt;code&gt;base&lt;/code&gt; argument. The corresponding argument shall be a pointer to unsigned integer.

; &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt; : Matches an optionally signed floating-point number, whose format is the same as expected for the subject string of the &lt;code&gt;strtod&lt;/code&gt; function. The corresponding argument will be a pointer to floating.

; &lt;tt&gt;s&lt;/tt&gt; : Matches a sequence of non-white-space characters. (No special provisions are made for multibyte characters.) The corresponding argument shall be a pointer to the initial character of an array large enough to accept the sequence and a terminating null character, which will be added automatically.

; &lt;tt&gt;[&lt;/tt&gt; : Matches a nonempty sequence of characters (no special provisions are made for multibyte characters) from a set of expected characters (the &lt;i&gt;scanset&lt;/i&gt;). The corresponding argument shall be a pointer to the initial character of an array large enough to accept the sequence and a terminating null character, which will be added automatically. The conversion specifier includes all subsequent characters in the &lt;code&gt;format&lt;/code&gt; string, up to and including the matching right bracket (&lt;tt&gt;]&lt;/tt&gt;). The characters between the brackets (the &lt;i&gt;scanlist&lt;/i&gt;) comprise the scanset, unless the character after the left bracket is a circumflex (&lt;tt&gt;^&lt;/tt&gt;), in which case the scanset contains all the characters that do not appear in the scanlist between the circumflex and the right bracket. If the conversion specifier begins with &lt;tt&gt;[]&lt;/tt&gt; or &lt;tt&gt;[^]&lt;/tt&gt;, the right-bracket character is in the scanlist and the next right bracket character is the matching right bracket that ends the specification; otherwise, the first right bracket character is the one that ends the specification. If a &lt;tt&gt;-&lt;/tt&gt; character is in the scanlist and is not the first, nor the second where the first character is a &lt;tt&gt;^&lt;/tt&gt;, nor the last character, the behavior is implementation-defined.

; &lt;tt&gt;c&lt;/tt&gt; : Matches a sequence of characters (no special provisions are made for multibyte characters) of the number specified by the field width (1 if no field width is present in the directive). The corresponding argument shall be a pointer to the initial character of an array large enough to accept the sequence. No null character is added.

; &lt;tt&gt;p&lt;/tt&gt; : Matches an implementation-defined set of sequences, which should be the same as the set of sequences that may be produced by the &lt;tt&gt;%p&lt;/tt&gt; conversion of the &lt;code&gt;fprintf&lt;/code&gt; function. The corresponding argument shall be a pointer to &lt;code&gt;void&lt;/code&gt;. The interpretation of the input then is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that results shall compare equal to that value; otherwise the behavior of the &lt;tt&gt;%p&lt;/tt&gt; conversion is undefined.

; &lt;tt&gt;n&lt;/tt&gt; : No input is consumed. The corresponding argument shall be a pointer to integer into which is to be written the number of characters read from the input stream so far by this call to the &lt;code&gt;fscanf&lt;/code&gt; function. Execution of a &lt;tt&gt;%n&lt;/tt&gt; directive does not increment the assignment count returned at the completion of execution of the &lt;code&gt;fscanf&lt;/code&gt; function.

; &lt;tt&gt;%&lt;/tt&gt; : Matches a single &lt;tt&gt;%&lt;/tt&gt;; no conversion or assignment occurs. The complete conversion specification shall be &lt;tt&gt;%%&lt;/tt&gt;.

If a conversion specification is invalid, the behavior is undefined.

The conversion specifiers &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;G&lt;/tt&gt;, and &lt;tt&gt;X&lt;/tt&gt; are also valid and behave the same as, respectively, &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt;, and &lt;tt&gt;x&lt;/tt&gt;.

If end-of-file is encountered during input, conversion is terminated. If end-of-file occurs before any characters matching the current directive have been read (other than leading white space, where permitted), execution of the current directive terminates with an input failure; otherwise, unless execution of the current directive is terminated with a matching failure, execution of the following directive (if any) is terminated with an input failure.

If conversion terminates on a conflicting input character, the offending input character is left unread in the input stream. Trailing white space (including new-line characters) is left unread unless matched by a directive. The success of literal matches and suppressed assignments is not directly determinable other than via the &lt;tt&gt;%n&lt;/tt&gt; directive.

The &lt;code&gt;fscanf&lt;/code&gt; function returns the value of the macro &lt;code&gt;EOF&lt;/code&gt; if an input failure occurs before any conversion. Otherwise, the &lt;code&gt;fscanf&lt;/code&gt; function returns the number of input items assigned, which can be fewer than provided for, or even zero, in the event of an early matching failure.

The &lt;code&gt;scanf&lt;/code&gt; function is equivalent to &lt;code&gt;fscanf&lt;/code&gt; with the argument &lt;code&gt;stdin&lt;/code&gt; interposed before the arguments to &lt;code&gt;scanf&lt;/code&gt;. Its return value is similar to that of &lt;code&gt;fscanf&lt;/code&gt;.

The &lt;code&gt;sscanf&lt;/code&gt; function is equivalent to &lt;code&gt;fscanf&lt;/code&gt;, except that the argument &lt;code&gt;s&lt;/code&gt; specifies a string from which the input is to be obtained, rather than from a stream. Reaching the end of the string is equivalent to encountering the end-of-file for the &lt;code&gt;fscanf&lt;/code&gt; function. If copying takes place between objects that overlap, the behavior is undefined.

==Writing to Files==
===Character Output Functions===
====The &lt;code&gt;fputc&lt;/code&gt; function====
 #include &lt;stdio.h&gt;
 int fputc(int c, FILE *stream);

The &lt;code&gt;fputc&lt;/code&gt; function writes the character specified by &lt;code&gt;c&lt;/code&gt; (converted to an &lt;code&gt;unsigned char&lt;/code&gt;) to the stream pointed to by &lt;code&gt;stream&lt;/code&gt; at the position indicated by the associated file position indicator (if defined), and advances the indicator appropriately. If the file cannot support positioning requests, or if the stream is opened with append mode, the character is appended to the output stream. The function returns the character written, unless a write error occurs, in which case the error indicator for the stream is set and &lt;code&gt;fputc&lt;/code&gt; returns &lt;code&gt;EOF&lt;/code&gt;.

====The &lt;code&gt;fputs&lt;/code&gt; function====
 #include &lt;stdio.h&gt;
 int fputs(const char *s, FILE *stream);

The &lt;code&gt;fputs&lt;/code&gt; function writes the string pointed to by &lt;code&gt;s&lt;/code&gt; to the stream pointed to by &lt;code&gt;stream&lt;/code&gt;. The terminating null character is not written. The function returns &lt;code&gt;EOF&lt;/code&gt; if a write error occurs, otherwise it returns a nonnegative value.

====The &lt;code&gt;putc&lt;/code&gt; function====
 #include &lt;stdio.h&gt;
 int putc(int c, FILE *stream);

The &lt;code&gt;putc&lt;/code&gt; function is equivalent to &lt;code&gt;fputc&lt;/code&gt;, except that if it is implemented as a macro, it may evaluate &lt;code&gt;stream&lt;/code&gt; more than once, so the argument should never be an expression with side effects. The function returns the character written, unless a write error occurs, in which case the error indicator for the stream is set and the function returns &lt;code&gt;EOF&lt;/code&gt;.

====The &lt;code&gt;putchar&lt;/code&gt; function====
 #include &lt;stdio.h&gt;
 int putchar(int c);

The &lt;code&gt;putchar&lt;/code&gt; function is equivalent to &lt;code&gt;putc&lt;/code&gt; with the second argument &lt;code&gt;stdout&lt;/code&gt;. It returns the character written, unless a write error occurs, in which case the error indicator for &lt;code&gt;stdout&lt;/code&gt; is set and the function returns &lt;code&gt;EOF&lt;/code&gt;.

====The &lt;code&gt;puts&lt;/code&gt; function====
 #include &lt;stdio.h&gt;
 int puts(const char *s);

The &lt;code&gt;puts&lt;/code&gt; function writes the string pointed to by &lt;code&gt;s&lt;/code&gt; to the stream pointed to by &lt;code&gt;stdout&lt;/code&gt;, and appends a new-line character to the output. The terminating null character is not written. The function returns &lt;code&gt;EOF&lt;/code&gt; if a write error occurs; otherwise, it returns a nonnegative value.

===Direct output function: the &lt;code&gt;fwrite&lt;/code&gt; function===
 #include &lt;stdio.h&gt;
 size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

The &lt;code&gt;fwrite&lt;/code&gt; function writes, from the array pointed to by &lt;code&gt;ptr&lt;/code&gt;, up to &lt;code&gt;nmemb&lt;/code&gt; elements whose size is specified by &lt;code&gt;size&lt;/code&gt; to the stream pointed to by &lt;code&gt;stream&lt;/code&gt;. The file position indicator for the stream (if defined) is advanced by the number of characters successfully written. If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. The function returns the number of elements successfully written, which will be less than &lt;code&gt;nmemb&lt;/code&gt; only if a write error is encountered.

===Formatted output functions: the &lt;code&gt;printf&lt;/code&gt; family of functions===
 #include &lt;stdarg.h&gt;
 #include &lt;stdio.h&gt;
 int fprintf(FILE *stream, const char *format, ...);
 int printf(const char *format, ...);
 int sprintf(char *s, const char *format, ...);
 int vfprintf(FILE *stream, const char *format, va_list arg);
 int vprintf(const char *format, va_list arg);
 int vsprintf(char *s, const char *format, va_list arg);

''Note: Some length specifiers and format specifiers are new in C99. These may not be available in older compilers and versions of the stdio library, which adhere to the C89/C90 standard. Wherever possible, the new ones will be marked with (C99).''

The &lt;code&gt;fprintf&lt;/code&gt; function writes output to the stream pointed to by &lt;code&gt;stream&lt;/code&gt; under control of the string pointed to by &lt;code&gt;format&lt;/code&gt; that specifies how subsequent arguments are converted for output. If there are insufficient arguments for the format, the behavior is
undefined. If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored. The &lt;code&gt;fprintf &lt;/code&gt; function returns when the end of the format string is encountered.

The format shall be a multibyte character sequence, beginning and ending in its initial shift state. The format is composed of zero or more directives: ordinary multibyte characters (not &lt;tt&gt;%&lt;/tt&gt;), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments, converting them, if applicable, according to the corresponding conversion specifier, and then writing the result to the output stream.

Each conversion specification is introduced by the character &lt;tt&gt;%&lt;/tt&gt;. After the &lt;tt&gt;%&lt;/tt&gt;, the following appear in sequence:

* Zero or more flags (in any order) that modify the meaning of the conversion specification.
* An optional minimum field width. If the converted value has fewer characters than the field width, it is padded with spaces (by default) on the left (or right, if the left adjustment flag, described later, has been given) to the field width. The field width takes the form of an asterisk &lt;tt&gt;*&lt;/tt&gt; (described later) or a decimal integer. (Note that 0 is taken as a flag, not as the beginning of a field width.)
*An optional precision that gives the minimum number of digits to appear for the &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, and &lt;tt&gt;X&lt;/tt&gt; conversions, the number of digits to appear after the decimal-point character for &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, and &lt;tt&gt;F&lt;/tt&gt; conversions, the maximum number of significant digits for the &lt;tt&gt;g&lt;/tt&gt; and &lt;tt&gt;G&lt;/tt&gt; conversions, or the maximum number of characters to be written from a string in &lt;tt&gt;s&lt;/tt&gt; conversions. The precision takes the form of a period (&lt;tt&gt;.&lt;/tt&gt;) followed either by an asterisk &lt;tt&gt;*&lt;/tt&gt; (described later) or by an optional decimal integer; if only the period is specified, the precision is taken as zero. If a precision appears with any other conversion specifier, the behavior is undefined. Floating-point numbers are ''rounded'' to fit the precision; i.e. &lt;tt&gt;printf("%1.1f\n", 1.19);&lt;/tt&gt; produces &lt;tt&gt;1.2&lt;/tt&gt;.
* An optional length modifier that specifies the size of the argument.
* A conversion specifier character that specifies the type of conversion to be applied.

As noted above, a field width, or precision, or both, may be indicated by an asterisk. In this case, an &lt;code&gt;int&lt;/code&gt; argument supplies the field width or precision. The arguments specifying field width, or precision, or both, shall appear (in that order) before the argument (if any) to be converted. A negative field width argument is taken as a &lt;tt&gt;-&lt;/tt&gt; flag followed by a positive field width. A negative precision argument is taken as if the precision were omitted.

The flag characters and their meanings are:
; &lt;tt&gt;-&lt;/tt&gt; : The result of the conversion is left-justified within the field. (It is right-justified if this flag is not specified.)
; &lt;tt&gt;+&lt;/tt&gt; : The result of a signed conversion always begins with a plus or minus sign. (It begins with a sign only when a negative value is converted if this flag is not specified. The results of all floating conversions of a negative zero, and of negative values that round to zero, include a minus sign.)
; &lt;i&gt;space&lt;/i&gt; : If the first character of a signed conversion is not a sign, or if a signed conversion results in no characters, a space is prefixed to the result. If the space and &lt;tt&gt;+&lt;/tt&gt; flags both appear, the space flag is ignored.
; &lt;tt&gt;#&lt;/tt&gt; : The result is converted to an "alternative form". For &lt;tt&gt;o&lt;/tt&gt; conversion, it increases the precision, if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is printed). For &lt;tt&gt;x&lt;/tt&gt; (or &lt;tt&gt;X&lt;/tt&gt;) conversion, a nonzero result has &lt;tt&gt;0x&lt;/tt&gt; (or &lt;tt&gt;0X&lt;/tt&gt;) prefixed to it. For &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;F&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt;, and &lt;tt&gt;G&lt;/tt&gt; conversions, the result always contains a decimal-point character, even if no digits follow it. (Normally, a decimal-point character appears in the result of these conversions only if a digit follows it.) For &lt;tt&gt;g&lt;/tt&gt; and &lt;tt&gt;G&lt;/tt&gt; conversions, trailing zeros are not removed from the result. For other conversions, the behavior is undefined.
; &lt;tt&gt;0&lt;/tt&gt; : For &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, &lt;tt&gt;X&lt;/tt&gt;, &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;F&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt;, and &lt;tt&gt;G&lt;/tt&gt; conversions, leading zeros (following any indication of sign or base) are used to pad to the field width; no space padding is performed. If the &lt;tt&gt;0&lt;/tt&gt; and &lt;tt&gt;-&lt;/tt&gt; flags both appear, the &lt;tt&gt;0&lt;/tt&gt; flag is ignored. For &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, and &lt;tt&gt;X&lt;/tt&gt; conversions, if a precision is specified, the &lt;tt&gt;0&lt;/tt&gt; flag is ignored. For other conversions, the behavior is undefined.

The length modifiers and their meanings are:
; &lt;tt&gt;hh&lt;/tt&gt; : (C99) Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; argument (the argument will have been promoted according to the integer promotions, but its value shall be converted to &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; before printing); or that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to a &lt;code&gt;signed char&lt;/code&gt; argument.

; &lt;tt&gt;h&lt;/tt&gt; : Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;short int&lt;/code&gt; or &lt;code&gt;unsigned short int&lt;/code&gt; argument (the argument will have been promoted according to the integer promotions, but its value shall be converted to &lt;code&gt;short int&lt;/code&gt; or &lt;code&gt;unsigned short int&lt;/code&gt; before printing); or that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to a &lt;code&gt;short int&lt;/code&gt; argument.

; &lt;tt&gt;l&lt;/tt&gt; (ell) : Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;long int&lt;/code&gt; or &lt;code&gt;unsigned long int&lt;/code&gt; argument; that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to a &lt;code&gt;long int&lt;/code&gt; argument; (C99) that a following &lt;tt&gt;c&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;wint_t&lt;/code&gt; argument; (C99) that a following &lt;tt&gt;s&lt;/tt&gt; conversion specifier applies to a pointer to a &lt;code&gt;wchar_t&lt;/code&gt; argument; or has no effect on a following &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;F&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt;, or &lt;tt&gt;G&lt;/tt&gt; conversion specifier.

; &lt;tt&gt;ll&lt;/tt&gt; (ell-ell) : (C99) Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;long long int&lt;/code&gt; or &lt;code&gt;unsigned long long int&lt;/code&gt; argument; or that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to a &lt;code&gt;long long int&lt;/code&gt; argument.

; &lt;tt&gt;j&lt;/tt&gt; : (C99) Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to an &lt;code&gt;intmax_t&lt;/code&gt; or &lt;code&gt;uintmax_t&lt;/code&gt; argument; or that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to an &lt;code&gt;intmax_t&lt;/code&gt; argument.

; &lt;tt&gt;z&lt;/tt&gt; : (C99) Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;size_t&lt;/code&gt; or the corresponding signed integer type argument; or that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to a signed integer type corresponding to &lt;code&gt;size_t&lt;/code&gt; argument.

; &lt;tt&gt;t&lt;/tt&gt; : (C99) Specifies that a following &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt;, &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, or &lt;tt&gt;X&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;ptrdiff_t&lt;/code&gt; or the corresponding unsigned integer type argument; or that a following &lt;tt&gt;n&lt;/tt&gt; conversion specifier applies to a pointer to a &lt;code&gt;ptrdiff_t&lt;/code&gt; argument.

; &lt;tt&gt;L&lt;/tt&gt; : Specifies that a following &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;F&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt;, or &lt;tt&gt;G&lt;/tt&gt; conversion specifier applies to a &lt;code&gt;long double&lt;/code&gt; argument.

If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.

The conversion specifiers and their meanings are:

; &lt;tt&gt;d&lt;/tt&gt;, &lt;tt&gt;i&lt;/tt&gt; : The &lt;code&gt;int&lt;/code&gt; argument is converted to signed decimal in the style &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;&lt;b&gt;−&lt;/b&gt;&lt;/tt&gt;&lt;i&gt;]dddd&lt;/i&gt;. The precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it is expanded with leading zeros. The default precision is 1. The result of converting a zero value with a precision of zero is no characters.

; &lt;tt&gt;o&lt;/tt&gt;, &lt;tt&gt;u&lt;/tt&gt;, &lt;tt&gt;x&lt;/tt&gt;, &lt;tt&gt;X&lt;/tt&gt; : The &lt;code&gt;unsigned int&lt;/code&gt; argument is converted to unsigned octal (&lt;tt&gt;o&lt;/tt&gt;), unsigned decimal (&lt;tt&gt;u&lt;/tt&gt;), or unsigned hexadecimal notation (&lt;tt&gt;x&lt;/tt&gt; or &lt;tt&gt;X&lt;/tt&gt;) in the style &lt;i&gt;dddd&lt;/i&gt;; the letters &lt;tt&gt;&lt;b&gt;abcdef&lt;/b&gt;&lt;/tt&gt; are used for &lt;tt&gt;x&lt;/tt&gt; conversion and the letters &lt;tt&gt;&lt;b&gt;ABCDEF&lt;/b&gt;&lt;/tt&gt; for &lt;tt&gt;X&lt;/tt&gt; conversion. The precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it is expanded with leading zeros. The default precision is 1. The result of converting a zero value with a precision of zero is no characters.

; &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;F&lt;/tt&gt; : A &lt;code&gt;double&lt;/code&gt; argument representing a (finite) floating-point number is converted to decimal notation in the style &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;−&lt;/tt&gt;&lt;i&gt;]ddd&lt;/i&gt;&lt;tt&gt;.&lt;/tt&gt;&lt;i&gt;ddd&lt;/i&gt;, where the number of digits after the decimal-point character is equal to the precision specification. If the precision is missing, it is taken as 6; if the precision is zero and the &lt;tt&gt;#&lt;/tt&gt; flag is not specified, no decimal-point character appears. If a decimal-point character appears, at least one digit appears before it. The value is rounded to the appropriate number of digits.&lt;br&gt;(C99) A &lt;code&gt;double&lt;/code&gt; argument representing an infinity is converted in one of the styles &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;-&lt;/tt&gt;&lt;i&gt;]&lt;/i&gt;&lt;tt&gt;inf&lt;/tt&gt; or &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;-&lt;/tt&gt;&lt;i&gt;]&lt;/i&gt;&lt;tt&gt;infinity&lt;/tt&gt; &amp;mdash; which style is implementation-defined. A double argument representing a NaN is converted in one of the styles &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;-&lt;/tt&gt;&lt;i&gt;]&lt;/i&gt;&lt;tt&gt;nan&lt;/tt&gt; or &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;-&lt;/tt&gt;&lt;i&gt;]&lt;/i&gt;&lt;tt&gt;nan(&lt;/tt&gt;&lt;i&gt;n-char-sequence&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; &amp;mdash; which style, and the meaning of any &lt;i&gt;n-char-sequence&lt;/i&gt;, is implementation-defined. The &lt;tt&gt;F&lt;/tt&gt; conversion specifier produces &lt;tt&gt;INF&lt;/tt&gt;, &lt;tt&gt;INFINITY&lt;/tt&gt;, or &lt;tt&gt;NAN&lt;/tt&gt; instead of &lt;tt&gt;inf&lt;/tt&gt;, &lt;tt&gt;infinity&lt;/tt&gt;, or &lt;tt&gt;nan&lt;/tt&gt;, respectively. (When applied to infinite and NaN values, the &lt;tt&gt;-&lt;/tt&gt;, &lt;tt&gt;+&lt;/tt&gt;, and &lt;i&gt;space&lt;/i&gt; flags have their usual meaning; the &lt;tt&gt;#&lt;/tt&gt; and &lt;tt&gt;0&lt;/tt&gt; flags have no effect.)

; &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt; : A &lt;code&gt;double&lt;/code&gt; argument representing a (finite) floating-point number is converted in the style &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;−&lt;/tt&gt;&lt;i&gt;]d&lt;/i&gt;&lt;tt&gt;.&lt;/tt&gt;&lt;i&gt;ddd&lt;/i&gt;&lt;tt&gt;e&amp;plusmn;&lt;/tt&gt;&lt;i&gt;dd&lt;/i&gt;, where there is one digit (which is nonzero if the argument is nonzero) before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero and the &lt;tt&gt;#&lt;/tt&gt; flag is not specified, no decimal-point character appears. The value is rounded to the appropriate number of digits. The &lt;tt&gt;E&lt;/tt&gt; conversion specifier produces a number with &lt;tt&gt;E&lt;/tt&gt; instead of &lt;tt&gt;e&lt;/tt&gt; introducing the exponent. The exponent always contains at least two digits, and only as many more digits as necessary to represent the exponent. If the value is zero, the exponent is zero.&lt;br&gt;(C99) A &lt;code&gt;double&lt;/code&gt; argument representing an infinity or NaN is converted in the style of an &lt;tt&gt;f&lt;/tt&gt; or &lt;tt&gt;F&lt;/tt&gt; conversion specifier.

; &lt;tt&gt;g&lt;/tt&gt;, &lt;tt&gt;G&lt;/tt&gt; : A &lt;code&gt;double&lt;/code&gt; argument representing a (finite) floating-point number is converted in style &lt;tt&gt;f&lt;/tt&gt; or &lt;tt&gt;e&lt;/tt&gt; (or in style &lt;tt&gt;F&lt;/tt&gt; or &lt;tt&gt;E&lt;/tt&gt; in the case of a &lt;tt&gt;G&lt;/tt&gt; conversion specifier), with the precision specifying the number of significant digits. If the precision is zero, it is taken as 1. The style used depends on the value converted; style &lt;tt&gt;e&lt;/tt&gt; (or &lt;tt&gt;E&lt;/tt&gt;) is used only if the exponent resulting from such a conversion is less than &amp;ndash;4 or greater than or equal to the precision. Trailing zeros are removed from the fractional portion of the result unless the &lt;tt&gt;#&lt;/tt&gt; flag is specified; a decimal-point character appears only if it is followed by a digit.&lt;br&gt;(C99) A &lt;code&gt;double&lt;/code&gt; argument representing an infinity or NaN is converted in the style of an &lt;tt&gt;f&lt;/tt&gt; or &lt;tt&gt;F&lt;/tt&gt; conversion specifier.

; &lt;tt&gt;a&lt;/tt&gt;, &lt;tt&gt;A&lt;/tt&gt; : (C99) A double argument representing a (finite) floating-point number is converted in the style &lt;i&gt;[&lt;/i&gt;&lt;tt&gt;−&lt;/tt&gt;&lt;i&gt;]&lt;/i&gt;&lt;tt&gt;0x&lt;/tt&gt;&lt;i&gt;h&lt;/i&gt;&lt;tt&gt;.&lt;/tt&gt;&lt;i&gt;hhhh&lt;/i&gt;&lt;tt&gt;p&amp;plusmn;&lt;/tt&gt;&lt;i&gt;d&lt;/i&gt;, where there is one hexadecimal digit (which is nonzero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character (Binary implementations can choose the hexadecimal digit to the left of the decimal-point character so that subsequent digits align to nibble [4-bit] boundaries.) and the number of hexadecimal digits after it is equal to the precision; if the precision is missing and &lt;code&gt;FLT_RADIX&lt;/code&gt; is a power of 2, then the precision is sufficient for an exact representation of the value; if the precision is missing and &lt;code&gt;FLT_RADIX&lt;/code&gt; is not a power of 2, then the precision is sufficient to distinguish (The precision &lt;i&gt;p&lt;/i&gt; is sufficient to distinguish values of the source type if 16&lt;sup&gt;&lt;i&gt;p&lt;/i&gt;&amp;ndash;1&lt;/sup&gt; &gt; &lt;i&gt;b&lt;sup&gt;n&lt;/sup&gt;&lt;/i&gt; where &lt;i&gt;b&lt;/i&gt; is &lt;code&gt;FLT_RADIX&lt;/code&gt; and &lt;i&gt;n&lt;/i&gt; is the number of base-&lt;i&gt;b&lt;/i&gt; digits in the significand of the source type. A smaller &lt;i&gt;p&lt;/i&gt; might suffice depending on the implementation's scheme for determining the digit to the left of the decimal-point character.) values of type &lt;code&gt;double&lt;/code&gt;, except that trailing zeros may be omitted; if the precision is zero and the &lt;tt&gt;#&lt;/tt&gt; flag is not specified, no decimal-point character appears. The letters &lt;tt&gt;&lt;b&gt;abcdef&lt;/b&gt;&lt;/tt&gt; are used for &lt;tt&gt;a&lt;/tt&gt; conversion and the letters &lt;tt&gt;&lt;b&gt;ABCDEF&lt;/b&gt;&lt;/tt&gt; for &lt;tt&gt;A&lt;/tt&gt; conversion. The &lt;tt&gt;A&lt;/tt&gt; conversion specifier produces a number with &lt;tt&gt;X&lt;/tt&gt; and &lt;tt&gt;P&lt;/tt&gt; instead of &lt;tt&gt;x&lt;/tt&gt; and &lt;tt&gt;p&lt;/tt&gt;. The exponent always contains at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2. If the value is zero, the exponent is zero.&lt;br&gt;A &lt;code&gt;double&lt;/code&gt; argument representing an infinity or NaN is converted in the style of an &lt;tt&gt;f&lt;/tt&gt; or &lt;tt&gt;F&lt;/tt&gt; conversion specifier.

; &lt;tt&gt;c&lt;/tt&gt; : If no &lt;tt&gt;l&lt;/tt&gt; length modifier is present, the &lt;code&gt;int&lt;/code&gt; argument is converted to an &lt;code&gt;unsigned char&lt;/code&gt;, and the resulting character is written.&lt;br&gt;(C99) If an &lt;tt&gt;l&lt;/tt&gt; length modifier is present, the &lt;code&gt;wint_t&lt;/code&gt; argument is converted as if by an &lt;tt&gt;ls&lt;/tt&gt; conversion specification with no precision and an argument that points to the initial element of a two-element array of &lt;code&gt;wchar_t&lt;/code&gt;, the first element containing the &lt;code&gt;wint_t&lt;/code&gt; argument to the &lt;tt&gt;lc&lt;/tt&gt; conversion specification and the second a null wide character.

; &lt;tt&gt;s&lt;/tt&gt; : If no &lt;tt&gt;l&lt;/tt&gt; length modifier is present, the argument shall be a pointer to the initial element of an array of character type. (No special provisions are made for multibyte characters.) Characters from the array are written up to (but not including) the terminating null character. If the precision is specified, no more than that many characters are written. If the precision is not specified or is greater than the size of the array, the array shall contain a null character.&lt;br&gt;(C99) If an &lt;tt&gt;l&lt;/tt&gt; length modifier is present, the argument shall be a pointer to the initial element of an array of &lt;code&gt;wchar_t&lt;/code&gt; type. Wide characters from the array are converted to multibyte characters (each as if by a call to the &lt;code&gt;wcrtomb&lt;/code&gt; function, with the conversion state described by an &lt;code&gt;mbstate_t&lt;/code&gt; object initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The resulting multibyte characters are written up to (but not including) the terminating null character (byte). If no precision is specified, the array shall contain a null wide character. If a precision is specified, no more than that many characters (bytes) are written (including shift sequences, if any), and the array shall contain a null wide character if, to equal the multibyte character sequence length given by the precision, the function would need to access a wide character one past the end of the array. In no case is a partial multibyte character written. (Redundant shift sequences may result if multibyte characters have a state-dependent encoding.)

; &lt;tt&gt;p&lt;/tt&gt; : The argument shall be a pointer to &lt;code&gt;void&lt;/code&gt;. The value of the pointer is converted to a sequence of printable characters, in an implementation-defined manner.

; &lt;tt&gt;n&lt;/tt&gt; : The argument shall be a pointer to signed integer into which is written the number of characters written to the output stream so far by this call to &lt;code&gt;fprintf&lt;/code&gt;. No argument is converted, but one is consumed. If the conversion specification includes any flags, a field width, or a precision, the behavior is undefined.

; &lt;tt&gt;%&lt;/tt&gt; : A &lt;tt&gt;%&lt;/tt&gt; character is written. No argument is converted. The complete conversion specification shall be &lt;tt&gt;%%&lt;/tt&gt;.

If a conversion specification is invalid, the behavior is undefined. If any argument is not the correct type for the corresponding coversion specification, the behavior is undefined.

In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.

For &lt;tt&gt;a&lt;/tt&gt; and &lt;tt&gt;A&lt;/tt&gt; conversions, if &lt;code&gt;FLT_RADIX&lt;/code&gt; is a power of 2, the value is correctly rounded to a hexadecimal floating number with the given precision.

It is recommended practice that if &lt;code&gt;FLT_RADIX&lt;/code&gt; is not a power of 2, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with the extra stipulation that the error should have a correct sign for the current rounding direction.

It is recommended practice that for &lt;tt&gt;e&lt;/tt&gt;, &lt;tt&gt;E&lt;/tt&gt;, &lt;tt&gt;f&lt;/tt&gt;, &lt;tt&gt;F&lt;/tt&gt;, &lt;tt&gt;g&lt;/tt&gt;, and &lt;tt&gt;G&lt;/tt&gt; conversions, if the number of significant decimal digits is at most &lt;code&gt;DECIMAL_DIG&lt;/code&gt;, then the result should be correctly rounded. (For binary-to-decimal conversion, the result format's values are the numbers representable with the given format specifier. The number of significant digits is determined by the format specifier, and in the case of fixed-point conversion by the source value as well.) If the number of significant decimal digits is more than &lt;code&gt;DECIMAL_DIG&lt;/code&gt; but the source value is exactly representable with &lt;code&gt;DECIMAL_DIG&lt;/code&gt; digits, then the result should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings &lt;i&gt;L &lt; U&lt;/i&gt;, both having &lt;tt&gt;DECIMAL_DIG&lt;/tt&gt; significant digits; the value of the resultant decimal string &lt;i&gt;D&lt;/i&gt; should satisfy &lt;i&gt;L &amp;le; D &amp;le; U&lt;/i&gt;, with the extra stipulation that the error should have a correct sign for the current rounding direction.

The &lt;code&gt;fprintf&lt;/code&gt; function returns the number of characters transmitted, or a negative value if an output or encoding error occurred.

The &lt;code&gt;printf&lt;/code&gt; function is equivalent to &lt;code&gt;fprintf&lt;/code&gt; with the argument &lt;code&gt;stdout&lt;/code&gt; interposed before the arguments to &lt;code&gt;printf&lt;/code&gt;. It returns the number of characters transmitted, or a negative value if an output error occurred.

The &lt;code&gt;sprintf&lt;/code&gt; function is equivalent to &lt;code&gt;fprintf&lt;/code&gt;, except that the argument &lt;code&gt;s&lt;/code&gt; specifies an array into which the generated input is to be written, rather than to a stream. A null character is written at the end of the characters written; it is not counted as part of the returned sum. If copying takes place between objects that overlap, the behavior is undefined. The function returns the number of characters written in the array, not counting the terminating null character.

The &lt;code&gt;vfprintf&lt;/code&gt; function is equivalent to &lt;code&gt;fprintf&lt;/code&gt;, with the variable argument list replaced by &lt;code&gt;arg&lt;/code&gt;, which shall have been initialized by the &lt;code&gt;va_start&lt;/code&gt; macro (and possibly subsequent &lt;code&gt;va_arg&lt;/code&gt; calls). The &lt;code&gt;vfprintf&lt;/code&gt; function does not invoke the &lt;code&gt;va_end&lt;/code&gt; macro. The function returns the number of characters transmitted, or a negative value if an output error occurred.

The &lt;code&gt;vprintf&lt;/code&gt; function is equivalent to &lt;code&gt;printf&lt;/code&gt;, with the variable argument list replaced by &lt;code&gt;arg&lt;/code&gt;, which shall have been initialized by the &lt;code&gt;va_start&lt;/code&gt; macro (and possibly subsequent &lt;code&gt;va_arg&lt;/code&gt; calls). The &lt;code&gt;vprintf&lt;/code&gt; function does not invoke the &lt;code&gt;va_end&lt;/code&gt; macro. The function returns the number of characters transmitted, or a negative value if an output error occurred.

The &lt;code&gt;vsprintf&lt;/code&gt; function is equivalent to &lt;code&gt;sprintf&lt;/code&gt;, with the variable argument list replaced by &lt;code&gt;arg&lt;/code&gt;, which shall have been initialized by the &lt;code&gt;va_start&lt;/code&gt; macro (and possibly subsequent &lt;code&gt;va_arg&lt;/code&gt; calls). The &lt;code&gt;vsprintf&lt;/code&gt; function does not invoke the &lt;code&gt;va_end&lt;/code&gt; macro. If copying takes place between objects that overlap, the behavior is undefined. The function returns the number of characters written into the array, not counting the terminating null character.


==References==
{{reflist}}

{{C Programming/Navigation|Error handling|Strings}}

[[fr:Programmation C/Entrées/sorties]]
[[pl:C/Czytanie i pisanie do plików]]</text>
      <sha1>h64jk5kba9p7ec3wvrj10wl6gghsxlx</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/String manipulation</title>
    <ns>0</ns>
    <id>8084</id>
    <revision>
      <id>3627751</id>
      <parentid>3627736</parentid>
      <timestamp>2019-12-18T19:10:31Z</timestamp>
      <contributor>
        <username>Mrjulesd</username>
        <id>1779740</id>
      </contributor>
      <comment>Rejected the last text change (by [[Special:Contributions/183.83.253.64|183.83.253.64]]) and restored revision 3622562 by 203.194.96.126</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="36695" xml:space="preserve">{{C Programming/Navigation|File IO|Further math}}

A '''string''' in C is merely an array of characters. The length of a string is determined by a terminating null character: &lt;code&gt;'\0'&lt;/code&gt;. So, a string with the contents, say, &lt;code&gt;"abc"&lt;/code&gt; has four characters: &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'b'&lt;/code&gt;, &lt;code&gt;'c'&lt;/code&gt;, and the terminating null (&lt;code&gt;'\0'&lt;/code&gt;) character.

The terminating null character has the value zero.


== Syntax ==
In C, string constants (literals) are surrounded by double quotes (&lt;tt&gt;"&lt;/tt&gt;), e.g. &lt;tt&gt;"Hello world!"&lt;/tt&gt; and are compiled to an array of the specified &lt;tt&gt;char&lt;/tt&gt; values with an additional null terminating character (0-valued) code to mark the end of the string. The type of a string constant is &lt;tt&gt;char []&lt;/tt&gt;.

=== backslash escapes ===

String literals may not directly in the source code contain embedded newlines or other control characters, or some other characters of special meaning in string.

To include such characters in a string, the backslash escapes may be used, like this:
{|
! align="left" |Escape
! align="left" |Meaning
|-
| &lt;tt&gt;\\&lt;/tt&gt; || Literal backslash
|-
| &lt;tt&gt;\"&lt;/tt&gt; || Double quote
|-
| &lt;tt&gt;\'&lt;/tt&gt; || Single quote
|-
| &lt;tt&gt;\n&lt;/tt&gt; || Newline (line feed)
|-
| &lt;tt&gt;\r&lt;/tt&gt; || Carriage return
|-
| &lt;tt&gt;\b&lt;/tt&gt; || Backspace
|-
| &lt;tt&gt;\t&lt;/tt&gt; || Horizontal tab
|-
| &lt;tt&gt;\f&lt;/tt&gt; || Form feed
|-
| &lt;tt&gt;\a&lt;/tt&gt; || Alert (bell)
|-
| &lt;tt&gt;\v&lt;/tt&gt; || Vertical tab
|-
| &lt;tt&gt;\?&lt;/tt&gt; || Question mark (used to escape [[../C trigraph/|trigraphs]])
|-
| &lt;tt&gt;\&lt;/tt&gt;''nnn'' || Character with octal value ''nnn''
|-
| &lt;tt&gt;\x&lt;/tt&gt;''hh'' || Character with hexadecimal value ''hh''
|}

===Wide character strings===
C supports wide character strings, defined as arrays of the type &lt;tt&gt;wchar_t&lt;/tt&gt;, 16-bit (at least) values. They are written with an L before the string like this
:&lt;tt&gt;wchar_t *p = L"Hello&lt;/tt&gt;&amp;nbsp;&lt;tt&gt;world!";&lt;/tt&gt;
This feature allows strings where more than 256 different possible characters are needed (although also variable length &lt;tt&gt;char&lt;/tt&gt; strings can be used). They end with a zero-valued &lt;tt&gt;wchar_t&lt;/tt&gt;. These strings are not supported by the &lt;tt&gt;&amp;lt;string.h&amp;gt;&lt;/tt&gt; functions. Instead they have their own functions, declared in &lt;tt&gt;&amp;lt;wchar.h&amp;gt;&lt;/tt&gt;.

===Character encodings===
What character encoding the &lt;tt&gt;char&lt;/tt&gt; and &lt;tt&gt;wchar_t&lt;/tt&gt; represent is not specified by the C standard, except that the value 0x00 and 0x0000 specify the end of the string and not a character. It is the input and output code which are directly affected by the character encoding. Other code should not be too affected. The editor should also be able to handle the encoding if strings shall be able to written in the source code.

There are three major types of encodings:
*One byte per character. Normally based on ASCII. There is a limit of 255 different characters plus the zero termination character.
*Variable length &lt;tt&gt;char&lt;/tt&gt; strings, which allows many more than 255 different characters. Such strings are written as normal &lt;tt&gt;char&lt;/tt&gt;-based arrays. These encodings are normally ASCII-based and examples are [[UTF-8]] or [[Shift JIS]].
*Wide character strings. They are arrays of &lt;tt&gt;wchar_t&lt;/tt&gt; values. [[UTF-16]] is the most common such encoding, and it is also variable-length, meaning that a character can be two &lt;tt&gt;wchar_t&lt;/tt&gt;.

== The &lt;code&gt;&lt;string.h&gt;&lt;/code&gt; Standard Header ==

Because programmers find raw strings cumbersome to deal with, they wrote the code in the &lt;code&gt;&lt;string.h&gt;&lt;/code&gt; library. It represents not a concerted design effort but rather the accretion of contributions made by various authors over a span of years.

First, three types of functions exist in the string library:

* the &lt;code&gt;mem&lt;/code&gt; functions manipulate sequences of arbitrary characters without regard to the null character;
* the &lt;code&gt;str&lt;/code&gt; functions manipulate null-terminated sequences of characters;
* the &lt;code&gt;strn&lt;/code&gt; functions manipulate sequences of non-null characters.

=== The more commonly-used string functions ===

The nine most commonly used functions in the string library are:

* &lt;code&gt;strcat&lt;/code&gt; - concatenate two strings
* &lt;code&gt;strchr&lt;/code&gt; - string scanning operation
* &lt;code&gt;strcmp&lt;/code&gt; - compare two strings
* &lt;code&gt;strcpy&lt;/code&gt; - copy a string
* &lt;code&gt;strlen&lt;/code&gt; - get string length
* &lt;code&gt;strncat&lt;/code&gt; - concatenate one string with part of another
* &lt;code&gt;strncmp&lt;/code&gt; - compare parts of two strings
* &lt;code&gt;strncpy&lt;/code&gt; - copy part of a string
* &lt;code&gt;strrchr&lt;/code&gt; - string scanning operation

Other functions, such as &lt;code&gt;strlwr&lt;/code&gt; (convert to lower case), &lt;code&gt;strrev&lt;/code&gt; (return the string reversed), and &lt;code&gt;strupr&lt;/code&gt; (convert to upper case) may be popular; however, they are neither specified by the C Standard nor the Single Unix Standard. It is also unspecified whether these functions return copies of the original strings or convert the strings in place.

==== The &lt;code&gt;strcat&lt;/code&gt; function ====
&lt;source lang="C"&gt;
char *strcat(char * restrict s1, const char * restrict s2);
&lt;/source&gt;

''Some people recommend using'' &lt;code&gt;strncat()&lt;/code&gt; ''or'' &lt;code&gt;strlcat()&lt;/code&gt; ''instead of strcat, in order to avoid buffer overflow.''

The &lt;code&gt;strcat()&lt;/code&gt; function shall append a copy of the string pointed to by &lt;code&gt;s2&lt;/code&gt; (including the terminating null byte) to the end of the string pointed to by &lt;code&gt;s1&lt;/code&gt;. The initial byte of &lt;code&gt;s2&lt;/code&gt; overwrites the null byte at the end of &lt;code&gt;s1&lt;/code&gt;. If copying takes place between objects that overlap, the behavior is undefined. The function returns &lt;code&gt;s1&lt;/code&gt;.

This function is used to attach one string to the end of another string. It is imperative that the first string (&lt;code&gt;s1&lt;/code&gt;) have the space needed to store both strings.
{{NOTE
|The &lt;code&gt;[[w:Restrict|restrict]]&lt;/code&gt; requirement on the arguments has been added in the [[w:C99 Standard|C99 standard]].}}

Example:
&lt;source lang=c&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    ...
    static const char *colors[] = {"Red","Orange","Yellow","Green","Blue","Purple" };
    static const char *widths[] = {"Thin","Medium","Thick","Bold" };
    ...
    char penText[20];
    ...
    int penColor = 3, penThickness = 2;
    strcpy(penText, colors[penColor]);
    strcat(penText, widths[penThickness]);
    printf("My pen is %s\n", penText); /* prints 'My pen is GreenThick' */
&lt;/source&gt;

Before calling &lt;code&gt;strcat()&lt;/code&gt;, the destination must currently contain a null terminated string or the first character must have been initialized with the null character (e.g. &lt;code&gt;penText[0] = '\0';&lt;/code&gt;).

The following is a public-domain implementation of &lt;code&gt;strcat&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strcat */
 char *(strcat)(char *restrict s1, const char *restrict s2)
 {
     char *s = s1;
     /* Move s so that it points to the end of s1.  */
     while (*s != '\0')
         s++;
     /* Copy the contents of s2 into the space at the end of s1.  */
     strcpy(s, s2);
     return s1;
 }
&lt;/source&gt;

==== The &lt;code&gt;strchr&lt;/code&gt; function ====
&lt;source lang="C"&gt;
char *strchr(const char *s, int c);
&lt;/source&gt;

The &lt;code&gt;strchr()&lt;/code&gt; function shall locate the first occurrence of &lt;code&gt;c&lt;/code&gt; (converted to a &lt;code&gt;char&lt;/code&gt;) in the string pointed to by &lt;code&gt;s&lt;/code&gt;. The terminating null byte is considered to be part of the string. The function returns the location of the found character, or a null pointer if the character was not found.

This function is used to find certain characters in strings.

At one point in history, this function was named &lt;code&gt;index&lt;/code&gt;. The &lt;code&gt;strchr&lt;/code&gt; name, however cryptic, fits the general pattern for naming.

The following is a public-domain implementation of &lt;code&gt;strchr&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strchr */
 char *(strchr)(const char *s, int c)
 {
     char ch = c;
     /* Scan s for the character.  When this loop is finished,
        s will either point to the end of the string or the
        character we were looking for.  */
     while (*s != '\0' &amp;&amp; *s != ch)
         s++;
     return (*s == ch) ? (char *) s : NULL;
 }
&lt;/source&gt;

==== The &lt;code&gt;strcmp&lt;/code&gt; function ====
&lt;source lang="C"&gt;int strcmp(const char *s1, const char *s2);&lt;/source&gt;

A rudimentary form of string comparison is done with the strcmp() function. It takes two strings as arguments and returns a value less than zero if the first is lexographically less than the second, a value greater than zero if the first is lexographically greater than the second, or zero if the two strings are equal. The comparison is done by comparing the coded (ascii) value of the characters, character by character.

This simple type of string comparison is nowadays generally considered unacceptable when sorting lists of strings.
More advanced algorithms exist that are capable of producing lists in dictionary sorted order. They can also fix problems such as strcmp() considering the string "Alpha2" greater than "Alpha12". (In the previous example, "Alpha2" compares greater than "Alpha12" because '2' comes after '1' in the character set.) What we're saying is, don't use this &lt;code&gt;strcmp()&lt;/code&gt; alone for general string sorting in any commercial or professional code.

The &lt;code&gt;strcmp()&lt;/code&gt; function shall compare the string pointed to by &lt;code&gt;s1&lt;/code&gt; to the string pointed to by &lt;code&gt;s2&lt;/code&gt;.  The sign of a non-zero return value shall be determined by the sign of the difference between the values of the first pair of bytes (both interpreted as type &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared. Upon completion, &lt;code&gt;strcmp()&lt;/code&gt; shall return an integer greater than, equal to, or less than 0, if the string pointed to by &lt;code&gt;s1&lt;/code&gt; is greater than, equal to, or less than the string pointed to by &lt;code&gt;s2&lt;/code&gt;, respectively.

Since comparing pointers by themselves is not practically useful unless one is comparing pointers within the same array, this function lexically compares the strings that two pointers point to.

This function is useful in comparisons, e.g.

 if (strcmp(s, "whatever") == 0) /* do something */
     ;

The collating sequence used by &lt;code&gt;strcmp()&lt;/code&gt; is equivalent to the machine's native character set. The only guarantee about the order is that the digits from &lt;tt&gt;'0'&lt;/tt&gt; to &lt;tt&gt;'9'&lt;/tt&gt; are in consecutive order.

The following is a public-domain implementation of &lt;code&gt;strcmp&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strcmp */
 int (strcmp)(const char *s1, const char *s2)
 {
     unsigned char uc1, uc2;
     /* Move s1 and s2 to the first differing characters 
        in each string, or the ends of the strings if they
        are identical.  */
     while (*s1 != '\0' &amp;&amp; *s1 == *s2) {
         s1++;
         s2++;
     }
     /* Compare the characters as unsigned char and
        return the difference.  */
     uc1 = (*(unsigned char *) s1);
     uc2 = (*(unsigned char *) s2);
     return ((uc1 &lt; uc2) ? -1 : (uc1 &gt; uc2));
 }
&lt;/source&gt;

==== The &lt;code&gt;strcpy&lt;/code&gt; function ====
&lt;source lang="C"&gt;char *strcpy(char *restrict s1, const char *restrict s2);&lt;/source&gt;

''Some people recommend always using'' &lt;code&gt;strncpy()&lt;/code&gt; ''instead of strcpy, to avoid buffer overflow.''

The &lt;code&gt;strcpy()&lt;/code&gt; function shall copy the C string pointed to by &lt;code&gt;s2&lt;/code&gt; (including the terminating null byte) into the array pointed to by &lt;code&gt;s1&lt;/code&gt;. If copying takes place between objects that overlap, the behavior is undefined. The function returns &lt;code&gt;s1&lt;/code&gt;. There is no value used to indicate an error: if the arguments to &lt;code&gt;strcpy()&lt;/code&gt; are correct, and the destination buffer is large enough, the function will never fail.

Example:
&lt;source lang=c&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    /* ... */
    static const char *penType="round";
    /* ... */
    char penText[20];
    /* ... */
    strcpy(penText, penType);
&lt;/source&gt;

Important: You must ensure that the destination buffer (&lt;code&gt;s1&lt;/code&gt;) is able to contain all the characters in the source array, including the terminating null byte. Otherwise, &lt;code&gt;strcpy()&lt;/code&gt; will overwrite memory past the end of the buffer, causing a buffer overflow, which can cause the program to crash, or can be exploited by hackers to compromise the security of the computer.

The following is a public-domain implementation of &lt;code&gt;strcpy&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strcpy */
 char *(strcpy)(char *restrict s1, const char *restrict s2)
 {
     char *dst = s1;
     const char *src = s2;
     /* Do the copying in a loop.  */
     while ((*dst++ = *src++) != '\0')
         ;               /* The body of this loop is left empty. */
     /* Return the destination string.  */
     return s1;
 }
&lt;/source&gt;

==== The &lt;code&gt;strlen&lt;/code&gt; function ====
&lt;source lang="C"&gt;size_t strlen(const char *s);&lt;/source&gt;

The &lt;code&gt;strlen()&lt;/code&gt; function shall compute the number of bytes in the string to which &lt;code&gt;s&lt;/code&gt; points, not including the terminating null byte.
It returns the number of bytes in the string. No value is used to indicate an error.

The following is a public-domain implementation of &lt;code&gt;strlen&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strlen */
 size_t (strlen)(const char *s)
 {
     const char *p = s; /* pointer to character constant */
     /* Loop over the data in s.  */
     while (*p != '\0')
         p++;
     return (size_t)(p - s);
 }
&lt;/source&gt;

Note how the line
&lt;source lang="C"&gt;
  const char *p = s
&lt;/source&gt;
declares and initializes a pointer &lt;code&gt;p&lt;/code&gt; to an integer constant, i.e. &lt;code&gt;p&lt;/code&gt; cannot change the value it points to.

==== The &lt;code&gt;strncat&lt;/code&gt; function ====
&lt;source lang="C"&gt;char *strncat(char *restrict s1, const char *restrict s2, size_t n);&lt;/source&gt;

The &lt;code&gt;strncat()&lt;/code&gt; function shall append not more than &lt;code&gt;n&lt;/code&gt; bytes (a null byte and bytes that follow it are not appended) from the array pointed to by &lt;code&gt;s2&lt;/code&gt; to the end of the string pointed to by &lt;code&gt;s1&lt;/code&gt;. The initial byte of &lt;code&gt;s2&lt;/code&gt; overwrites the null byte at the end of &lt;code&gt;s1&lt;/code&gt;. A terminating null byte is always appended to the result. If copying takes place between objects that overlap, the behavior is undefined. The function returns &lt;code&gt;s1&lt;/code&gt;.

The following is a public-domain implementation of &lt;code&gt;strncat&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strncat */
 char *(strncat)(char *restrict s1, const char *restrict s2, size_t n)
 {
     char *s = s1;
     /* Loop over the data in s1.  */
     while (*s != '\0')
         s++;
     /* s now points to s1's trailing null character, now copy
        up to n bytes from s2 into s stopping if a null character
        is encountered in s2.
        It is not safe to use strncpy here since it copies EXACTLY n
        characters, NULL padding if necessary.  */
     while (n != 0 &amp;&amp; (*s = *s2++) != '\0') {
         n--;
         s++;
     }
     if (*s != '\0')
         *s = '\0';
     return s1;
 }
&lt;/source&gt;

==== The &lt;code&gt;strncmp&lt;/code&gt; function ====
&lt;source lang="C"&gt;int strncmp(const char *s1, const char *s2, size_t n);&lt;/source&gt;

The &lt;code&gt;strncmp()&lt;/code&gt; function shall compare not more than &lt;code&gt;n&lt;/code&gt; bytes (bytes that follow a null byte are not compared) from the array pointed to by &lt;code&gt;s1&lt;/code&gt; to the array pointed to by &lt;code&gt;s2&lt;/code&gt;. The sign of a non-zero return value is determined by the sign of the difference between the values of the first pair of bytes (both interpreted as type &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared. See &lt;code&gt;strcmp&lt;/code&gt; for an explanation of the return value.

This function is useful in comparisons, as the &lt;code&gt;strcmp&lt;/code&gt; function is.

The following is a public-domain implementation of &lt;code&gt;strncmp&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strncmp */
 int (strncmp)(const char *s1, const char *s2, size_t n)
 {
     unsigned char uc1, uc2;
     /* Nothing to compare?  Return zero.  */
     if (n == 0)
         return 0;
     /* Loop, comparing bytes.  */
     while (n-- &gt; 0 &amp;&amp; *s1 == *s2) {
         /* If we've run out of bytes or hit a null, return zero
            since we already know *s1 == *s2.  */
         if (n == 0 || *s1 == '\0')
             return 0;
         s1++;
         s2++;
     }
     uc1 = (*(unsigned char *) s1);
     uc2 = (*(unsigned char *) s2);
     return ((uc1 &lt; uc2) ? -1 : (uc1 &gt; uc2));
 }
&lt;/source&gt;

==== The &lt;code&gt;strncpy&lt;/code&gt; function ====
&lt;source lang="C"&gt;char *strncpy(char *restrict s1, const char *restrict s2, size_t n);&lt;/source&gt;

The &lt;code&gt;strncpy()&lt;/code&gt; function shall copy not more than &lt;code&gt;n&lt;/code&gt; bytes (bytes that follow a null byte are not copied) from the array pointed to by &lt;code&gt;s2&lt;/code&gt; to the array pointed to by &lt;code&gt;s1&lt;/code&gt;. If copying takes place between objects that overlap, the behavior is undefined. If the array pointed to by &lt;code&gt;s2&lt;/code&gt; is a string that is shorter than &lt;code&gt;n&lt;/code&gt; bytes, null bytes shall be appended to the copy in the array pointed to by &lt;code&gt;s1&lt;/code&gt;, until &lt;code&gt;n&lt;/code&gt; bytes in all are written. The function shall return s1; no return value is reserved to indicate an error.

It is possible that the function will &lt;b&gt;not&lt;/b&gt; return a null-terminated string, which happens if the &lt;code&gt;s2&lt;/code&gt; string is longer than &lt;code&gt;n&lt;/code&gt; bytes.

The following is a public-domain version of &lt;code&gt;strncpy&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strncpy */
 char *(strncpy)(char *restrict s1, const char *restrict s2, size_t n)
 {
     char *dst = s1;
     const char *src = s2;
     /* Copy bytes, one at a time.  */
     while (n &gt; 0) {
         n--;
         if ((*dst++ = *src++) == '\0') {
             /* If we get here, we found a null character at the end
                of s2, so use memset to put null bytes at the end of
                s1.  */
             memset(dst, '\0', n);
             break;
         }
     }
     return s1;
 }
&lt;/source&gt;

==== The &lt;code&gt;strrchr&lt;/code&gt; function ====
&lt;source lang="C"&gt;char *strrchr(const char *s, int c);&lt;/source&gt;

The &lt;code&gt;strrchr&lt;/code&gt; function is similar to the &lt;code&gt;strchr&lt;/code&gt; function, except that &lt;code&gt;strrchr&lt;/code&gt; returns a pointer to the &lt;b&gt;last&lt;/b&gt; occurrence of &lt;code&gt;c&lt;/code&gt; within &lt;code&gt;s&lt;/code&gt; instead of the first.

The &lt;code&gt;strrchr()&lt;/code&gt; function shall locate the last occurrence of &lt;code&gt;c&lt;/code&gt; (converted to a &lt;code&gt;char&lt;/code&gt;) in the string pointed to by &lt;code&gt;s&lt;/code&gt;. The terminating null byte is considered to be part of the string. Its return value is similar to &lt;code&gt;strchr&lt;/code&gt;'s return value.

At one point in history, this function was named &lt;code&gt;rindex&lt;/code&gt;. The &lt;code&gt;strrchr&lt;/code&gt; name, however cryptic, fits the general pattern for naming.

The following is a public-domain implementation of &lt;code&gt;strrchr&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strrchr */
 char *(strrchr)(const char *s, int c)
 {
     const char *last = NULL;
     /* If the character we're looking for is the terminating null,
        we just need to look for that character as there's only one
        of them in the string.  */
     if (c == '\0')
         return strchr(s, c);
     /* Loop through, finding the last match before hitting NULL.  */
     while ((s = strchr(s, c)) != NULL) {
         last = s;
         s++;
     }
     return (char *) last;
 }
&lt;/source&gt;

=== The less commonly-used string functions ===

The less-used functions are:

* &lt;code&gt;memchr&lt;/code&gt; - Find a byte in memory
* &lt;code&gt;memcmp&lt;/code&gt; - Compare bytes in memory
* &lt;code&gt;memcpy&lt;/code&gt; - Copy bytes in memory
* &lt;code&gt;memmove&lt;/code&gt; - Copy bytes in memory with overlapping areas
* &lt;code&gt;memset&lt;/code&gt; - Set bytes in memory
* &lt;code&gt;strcoll&lt;/code&gt; - Compare bytes according to a locale-specific collating sequence
* &lt;code&gt;strcspn&lt;/code&gt; - Get the length of a complementary substring
* &lt;code&gt;strerror&lt;/code&gt; - Get error message
* &lt;code&gt;strpbrk&lt;/code&gt; - Scan a string for a byte
* &lt;code&gt;strspn&lt;/code&gt; - Get the length of a substring
* &lt;code&gt;strstr&lt;/code&gt; - Find a substring
* &lt;code&gt;strtok&lt;/code&gt; - Split a string into tokens
* &lt;code&gt;strxfrm&lt;/code&gt; - Transform string 

==== Copying functions ====

===== The &lt;code&gt;memcpy&lt;/code&gt; function =====
&lt;source lang="C"&gt;void *memcpy(void * restrict s1, const void * restrict s2, size_t n);&lt;/source&gt;

The &lt;code&gt;memcpy()&lt;/code&gt; function shall copy &lt;code&gt;n&lt;/code&gt; bytes from the object pointed to by &lt;code&gt;s2&lt;/code&gt; into the object pointed to by &lt;code&gt;s1&lt;/code&gt;. If copying takes place between objects that overlap, the behavior is undefined. The function returns &lt;code&gt;s1&lt;/code&gt;.

Because the function does not have to worry about overlap, it can do the simplest copy it can.

The following is a public-domain implementation of &lt;code&gt;memcpy&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* memcpy */
 void *(memcpy)(void * restrict s1, const void * restrict s2, size_t n)
 {
     char *dst = s1;
     const char *src = s2;
     /* Loop and copy.  */
     while (n-- != 0)
         *dst++ = *src++;
     return s1;
 }
&lt;/source&gt;

===== The &lt;code&gt;memmove&lt;/code&gt; function =====
&lt;source lang="C"&gt;void *memmove(void *s1, const void *s2, size_t n);&lt;/source&gt;

The &lt;code&gt;memmove()&lt;/code&gt; function shall copy &lt;code&gt;n&lt;/code&gt; bytes from the object pointed to by &lt;code&gt;s2&lt;/code&gt; into the object pointed to by &lt;code&gt;s1&lt;/code&gt;. Copying takes place as if the &lt;code&gt;n&lt;/code&gt; bytes from the object pointed to by &lt;code&gt;s2&lt;/code&gt; are first copied into a temporary array of &lt;code&gt;n&lt;/code&gt; bytes that does not overlap the objects pointed to by &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, and then the &lt;code&gt;n&lt;/code&gt; bytes from the temporary array are copied into the object pointed to by &lt;code&gt;s1&lt;/code&gt;. The function returns the value of &lt;code&gt;s1&lt;/code&gt;.

The easy way to implement this without using a temporary array is to check for a condition that would prevent an ascending copy, and if found, do a descending copy.

The following is a public-domain, though not completely portable, implementation of &lt;code&gt;memmove&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* memmove */
 void *(memmove)(void *s1, const void *s2, size_t n) 
 {
    /* note: these don't have to point to unsigned chars */
    char *p1 = s1;
    const char *p2 = s2;
    /* test for overlap that prevents an ascending copy */
    if (p2 &lt; p1 &amp;&amp; p1 &lt; p2 + n) {
        /* do a descending copy */
        p2 += n;
        p1 += n;
        while (n-- != 0) 
            *--p1 = *--p2;
    } else 
        while (n-- != 0) 
            *p1++ = *p2++;
    return s1; 
 }
&lt;/source&gt;

==== Comparison functions ====

===== The &lt;code&gt;memcmp&lt;/code&gt; function =====
&lt;source lang="C"&gt;int memcmp(const void *s1, const void *s2, size_t n);&lt;/source&gt;

The &lt;code&gt;memcmp()&lt;/code&gt; function shall compare the first &lt;code&gt;n&lt;/code&gt; bytes (each interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) of the object pointed to by &lt;code&gt;s1&lt;/code&gt; to the first &lt;code&gt;n&lt;/code&gt; bytes of the object pointed to by &lt;code&gt;s2&lt;/code&gt;. The sign of a non-zero return value shall be determined by the sign of the difference between the values of the first pair of bytes (both interpreted as type &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.

The following is a public-domain implementation of &lt;code&gt;memcmp&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* memcmp */
 int (memcmp)(const void *s1, const void *s2, size_t n)
 {
     const unsigned char *us1 = (const unsigned char *) s1;
     const unsigned char *us2 = (const unsigned char *) s2;
     while (n-- != 0) {
         if (*us1 != *us2)
             return (*us1 &lt; *us2) ? -1 : +1;
         us1++;
         us2++;
     }
     return 0;
 }
&lt;/source&gt;

===== The &lt;code&gt;strcoll&lt;/code&gt; and &lt;code&gt;strxfrm&lt;/code&gt; functions =====
&lt;source lang="C"&gt;int strcoll(const char *s1, const char *s2);&lt;/source&gt;

&lt;code&gt;size_t strxfrm(char *s1, const char *s2, size_t n);&lt;/code&gt;

The ANSI C Standard specifies two locale-specific comparison functions.

The &lt;code&gt;strcoll&lt;/code&gt; function compares the string pointed to by &lt;code&gt;s1&lt;/code&gt; to the string pointed to by &lt;code&gt;s2&lt;/code&gt;, both interpreted as appropriate to the &lt;code&gt;LC_COLLATE&lt;/code&gt; category of the current locale. The return value is similar to &lt;code&gt;strcmp&lt;/code&gt;.

The &lt;code&gt;strxfrm&lt;/code&gt; function transforms the string pointed to by &lt;code&gt;s2&lt;/code&gt; and places the resulting string into the array pointed to by &lt;code&gt;s1&lt;/code&gt;. The transformation is such that if the &lt;code&gt;strcmp&lt;/code&gt; function is applied to the two transformed strings, it returns a value greater than, equal to, or less than zero, corresponding to the result of the &lt;code&gt;strcoll&lt;/code&gt; function applied to the same two original strings. No more than &lt;code&gt;n&lt;/code&gt; characters are placed into the resulting array pointed to by &lt;code&gt;s1&lt;/code&gt;, including the terminating null character. If &lt;code&gt;n&lt;/code&gt; is zero, &lt;code&gt;s1&lt;/code&gt; is permitted to be a null pointer. If copying takes place between objects that overlap, the behavior is undefined. The function returns the length of the transformed string.

These functions are rarely used and nontrivial to code, so there is no code for this section.

==== Search functions ====

===== The &lt;code&gt;memchr&lt;/code&gt; function =====
&lt;source lang="C"&gt;void *memchr(const void *s, int c, size_t n);&lt;/source&gt;

The &lt;code&gt;memchr()&lt;/code&gt; function shall locate the first occurrence of &lt;code&gt;c&lt;/code&gt; (converted to an &lt;code&gt;unsigned char&lt;/code&gt;) in the initial &lt;code&gt;n&lt;/code&gt; bytes (each interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) of the object pointed to by &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is not found, &lt;code&gt;memchr&lt;/code&gt; returns a null pointer.

The following is a public-domain implementation of &lt;code&gt;memchr&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* memchr */
 void *(memchr)(const void *s, int c, size_t n)
 {
     const unsigned char *src = s;
     unsigned char uc = c;
     while (n-- != 0) {
         if (*src == uc)
             return (void *) src;
         src++;
     }
     return NULL;
 }

&lt;/source&gt;

===== The &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, and &lt;code&gt;strspn&lt;/code&gt; functions =====
&lt;source lang="C"&gt;size_t strcspn(const char *s1, const char *s2);&lt;/source&gt;

&lt;source lang="C"&gt;char *strpbrk(const char *s1, const char *s2);&lt;/source&gt;

&lt;source lang="C"&gt;size_t strspn(const char *s1, const char *s2);&lt;/source&gt;

The &lt;code&gt;strcspn&lt;/code&gt; function computes the length of the maximum initial segment of the string pointed to by &lt;code&gt;s1&lt;/code&gt; which consists entirely of characters &lt;b&gt;not&lt;/b&gt; from the string pointed to by &lt;code&gt;s2&lt;/code&gt;.

The &lt;code&gt;strpbrk&lt;/code&gt; function locates the first occurrence in the string pointed to by &lt;code&gt;s1&lt;/code&gt; of any character from the string pointed to by &lt;code&gt;s2&lt;/code&gt;, returning a pointer to that character or a null pointer if not found.

The &lt;code&gt;strspn&lt;/code&gt; function computes the length of the maximum initial segment of the string pointed to by &lt;code&gt;s1&lt;/code&gt; which consists entirely of characters from the string pointed to by &lt;code&gt;s2&lt;/code&gt;.

All of these functions are similar except in the test and the return value.

The following are public-domain implementations of &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, and &lt;code&gt;strspn&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strcspn */
 size_t (strcspn)(const char *s1, const char *s2)
 {
     const char *sc1;
     for (sc1 = s1; *sc1 != '\0'; sc1++)
         if (strchr(s2, *sc1) != NULL)
             return (sc1 - s1);
     return sc1 - s1;            /* terminating nulls match */
 }
&lt;/source&gt;

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strpbrk */
 char *(strpbrk)(const char *s1, const char *s2)
 {
     const char *sc1;
     for (sc1 = s1; *sc1 != '\0'; sc1++)
         if (strchr(s2, *sc1) != NULL)
             return (char *)sc1;
     return NULL;                /* terminating nulls match */
 }
&lt;/source&gt;

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strspn */
 size_t (strspn)(const char *s1, const char *s2)
 {
     const char *sc1;
     for (sc1 = s1; *sc1 != '\0'; sc1++)
         if (strchr(s2, *sc1) == NULL)
             return (sc1 - s1);
     return sc1 - s1;            /* terminating nulls don't match */
 }
&lt;/source&gt;

===== The &lt;code&gt;strstr&lt;/code&gt; function =====
&lt;source lang="C"&gt;char *strstr(const char *haystack, const char *needle);&lt;/source&gt;

The &lt;code&gt;strstr()&lt;/code&gt; function shall locate the first occurrence in the string pointed to by &lt;code&gt;haystack&lt;/code&gt; of the sequence of bytes (excluding the terminating null byte) in the string pointed to by &lt;code&gt;needle&lt;/code&gt;. The function returns the pointer to the matching string in &lt;code&gt;haystack&lt;/code&gt; or a null pointer if a match is not found. If &lt;code&gt;needle&lt;/code&gt; is an empty string, the function returns &lt;code&gt;haystack&lt;/code&gt;.

The following is a public-domain implementation of &lt;code&gt;strstr&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strstr */
 char *(strstr)(const char *haystack, const char *needle)
 {
     size_t needlelen;
     /* Check for the null needle case.  */
     if (*needle == '\0')
         return (char *) haystack;
     needlelen = strlen(needle);
     for (; (haystack = strchr(haystack, *needle)) != NULL; haystack++)
         if (memcmp(haystack, needle, needlelen) == 0)
             return (char *) haystack;
     return NULL;
 }
&lt;/source&gt;

===== The &lt;code&gt;strtok&lt;/code&gt; function =====
&lt;source lang="C"&gt;char *strtok(char *restrict s1, const char *restrict delimiters);&lt;/source&gt;

A sequence of calls to &lt;code&gt;strtok()&lt;/code&gt; breaks the string pointed to by &lt;code&gt;s1&lt;/code&gt; into a sequence of tokens, each of which is delimited by a byte from the string pointed to by &lt;code&gt;delimiters&lt;/code&gt;. The first call in the sequence has &lt;code&gt;s1&lt;/code&gt; as its first argument, and is followed by calls with a null pointer as their first argument. The separator string pointed to by &lt;code&gt;delimiters&lt;/code&gt; may be different from call to call.

The first call in the sequence searches the string pointed to by &lt;code&gt;s1&lt;/code&gt; for the first byte that is not contained in the current separator string pointed to by &lt;code&gt;delimiters&lt;/code&gt;. If no such byte is found, then there are no tokens in the string pointed to by &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;strtok()&lt;/code&gt; shall return a null pointer. If such a byte is found, it is the start of the first token.

The &lt;code&gt;strtok()&lt;/code&gt; function then searches from there for a byte (or multiple, consecutive bytes) that is contained in the current separator string. If no such byte is found, the current token extends to the end of the string pointed to by &lt;code&gt;s1&lt;/code&gt;, and subsequent searches for a token shall return a null pointer. If such a byte is found, it is overwritten by a null byte, which terminates the current token. The &lt;code&gt;strtok()&lt;/code&gt; function saves a pointer to the following byte, from which the next search for a token shall start.

Each subsequent call, with a null pointer as the value of the first argument, starts searching from the saved pointer and behaves as described above.

The &lt;code&gt;strtok()&lt;/code&gt; function need not be reentrant. A function that is not required to be reentrant is not required to be thread-safe.

Because the &lt;code&gt;strtok()&lt;/code&gt; function must save state between calls, and you could not have two tokenizers going at the same time, the Single Unix Standard defined a similar function, &lt;code&gt;strtok_r()&lt;/code&gt;, that does not need to save state. Its prototype is this:

&lt;code&gt;char *strtok_r(char *s, const char *delimiters, char **lasts);&lt;/code&gt;

The &lt;code&gt;strtok_r()&lt;/code&gt; function considers the null-terminated string &lt;code&gt;s&lt;/code&gt; as a sequence of zero or more text tokens separated by spans of one or more characters from the separator string &lt;code&gt;delimiters&lt;/code&gt;. The argument lasts points to a user-provided pointer which points to stored information necessary for &lt;code&gt;strtok_r()&lt;/code&gt; to continue scanning the same string.

In the first call to &lt;code&gt;strtok_r()&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; points to a null-terminated string, &lt;code&gt;delimiters&lt;/code&gt; to a null-terminated string of separator characters, and the value pointed to by &lt;code&gt;lasts&lt;/code&gt; is ignored. The &lt;code&gt;strtok_r()&lt;/code&gt; function shall return a pointer to the first character of the first token, write a null character into &lt;code&gt;s&lt;/code&gt; immediately following the returned token, and update the pointer to which &lt;code&gt;lasts&lt;/code&gt; points.

In subsequent calls, &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;lasts&lt;/code&gt; shall be unchanged from the previous call so that subsequent calls shall move through the string &lt;code&gt;s&lt;/code&gt;, returning successive tokens until no tokens remain. The separator string &lt;code&gt;delimiters&lt;/code&gt; may be different from call to call. When no token remains in &lt;code&gt;s&lt;/code&gt;, a NULL pointer shall be returned.

The following public-domain code for &lt;code&gt;strtok&lt;/code&gt; and &lt;code&gt;strtok_r&lt;/code&gt; codes the former as a special case of the latter:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* strtok_r */
 char *(strtok_r)(char *s, const char *delimiters, char **lasts)
 {
     char *sbegin, *send;
     sbegin = s ? s : *lasts;
     sbegin += strspn(sbegin, delimiters);
     if (*sbegin == '\0') {
         *lasts = "";
         return NULL;
     }
     send = sbegin + strcspn(sbegin, delimiters);
     if (*send != '\0')
         *send++ = '\0';
     *lasts = send;
     return sbegin;
 }
 /* strtok */
 char *(strtok)(char *restrict s1, const char *restrict delimiters)
 {
     static char *ssave = "";
     return strtok_r(s1, delimiters, &amp;ssave);
 }
&lt;/source&gt;

==== Miscellaneous functions ====

These functions do not fit into one of the above categories.

===== The &lt;code&gt;memset&lt;/code&gt; function =====
&lt;source lang="C"&gt;void *memset(void *s, int c, size_t n);&lt;/source&gt;

The &lt;code&gt;memset()&lt;/code&gt; function converts &lt;code&gt;c&lt;/code&gt; into &lt;code&gt;unsigned char&lt;/code&gt;, then stores the character into the first &lt;code&gt;n&lt;/code&gt; bytes of memory pointed to by &lt;code&gt;s&lt;/code&gt;.

The following is a public-domain implementation of &lt;code&gt;memset&lt;/code&gt;:

&lt;source lang=c&gt;
 #include &lt;string.h&gt;
 /* memset */
 void *(memset)(void *s, int c, size_t n)
 {
     unsigned char *us = s;
     unsigned char uc = c;
     while (n-- != 0)
         *us++ = uc;
     return s;
 }
&lt;/source&gt;

===== The &lt;code&gt;strerror&lt;/code&gt; function =====
&lt;source lang="C"&gt;char *strerror(int errorcode);&lt;/source&gt;

This function returns a locale-specific error message corresponding to the parameter. Depending on the circumstances, this function could be trivial to implement, but this author will not do that as it varies.

The Single Unix System Version 3 has a variant, &lt;code&gt;strerror_r&lt;/code&gt;, with this prototype:

&lt;code&gt;int strerror_r(int errcode, char *buf, size_t buflen);&lt;/code&gt;

This function stores the message in &lt;code&gt;buf&lt;/code&gt;, which has a length of size &lt;code&gt;buflen&lt;/code&gt;.

== Examples ==

To determine the number of characters in a string, the &lt;code&gt;strlen()&lt;/code&gt; function is used:
&lt;source lang=c&gt;
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    ...
    int length, length2;
    char *turkey;
    static char *flower= "begonia";
    static char *gemstone="ruby ";
    
    length = strlen(flower);
    printf("Length = %d\n", length); // prints 'Length = 7'
    length2 = strlen(gemstone);
    
    turkey = malloc( length + length2 + 1);
    if (turkey) {
      strcpy( turkey, gemstone);
      strcat( turkey, flower);
      printf( "%s\n", turkey); // prints 'ruby begonia'
      free( turkey );
    }
&lt;/source&gt;

Note that the amount of memory allocated for 'turkey' is one plus the sum of the lengths of the strings to be concatenated. This is for the terminating null character, which is not counted in the lengths of the strings.

=== Exercises ===
# The string functions use a lot of looping constructs. Is there some way to portably unravel the loops?
# What functions are possibly missing from the library as it stands now?

== References ==

* [[A Little C Primer/C String Function Library]]
* [[C++ Programming/Code/IO/Streams/string]]
* Because so many functions in the standard &lt;code&gt;string.h&lt;/code&gt; library are vulnerable to buffer overflow errors, [http://www.and.org/vstr/security some people] recommend avoiding the &lt;code&gt;string.h&lt;/code&gt; library and "C style strings" and instead using a dynamic string API, such as the ones listed in the [http://www.and.org/vstr/comparison String library comparison].
* There's a tiny [http://openwall.info/wiki/people/solar/software/public-domain-source-code/concat public domain concat() function, which will allocate memory and safely concatenate any number of strings in portable C/C++ code]

{{C Programming/Navigation|File IO|Further math}}

[[fr:Programmation C/Chaînes de caractères]]
[[pl:C/Napisy]]
[[pt:Programar em C/Strings]]</text>
      <sha1>lzgygzpn9v4og5uwvwlrd2hmbvyfev6</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Structure and style</title>
    <ns>0</ns>
    <id>19253</id>
    <revision>
      <id>3535693</id>
      <parentid>3535692</parentid>
      <timestamp>2019-04-06T21:21:43Z</timestamp>
      <contributor>
        <username>Dhiegov</username>
        <id>3218450</id>
      </contributor>
      <comment>/* Blank Lines */ Change "precompiler declarations" to "preprocessor directives", since the former was not said until then and they seem to reffer to the same thing</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14421" xml:space="preserve">{{C Programming/Navigation|Compiling|Variables}}

==C Structure and Style==
This is a basic introduction to good coding style in the C Programming Language. It is designed to provide information on how to effectively use indentation, comments, and other elements that will make your C code more readable. It is not a tutorial on actual C programming.

As a beginning programmer, the point of creating structure in the program code might not be clear, as the compiler doesn't care about the difference. However, as programs become complex, chances are that writing the program has become a joint effort. (Or others might want to see how it was accomplished. Or you may have to read it again years later.) Well-written code also helps you get an overview of what the code does.

In the following sections, we will attempt to explain good programming practices that will in turn make your programs clearer.

== Introduction ==
In C, programs are composed of statements. Statements are terminated with a semi-colon, and are collected in sections known as functions.  By convention, a statement should be kept on its own line, as shown in the example below: 

&lt;source lang="c"&gt;
 #include &lt;stdio.h&gt;
  
 int main(void) {
 	printf("Hello, World!\n");
 	return 0;
 }
&lt;/source&gt;

The following block of code is essentially the same. While it contains exactly the same code, and will compile and execute with the same result, the removal of spacing causes an essential difference: it's harder to read.

&lt;source lang="c"&gt;
 #include &lt;stdio.h&gt;
 int main(void) {printf("Hello, World!\n");return 0;}
&lt;/source&gt;

The simple use of indents and line breaks can greatly improve code readability without impacting code performance. Readable code makes it much easier to see where functions and procedures end and which lines are part of which loops and procedures.

This lesson is going to focus on improving the coding style of an example piece of code which applies a formula and prints the result. Later, you'll see how to write code for such tasks in more detail. For now, focus on how the code looks, not what it does.

== Line Breaks and Indentation ==
The addition of white space inside your code is arguably the most important part of good code structure.  Effective use of white space can create a visual scale of how your code flows, which can be very important when returning to your code when you want to maintain it.

=== Line Breaks ===
{{Warning|Note the use of line numbers. They are '''not''' part of the actual code.  They are '''only''' for reference.}}
With minimal line breaks, code is barely human-readable, and may be hard to debug or understand:

&lt;source lang="c" line&gt;
#include &lt;stdio.h&gt;
int main(void) { int revenue = 80; int cost = 50; int roi; roi = (100 * (revenue - cost)) / cost; if (roi &gt;= 0) { printf ("%d\n", roi); } return 0; }
&lt;/source&gt;

Rather than putting everything on one line, it is much more readable to break up long lines so that each statement and declaration goes on its own line.  After inserting line breaks, the code will look like this: 

&lt;source lang="c" line&gt;
#include &lt;stdio.h&gt;
int main(void) {
int revenue = 80;
int cost = 50;
int roi;
roi = (100 * (revenue - cost)) / cost;
if (roi &gt;= 0) {
printf ("%d\n", roi);
}
return 0;
}
&lt;/source&gt;

=== Blank Lines ===

Blank lines should be used to offset the main components of your code.  Always use them 
*After preprocessor directives.
*After new variables are declared.
*Use your own judgment for finding other places where components should be separated.

Based on these two rules, there should now be at least two line breaks added.
*After line 1, because line 1 has a preprocessor directive.
*After line 5, because line 5 contains a variable declaration.
This will make the code much more readable than it was before:

The following lines of code have line breaks between functions, but without indentation.

&lt;source lang="c" line&gt;
#include &lt;stdio.h&gt;

int main(void) {

int revenue = 80;
int cost = 50;

int roi;

roi = (100 * (revenue - cost)) / cost;

if (roi &gt;= 0) {
printf ("%d\n", roi);
}

return 0;
}
&lt;/source&gt;
  
But it's still not as readable as it can be.

=== Indentation ===

{{Side note|side=right|&lt;small&gt;Many text editors automatically indent appropriately when you hit the enter/return key.&lt;/small&gt;}}
Although adding simple line breaks between key blocks of code can make code easier to read, it provides no information about the block structure of the program.  Using the tab key can be very helpful. Indentation visually separates paths of execution by moving their starting points to a new column.  This simple practice will make it much easier to read and understand code. Indentation follows a fairly simple rule:

*All code inside a new block should be indented by one tab&lt;ref&gt;

Several programmers recommend "use spaces for indentation. Do not use tabs in your code. You should set your editor to emit spaces when you hit the tab key." [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml] [http://www.jwz.org/doc/tabs-vs-spaces.html]  

Other programmers disagree. [http://web.archive.org/20080118165124/diagrammes-modernes.blogspot.com/2006/04/tab-versus-spaces.html] [http://www.derkarl.org/why_to_tabs.html]

Regardless of whether you prefer spaces or tabs, make sure you keep it consistent within the projects you are working on. Mixing tabs and spaces can cause code to become unreadable.
&lt;/ref&gt; more than the code in the previous path.

Based on the code from the previous section, there are two blocks requiring indentation:

*Lines 4 to 16
*Line 13

&lt;source lang="c" line&gt;
#include &lt;stdio.h&gt;

int main(void) {

    int revenue = 80;
    int cost = 50;

    int roi;

    roi = (100 * (revenue - cost)) / cost;

    if (roi &gt;= 0) {
        printf ("%d\n", roi);
    }

    return 0;
}
&lt;/source&gt;

It is now fairly obvious as to which parts of the program fit inside which blocks.  You can tell which parts of the program the coder has intended to be conditional, and which ones he or she has not.  Although it might not be immediately noticeable, once many nested paths get added to the structure of the program, the use of indentation can be very important. Thus, indentation makes the structure of your program clear.

It is claimed that research has shown that an indentation size between 2 to 4 characters is easier to read than 8 character indents&lt;ref name="rice"&gt;http://www.oualline.com/vim/vim-cook.html#drawing Vim cookbook&lt;/ref&gt;. However, an indent of 8 characters may still be in use for some systems&lt;ref name="linuxkernel"&gt;https://www.kernel.org/doc/html/latest/process/coding-style.html Linux Kernel Coding Style&lt;/ref&gt;.

== Comments ==

Comments in code can be useful for a variety of purposes.  They provide the easiest way to set off specific parts of code (and their purpose); as well as providing a visual "split" between various parts of your code.  Having good comments throughout your code will make it much easier to remember what specific parts of your code do.

Comments in modern flavors of C (and many other languages) can come in two forms:

&lt;source lang="c" line&gt;//Single Line Comments  (added by C99 standard, famously known as c++ style of comments)&lt;/source&gt;
and
&lt;source lang="c" line&gt;
/*Multi-Line
Comments
(only form of comments supported by C89 standard)*/
&lt;/source&gt;

Note that Single line comments are a more recent addition to C, so some compilers may not support them.  A recent version of [[Wikipedia:GNU Compiler Collection|GCC]] will have no problems supporting them.

This section is going to focus on the various uses of each form of commentary.

=== Single-line Comments ===

Single-line comments are most useful for simple 'side' notes that explain what certain parts of the code do.  The best places to put these comments are next to variable declarations, and next to pieces of code that may need explanation.  Comments should make clear the intention and ideas behind the corresponding code.  What is immediately obvious from reading the code does not belong in a comment.

Based on our previous program, there are various good places to place comments
*Line 5 and/or 6, to explain what 'int revenue' and 'int cost' represent,
*Line 8, to explain what the variable 'roi' is going to be used for,
*Line 10, to explain the idea of the calculation,
*Line 12, to explain the purpose of the 'if'.

This will make our program look something like

&lt;source lang="c"&gt;
#include &lt;stdio.h&gt;

int main(void) {

    int revenue = 80;               // as of 2016
    int cost = 50;

    int roi;                        // return on investment in percent

    roi = (100 * (revenue - cost)) / cost;  // formula from accounting book

    if (roi &gt;= 0) {                 // we don't care about negative roi
        printf ("%d\n", roi);
    }

    return 0;
}
&lt;/source&gt;

=== Multi-line Comments ===

{{Side note|side=right|&lt;small&gt;Single-line comments are a new feature, so many C programmers only use multi-line comments.&lt;/small&gt;}}
Multi-line comments are most useful for long explanations of code.  They can be used as copyright/licensing notices, and they can also be used to explain the purpose of a block of code.  This can be useful for two reasons: They make your functions easier to understand, and they make it easier to spot errors in code.  If you know what a block is ''supposed'' to do, then it is much easier to find the piece of code that is responsible if an error occurs.

As an example, suppose we had a program that was designed to print "Hello, World! " a certain number of lines, a specified number of times.  There would be many for loops in this program.  For this example, we shall call the number of lines ''i'', and the number of strings per line as ''j''.

A good example of a multi-line comment that describes 'for' loop ''i'''s purpose would be:
&lt;source lang="c"&gt;
 /* For Loop (int i)
    Loops the following procedure i times (for number of lines).  Performs 'for' loop j on each loop,
    and prints a new line at end of each loop.
 */
&lt;/source&gt;

This provides a good explanation of what ''i'''s purpose is, whilst not going into detail of what ''j'' does.  By going into detail over what the specific path does (and not ones inside it), it will be easier to troubleshoot the path.

Similarly, you should always include a multi-line comment before each function, to explain the role, preconditions and postconditions of each function.    Always leave the technical details to the individual blocks inside your program - this makes it easier to troubleshoot.

A function descriptor should look something like:
&lt;source lang="c"&gt;
 /* Function : int hworld (int i,int j)
    Input    : int i (Number of lines), int j (Number of instances per line)
    Output   : 0 (on success)
    Procedure: Prints "Hello, World!" j times, and a new line to standard output over i lines.
 */
&lt;/source&gt;
This system allows for an at-a-glance explanation of what the function should do.  You can then go into detail over how each aspect of the program is achieved later on in the program.

Finally, if you like to have aesthetically-pleasing source code, the multi-line comment system allows for the easy addition of comment  boxes.  These make the comments stand out much more than they would without otherwise.  They look like this.
&lt;source lang="c"&gt;
 /***************************************
  *  This is a multi line comment
  *  That is nearly surrounded by a
  *  Cool, starry border!
  ***************************************/
&lt;/source&gt;

Applied to our original program, we can now include a much more descriptive and readable source code:

&lt;source lang="c"&gt;
#include &lt;stdio.h&gt;

int main(void){
    /************************************************************************************
     * Function: int main(void)
     * Input   : none
     * Output  : Returns 0 on success
     * Procedure: Prints 2016's return on investment in percent if it is not negative.
     ************************************************************************************/
    int revenue = 80;               // as of 2016
    int cost = 50;

    int roi;                        // return on investment in percent

    roi = (100 * (revenue - cost)) / cost;  // formula from accounting book

    if (roi &gt;= 0) {                 // we don't care about negative roi
        printf ("%d\n", roi);
    }

    return 0;
}
&lt;/source&gt;

This will allow any outside users of the program an easy way to comprehend what the code functions are and how they operate.  It also inhibits uncertainty with other like-named functions.

A few programmers add a column of stars on the right side of a block comment:
&lt;source lang="c"&gt;
 /***************************************
  *  This is a multi line comment       *
  *  that is completely surrounded by a *
  *  cool, starry border!               *
  ***************************************/
&lt;/source&gt;
But most programmers don't put any stars on the right side of a block comment.
They feel that aligning the right side is a waste of time.

Comments written in source files can be used for documenting source code automatically by using popular tools like Doxygen.&lt;ref&gt;[http://www.macadamian.com/index.php?option=com_content&amp;task=view&amp;id=34&amp;Itemid=37 "Coding Conventions for C++ and Java"] "all the block comments illustrated in this document have no pretty stars on the right side of the block comment. This deliberate choice was made because aligning those pretty stars is a large waste of time and discourages the maintenance of in-line comments.",&lt;/ref&gt;&lt;ref&gt;[[c2:BigBlocksOfAsterisks]],[http://books.google.com/books?id=i4zCzpkrt4sC&amp;pg=PA82&amp;lpg=PA82&amp;dq=programming+comment+block+waste+time+lining+up&amp;source=bl&amp;ots=TUpTMIHBnh&amp;sig=NeZm23WPmvnw2aKMnIRUeQoHmJg&amp;hl=en&amp;ei=pri3SevGIYGyNMn9jd4K&amp;sa=X&amp;oi=book_result&amp;resnum=8&amp;ct=result "Code craft"] by Pete Goodliffe page 82,[http://www.falvotech.com/content/publications/conventions/c/ Falvotech "C Programming Style Guide"],
[http://directory.fedoraproject.org/wiki/Coding_Style Fedora Directory Server Coding Style]&lt;/ref&gt;

== References ==
{{Reflist}}
*[http://www.cs.wisc.edu/~ghost/doc/AFPL/6.01/C-style.htm Aladdin's C coding guidelines] - A more definitive C coding guideline.
*[http://www.mycplus.com/category/tutorials/programming-styles/ C/C++ Programming Styles] GNU Coding styles &amp; Linux Kernel Coding style

[[et:Programmeerimiskeel C/Stiil]]
{{C Programming/Navigation|Compiling|Variables}}</text>
      <sha1>fbmaqpqgfv35net0vfs7ahvjg8htjjv</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Variables</title>
    <ns>0</ns>
    <id>543</id>
    <revision>
      <id>3656113</id>
      <parentid>3656112</parentid>
      <timestamp>2020-01-29T19:38:46Z</timestamp>
      <contributor>
        <username>~riley</username>
        <id>552420</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/2600:1010:B142:23C2:D953:DDC5:55D5:2360|2600:1010:B142:23C2:D953:DDC5:55D5:2360]] ([[User talk:2600:1010:B142:23C2:D953:DDC5:55D5:2360|talk]]) to last version by ~riley</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="28922" xml:space="preserve">{{C Programming/Navigation|Structure and style|Simple Input and Output}}

Like most programming languages, C is able to use and process named variables and their contents. '''Variables''' are simply names used to refer to some location in memory – a location that holds a value with which we are working. 

It may help to think of variables as a placeholder for a value. You can think of a variable as being equivalent to its assigned value. So, if you have a variable ''i'' that is '''initialized''' (set equal) to 4, then it follows that ''i + 1'' will equal ''5''.

Since C is a relatively low-level programming language, before a C program can utilize memory to store a variable it must claim the memory needed to store the values for a variable. This is done by '''declaring''' variables. Declaring variables is the way in which a C program shows the number of variables it needs, what they are going to be named, and how much memory they will need.

Within the C programming language, when managing and working with variables, it is important to know the ''type'' of variables and the ''size'' of these types. A type’s size is the amount of computer memory required to store one value of this type. Since C is a fairly low-level programming language, the size of types can be specific to the hardware and compiler used – that is, how the language is made to work on one type of machine can be different from how it is made to work on another.

All variables in C are '''typed'''. That is, every variable declared must be assigned as a certain type of variable.

== Declaring, Initializing, and Assigning Variables ==
Here is an example of declaring an integer, which we've called &lt;tt&gt;some_number&lt;/tt&gt;. (Note the semicolon at the end of the line; that is how your compiler separates one program ''statement'' from another.)

&lt;source lang=c&gt;
int some_number;
&lt;/source&gt;

This statement means we're declaring some space for a variable called some_number, which will be used to store &lt;tt&gt;int&lt;/tt&gt;eger data. Note that we must specify the type of data that a variable will store. There are specific keywords to do this – we'll look at them in the next section.

Multiple variables can be declared with one statement, like this:
&lt;source lang=c&gt;
int anumber, anothernumber, yetanothernumber;
&lt;/source&gt;
We can also declare ''and'' assign some content to a variable at the same time.
&lt;source lang=c&gt;
int some_number = 3;
&lt;/source&gt;
This is called ''initialization''.

In early versions of C, variables had to be declared at the beginning of a block. In C99 it is allowed to mix declarations and statements arbitrarily – but doing so is not usual, because it is rarely necessary, some compilers still don’t support C99 (portability), and it may, because it is uncommon yet, irritate fellow programmers (maintainability).

After declaring variables, you can assign a value to a variable later on using a statement like this:
&lt;source lang=c&gt;
some_number = 3;
&lt;/source&gt;
You can also assign a variable the value of another variable, like so:
&lt;source lang=c&gt;
anumber = anothernumber;
&lt;/source&gt;
Or assign multiple variables the same value with one statement:
&lt;source lang=c&gt;
anumber = anothernumber = yetanothernumber = 3;
&lt;/source&gt;
This is because the assignment &lt;tt&gt;x = y&lt;/tt&gt; returns the value of the assignment, y. For example, &lt;tt&gt;some_number = 3&lt;/tt&gt; returns 3. That said, &lt;tt&gt;x = y = z &lt;/tt&gt; is really a shorthand for &lt;tt&gt;x = (y = z)&lt;/tt&gt;.

===Naming Variables===
Variable names in C are made up of letters (upper and lower case) and digits. The underscore character ("_") is also permitted. Names must not begin with a digit. Unlike some languages (such as [[w:Perl|Perl]] and some [[w:BASIC programming language|BASIC]] dialects), C does not use any special prefix characters on variable names.

Some examples of valid (but not very descriptive) C variable names:
&lt;source lang=c&gt;
foo
Bar
BAZ
foo_bar
_foo42
_
QuUx
&lt;/source&gt;
Some examples of invalid C variable names:
&lt;source lang=c&gt;
2foo    (must not begin with a digit)
my foo  (spaces not allowed in names)
$foo    ($ not allowed -- only letters, and _)
while   (language keywords cannot be used as names)
&lt;/source&gt;
As the last example suggests, certain words are reserved as keywords in the language, and these cannot be used as variable names.

It is not allowed to use the same name for multiple variables in the same [[C_Programming/Preliminaries|scope]]. When working with other developers, you should therefore take steps to avoid using the same name for global variables or function names. Some large projects adhere to naming guidelines&lt;ref&gt;Examples of naming guidelines are those of the [https://developer.gnome.org/programming-guidelines/stable/namespacing.html GNOME Project] or the parts of the [https://www.python.org/dev/peps/pep-0007/ Python interpreter] that are written in C.&lt;/ref&gt; to avoid duplicate names and for consistency.

In addition there are certain sets of names that, while not language keywords, are reserved for one reason or another. For example, a C compiler might use certain names "behind the scenes", and this might cause problems for a program that attempts to use them. Also, some names are reserved for possible future use in the C standard library. The rules for determining exactly what names are reserved (and in what contexts they are reserved) are too complicated to describe here{{fact}}, and as a beginner you don't need to worry about them much anyway. For now, just avoid using names that begin with an underscore character.

The naming rules for C variables also apply to naming other language constructs such as function names, struct tags, and macros, all of which will be covered later.

== Literals ==

Anytime within a program in which you specify a value explicitly instead of referring to a variable or some other form of data, that value is referred to as a '''literal'''. In the initialization example above, 3 is a literal. Literals can either take a form defined by their type (more on that soon), or one can use hexadecimal (hex) notation to directly insert data into a variable regardless of its type.{{fact}} Hex numbers are always preceded with ''0x''. For now, though, you probably shouldn't be too concerned with hex.

== The Four Basic Data Types ==

In Standard C there are four basic data types. They are &lt;code&gt;'''int'''&lt;/code&gt;, &lt;code&gt;'''char'''&lt;/code&gt;, &lt;code&gt;'''float'''&lt;/code&gt;, and &lt;code&gt;'''double'''&lt;/code&gt;.

===The &lt;code&gt;int&lt;/code&gt; type===
The &lt;tt&gt;int&lt;/tt&gt; type stores integers in the form of "whole numbers". An integer is typically the size of one machine word, which on most modern home PCs is 32 bits (4 octets). Examples of literals are whole numbers (integers) such as 1, 2, 3, 10, 100... When &lt;tt&gt;int&lt;/tt&gt; is 32 bits (4 octets), it can store any whole number (integer) between -2147483648 and 2147483647. A 32 bit word (number) has the possibility of representing any one number out of 4294967296 possibilities (2 to the power of 32).

&lt;!-- overflows --&gt;

If you want to declare a new int variable, use the &lt;tt&gt;int&lt;/tt&gt; keyword. For example:

&lt;source lang=c&gt;
int numberOfStudents, i, j=5;
&lt;/source&gt;

In this declaration we declare 3 variables, numberOfStudents, i and j, j here is assigned the literal 5.

===The &lt;code&gt;char&lt;/code&gt; type===
The &lt;code&gt;char&lt;/code&gt; type is capable of holding any member of the execution [[w:Character_encoding#Character_sets.2C_maps_and_code_pages|character set]]. It stores the same kind of data as an &lt;code&gt;int&lt;/code&gt; (i.e. integers), but typically has a size of one byte. The size of a byte is specified by the macro &lt;code&gt;CHAR_BIT&lt;/code&gt; which specifies the number of bits in a char (byte). In standard C it never can be less than 8 bits. A variable of type &lt;code&gt;char&lt;/code&gt; is most often used to store character data, hence its name. Most implementations use the [[w:ASCII|ASCII]] character set as the execution character set, but it's best not to know or care about that unless the actual values are important.

Examples of character literals are 'a', 'b', '1', etc., as well as some special characters such as '&lt;code&gt;\0&lt;/code&gt;' (the null character) and '&lt;code&gt;\n&lt;/code&gt;' (newline, recall "Hello, World"). Note that the &lt;code&gt;char&lt;/code&gt; value must be enclosed within single quotations.

When we initialize a character variable, we can do it two ways. One is preferred, the other way is '''''bad''''' programming practice.

The first way is to write
&lt;source lang=c&gt;
char letter1 = 'a';
&lt;/source&gt;

This is ''good'' programming practice in that it allows a person reading your code to understand that letter1 is being initialized with the letter 'a' to start off with.

The second way, which should ''not'' be used when you are coding letter characters, is to write
&lt;source lang=c&gt;
char letter2 = 97; /* in ASCII, 97 = 'a' */
&lt;/source&gt;

This is considered by some to be extremely '''''bad''''' practice, if we are using it to store a character, not a small number, in that if someone reads your code, most readers are forced to look up what character corresponds with the number 97 in the encoding scheme. In the end, &lt;code&gt;letter1&lt;/code&gt; and &lt;code&gt;letter2&lt;/code&gt; store both the same thing – the letter 'a', but the first method is clearer, easier to debug, and much more straightforward. 

One important thing to mention is that characters for numerals are represented differently from their corresponding number, i.e. '1' is not equal to 1. In short, any single entry that is enclosed within 'single quotes'.

There is one more kind of literal that needs to be explained in connection with chars: the '''string literal'''. A string is a series of characters, usually intended to be displayed. They are surrounded by double quotations (" ", not ' '). An example of a string literal is the "Hello, World!\n" in the "Hello, World" example.

The string literal is assigned to a character &lt;b&gt;array&lt;/b&gt;, arrays are described later. 
Example:
&lt;source lang=c&gt;
const char MY_CONSTANT_PEDANTIC_ITCH[] = "learn the usage context.\n";
printf("Square brackets after a variable name means it is a pointer to a string of memory blocks the size of the type of the array element.\n");

&lt;/source&gt;

=== The &lt;code&gt;float&lt;/code&gt; type === 
&lt;code&gt;float&lt;/code&gt; is short for '''floating point'''. It stores inexact representations of real numbers, both integer and non-integer values. It can be used with numbers that are much greater than the greatest possible &lt;code&gt;int&lt;/code&gt;. &lt;code&gt;float&lt;/code&gt; literals must be suffixed with F or f. Examples are: 3.1415926f, 4.0f, 6.022e+23f.

It is important to note that floating-point numbers are inexact. Some numbers like 0.1f cannot be represented exactly as &lt;code&gt;float&lt;/code&gt;s but will have a small error. Very large and very small numbers will have less precision and arithmetic operations are sometimes not associative or distributive because of a lack of precision. Nonetheless, floating-point numbers are most commonly used for approximating real numbers and operations on them are efficient on modern microprocessors.&lt;ref&gt;Representations of real numbers other than floating-point numbers exist but are not fundamental data types in C. Some C compilers support [[w:Fixed-point_arithmetic|fixed-point arithmetic]] data types, but these are not part of standard C. Libraries such as the [[w:GNU Multiple Precision Arithmetic Library|GNU Multiple Precision Arithmetic Library]] offer more data types for real numbers and very large numbers.&lt;/ref&gt; [[w:Floating-point arithmetic|Floating-point arithmetic]] is explained in more detail on Wikipedia.

&lt;code&gt;float&lt;/code&gt; variables can be declared using the &lt;tt&gt;float&lt;/tt&gt; keyword. A &lt;code&gt;float&lt;/code&gt; is only one machine word in size. Therefore, it is used when less precision than a double provides is required.

===The &lt;code&gt;double&lt;/code&gt; type===
The &lt;tt&gt;double&lt;/tt&gt; and &lt;tt&gt;float&lt;/tt&gt; types are very similar. The &lt;tt&gt;float&lt;/tt&gt; type allows you to store single-precision floating point numbers, while the &lt;tt&gt;double&lt;/tt&gt; keyword allows you to store double-precision floating point numbers – real numbers, in other words. Its size is typically two machine words, or 8 bytes on most machines. Examples of &lt;tt&gt;double&lt;/tt&gt; literals are 3.1415926535897932, 4.0, 6.022e+23 ([[w:Scientific notation|scientific notation]]). If you use 4 instead of 4.0, the 4 will be interpreted as an &lt;tt&gt;int&lt;/tt&gt;.

The distinction between floats and doubles was made because of the differing sizes of the two types. When C was first used, space was at a minimum and so the judicious use of a float instead of a double saved some memory. Nowadays, with memory more freely available, you rarely need to conserve memory like this – it may be better to use doubles consistently. Indeed, some C implementations use doubles instead of floats when you declare a float variable.

If you want to use a double variable, use the &lt;tt&gt;double&lt;/tt&gt; keyword.

== &lt;tt&gt;sizeof&lt;/tt&gt; ==
If you have any doubts as to the amount of memory actually used by any variable (and this goes for types we'll discuss later, also), you can use the &lt;tt&gt;'''sizeof'''&lt;/tt&gt; operator to find out for sure. (For completeness, it is important to mention that &lt;tt&gt;sizeof&lt;/tt&gt; is a [[w:Unary operation|unary operator]], not a function.) Its syntax is:

&lt;!-- Note: sizeof really needs the parentheses only when the argument is a type, see ISO 9899:2011 6.5.3.4/2 ``The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type.'' --&gt;
&lt;source lang=c&gt;
sizeof object
sizeof(type)
&lt;/source&gt;

The two expressions above return the size of the object and type specified, in bytes. The return type is &lt;tt&gt;size_t&lt;/tt&gt; (defined in the header &lt;tt&gt;&amp;lt;stddef.h&amp;gt;&lt;/tt&gt;) which is an unsigned value. Here's an example usage:

&lt;source lang=c&gt;
size_t size;
int i;
size = sizeof(i);
&lt;/source&gt;

&lt;tt&gt;size&lt;/tt&gt; will be set to 4, assuming &lt;tt&gt;CHAR_BIT&lt;/tt&gt; is defined as 8, and an integer is 32 bits wide. The value of &lt;tt&gt;sizeof&lt;/tt&gt;'s result is the number of bytes.

Note that when &lt;tt&gt;sizeof&lt;/tt&gt; is applied to a &lt;tt&gt;char&lt;/tt&gt;, the result is 1; that is:

&lt;source lang=c&gt;
sizeof(char)
&lt;/source&gt;

always returns 1.

== Data type modifiers ==

One can alter the data storage of any data type by preceding it with certain modifiers.

&lt;tt&gt;'''long'''&lt;/tt&gt; and &lt;tt&gt;'''short'''&lt;/tt&gt; are modifiers that make it possible for a data type to use either more or less memory. The &lt;tt&gt;int&lt;/tt&gt; keyword need not follow the &lt;tt&gt;short&lt;/tt&gt; and &lt;tt&gt;long&lt;/tt&gt; keywords. This is most commonly the case. A &lt;tt&gt;short&lt;/tt&gt; can be used where the values fall within a lesser range than that of an &lt;tt&gt;int&lt;/tt&gt;, typically -32768 to 32767.  A &lt;tt&gt;long&lt;/tt&gt; can be used to contain an extended range of values. It is not guaranteed that a &lt;tt&gt;short&lt;/tt&gt; uses less memory than an &lt;tt&gt;int&lt;/tt&gt;, nor is it guaranteed that a &lt;tt&gt;long&lt;/tt&gt; takes up more memory than an &lt;tt&gt;int&lt;/tt&gt;. It is only guaranteed that sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long).  Typically a &lt;tt&gt;short&lt;/tt&gt; is 2 bytes, an &lt;tt&gt;int&lt;/tt&gt; is 4 bytes, and a &lt;tt&gt;long&lt;/tt&gt; either 4 or 8 bytes. Modern C compilers also provide &lt;tt&gt;long long&lt;/tt&gt; which is typically an 8 byte integer.  

In all of the types described above, one bit is used to indicate the sign (positive or negative) of a value. If you decide that a variable will never hold a negative value, you may use the &lt;tt&gt;'''unsigned'''&lt;/tt&gt; modifier to use that one bit for storing other data, effectively doubling the range of values while mandating that those values be positive. The &lt;tt&gt;unsigned&lt;/tt&gt; specifier also may be used without a trailing &lt;tt&gt;int&lt;/tt&gt;, in which case the size defaults to that of an &lt;tt&gt;int&lt;/tt&gt;. There is also a &lt;tt&gt;'''signed'''&lt;/tt&gt; modifier which is the opposite, but it is not necessary, except for certain uses of &lt;tt&gt;char&lt;/tt&gt;, and seldom used since all types (except &lt;tt&gt;char&lt;/tt&gt;) are signed by default.

The &lt;tt&gt;long&lt;/tt&gt; modifier can also be used with &lt;tt&gt;double&lt;/tt&gt; to create a &lt;tt&gt;long double&lt;/tt&gt; type. This floating-point type may (but is not required to) have greater precision than the &lt;tt&gt;double&lt;/tt&gt; type. 

To use a modifier, just declare a variable with the data type and relevant modifiers:
&lt;source lang=c&gt;
unsigned short int usi;  /* fully qualified -- unsigned short int */
short si;                /* short int */
unsigned long uli;       /* unsigned long int */
&lt;/source&gt;

== &lt;tt&gt;const&lt;/tt&gt; qualifier ==

When the &lt;tt&gt;'''const'''&lt;/tt&gt; qualifier is used, the declared variable must be initialized at declaration. It is then not allowed to be changed.

While the idea of a variable that never changes may not seem useful, there are good reasons to use &lt;tt&gt;const&lt;/tt&gt;. For one thing, many compilers can perform some small optimizations on data when it knows that data will never change. For example, if you need the value of &amp;pi; in your calculations, you can declare a const variable of &lt;tt&gt;pi&lt;/tt&gt;, so a program or another function written by someone else cannot change the value of &lt;tt&gt;pi&lt;/tt&gt;.

Note that a Standard conforming compiler must issue a warning if an attempt is made to change a &lt;tt&gt;const&lt;/tt&gt; variable - but after doing so the compiler is free to ignore the &lt;tt&gt;const&lt;/tt&gt; qualifier.

== Magic numbers ==
When you write C programs, you may be tempted to write code that will depend on certain numbers. For example, you may be writing a program for a grocery store. This complex program has thousands upon thousands of lines of code. The programmer decides to represent the cost of a can of corn, currently 99 cents, as a literal throughout the code. Now, assume the cost of a can of corn changes to 89 cents. The programmer must now go in and manually change each entry of 99 cents to 89. While this is not that big of a problem, considering the "global find-replace" function of many text editors, consider another problem: the cost of a can of green beans is also initially 99 cents. To reliably change the price, you have to look at every occurrence of the number 99.

C possesses certain functionality to avoid this. This functionality is approximately equivalent, though one method can be useful in one circumstance, over another.

=== Using the &lt;tt&gt;const&lt;/tt&gt; keyword ===
The &lt;tt&gt;const&lt;/tt&gt; keyword helps eradicate '''magic numbers'''. By declaring a variable &lt;tt&gt;const corn&lt;/tt&gt; at the beginning of a block, a programmer can simply change that const and not have to worry about setting the value elsewhere.

There is also another method for avoiding magic numbers. It is much more flexible than &lt;tt&gt;const&lt;/tt&gt;, and also much more problematic in many ways. It also involves the preprocessor, as opposed to the compiler. Behold...

=== &lt;tt&gt;#define&lt;/tt&gt; ===
When you write programs, you can create what is known as a ''macro'', so when the computer is reading your code, it will replace all instances of a word with the specified expression.

Here's an example. If you write
&lt;source lang=c&gt;
#define PRICE_OF_CORN 0.99
&lt;/source&gt;
when you want to, for example, print the price of corn, you use the word &lt;code&gt;PRICE_OF_CORN&lt;/code&gt; instead of the number 0.99 – the preprocessor will replace all instances of &lt;code&gt;PRICE_OF_CORN&lt;/code&gt; with 0.99, which the compiler will interpret as the literal &lt;code&gt;double&lt;/code&gt; 0.99. The preprocessor performs substitution, that is, &lt;code&gt;PRICE_OF_CORN&lt;/code&gt; is replaced by 0.99 so this means there is no need for a semicolon.

It is important to note that &lt;code&gt;#define&lt;/code&gt; has basically the same functionality as the "find-and-replace" function in a lot of text editors/word processors. 

For some purposes, &lt;code&gt;#define&lt;/code&gt; can be harmfully used, and it is usually preferable to use &lt;code&gt;const&lt;/code&gt; if &lt;code&gt;#define&lt;/code&gt; is unnecessary. It is possible, for instance, to &lt;code&gt;#define&lt;/code&gt;, say, a macro &lt;code&gt;DOG&lt;/code&gt; as the number 3, but if you try to print the macro, thinking that &lt;code&gt;DOG&lt;/code&gt; represents a string that you can show on the screen, the program will have an error. &lt;code&gt;#define&lt;/code&gt; also has no regard for type. It disregards the structure of your program, replacing the text ''everywhere'' (in effect, disregarding scope), which could be advantageous in some circumstances, but can be the source of problematic bugs.

You will see further instances of the &lt;code&gt;#define&lt;/code&gt; directive later in the text. It is good convention to write &lt;code&gt;#define&lt;/code&gt;d words in all capitals, so a programmer will know that this is not a variable that you have declared but a &lt;code&gt;#define&lt;/code&gt;d macro.
It is not necessary to end a preprocessor directive such as &lt;code&gt;#define&lt;/code&gt; with a semicolon; in fact, some compilers may warn you about unnecessary tokens in your code if you do.
&lt;!-- Mention enum for constant defining! --&gt;

== Scope ==

In the Basic Concepts section, the concept of scope was introduced. It is important to revisit the distinction between local types and global types, and how to declare variables of each. To declare a local variable, you place the declaration at the beginning (i.e. before any non-declarative statements) of the block to which the variable is deemed to be local. To declare a global variable, declare the variable outside of any block. If a variable is global, it can be read, and written, from anywhere in your program.

Global variables are not considered good programming practice, and should be avoided whenever possible. They inhibit code readability, create naming conflicts, waste memory, and can create difficult-to-trace bugs. Excessive usage of globals is usually a sign of laziness or poor design. However, if there is a situation where local variables may create more obtuse and unreadable code, there's no shame in using globals.

== Other Modifiers ==

Included here, for completeness, are more of the modifiers that standard C provides. For the beginning programmer, ''static'' and ''extern'' may be useful. ''volatile'' is more of interest to advanced programmers. ''register'' and ''auto'' are largely deprecated and are generally not of interest to either beginning or advanced programmers.

===static===
&lt;tt&gt;'''static'''&lt;/tt&gt; is sometimes a useful keyword. 
It is a common misbelief that the only purpose is to make a variable stay in memory.

When you declare a function or global variable as ''static'', you cannot access the function or variable through the extern (see below) keyword from other files in your project.  This is called ''static linkage''.

When you declare a local variable as ''static'', it is created just like any other variable. However, when the variable goes out of scope (i.e. the block it was local to is finished) the variable stays in memory, retaining its value. The variable stays in memory until the program ends. While this behaviour resembles that of global variables, static variables still obey scope rules and therefore cannot be accessed outside of their scope.  This is called ''static storage duration''.

Variables declared static are initialized to zero (or for pointers, NULL&lt;ref name="NULL-macro"&gt;[http://c-faq.com/null/macro.html] - What is NULL and how is it defined?&lt;/ref&gt;&lt;ref name="NULL-or-zero"&gt;[http://c-faq.com/null/nullor0.html] - NULL or 0, which should you use?&lt;/ref&gt;) by default. They can be initialized explicitly on declaration to any ''constant'' value. The initialization is made just once, at compile time. 

You can use static in (at least) two different ways.  Consider this code, and imagine it is in a file called jfile.c:

&lt;source lang=c&gt;
#include &lt;stdio.h&gt;
 
static int j = 0;
 
void up(void)
{
   /* k is set to 0 when the program starts. The line is then "ignored"
    * for the rest of the program (i.e. k is not set to 0 every time up()
    * is called)
    */
   static int k = 0;
   j++;
   k++;
   printf("up() called.   k= %2d, j= %2d\n", k , j);
}
 
void down(void)
{
   static int k = 0;
   j--;
   k--;
   printf("down() called. k= %2d, j= %2d\n", k , j);
}
 
int main(void)
{
   int i;
     
   /* call the up function 3 times, then the down function 2 times */
   for (i = 0; i &lt; 3; i++)
      up();
   for (i = 0; i &lt; 2; i++)
      down();
    
   return 0;
}
&lt;/source&gt;

The &lt;code&gt;j&lt;/code&gt; variable is accessible by both up and down and retains its value.  The &lt;code&gt;k&lt;/code&gt; variables also retain their value, but they are two different variables, one in each of their scopes. Static variables are a good way to implement encapsulation, a term from the object-oriented way of thinking that effectively means not allowing changes to be made to a variable except through function calls.

Running the program above will produce the following output:
&lt;source lang=c&gt;
up() called.   k=  1, j=  1
up() called.   k=  2, j=  2
up() called.   k=  3, j=  3
down() called. k= -1, j=  2
down() called. k= -2, j=  1
&lt;/source&gt;

'''Features of &lt;code&gt;static&lt;/code&gt; variables :'''
     1. Keyword used        - '''static'''
     2. Storage             - Memory
     3. Default value       - Zero
     4. Scope               - Local to the block in which it is declared
     5. Lifetime            - Value persists between different function calls
     6. Keyword optionality - Mandatory to use the keyword

===extern===
&lt;tt&gt;'''extern'''&lt;/tt&gt; is used when a file needs to access a variable in another file that it may not have &lt;tt&gt;#include&lt;/tt&gt;d directly. Therefore, ''extern'' does not actually carve out space for a new variable, it just provides the compiler with sufficient information to access the remote variable.

'''Features of &lt;code&gt;extern&lt;/code&gt; variable :'''
     1. Keyword used        - '''extern'''
     2. Storage             - Memory
     3. Default value       - Zero
     4. Scope               - Global (all over the program)
     5. Lifetime            - Value persists till the program's execution comes to an end
     6. Keyword optionality - Optional if declared outside all the functions

===volatile===
'''&lt;tt&gt;volatile&lt;/tt&gt;''' is a special type of modifier which informs the compiler that the value of the variable may be changed by external entities other than the program itself. This is necessary for certain programs compiled with optimizations – if a variable were not defined &lt;tt&gt;volatile&lt;/tt&gt; then the compiler may assume that certain operations involving the variable are safe to optimize away when in fact they aren't. ''volatile'' is particularly relevant when working with embedded systems (where a program may not have complete control of a variable) and multi-threaded applications.

===auto===
&lt;tt&gt;'''auto'''&lt;/tt&gt; is a modifier which specifies an "automatic" variable that is automatically created when in scope and destroyed when out of scope. If you think this sounds like pretty much what you've been doing all along when you declare a variable, you're right: all declared items within a block are implicitly "automatic". For this reason, the ''auto'' keyword is more like the answer to a trivia question than a useful modifier, and there are lots of very competent programmers that are unaware of its existence.

'''Features of &lt;code&gt;automatic&lt;/code&gt; variables :'''
     1. Keyword used        - '''auto'''
     2. Storage             - Memory
     3. Default value       - Garbage value (random value)
     4. Scope               - Local to the block in which it is defined
     5. Lifetime            - Value persists while the control remains within the block
     6. Keyword optionality - Optional

===register===
'''&lt;tt&gt;register&lt;/tt&gt;''' is a hint to the compiler to attempt to optimize the storage of the given variable by storing it in a register of the computer's CPU when the program is run. Most optimizing compilers do this anyway, so use of this keyword is often unnecessary. In fact, ANSI C states that a compiler can ignore this keyword if it so desires – and many do. Microsoft Visual C++ is an example of an implementation that completely ignores the ''register'' keyword.

'''Features of &lt;code&gt;register&lt;/code&gt; variables :'''
     1. Keyword used        - '''register'''
     2. Storage             - CPU registers (values can be retrieved faster than from memory)
     3. Default value       - Garbage value
     4. Scope               - Local to the block in which it is defined
     5. Lifetime            - Value persists while the control remains within the block
     6. Keyword optionality - Mandatory to use the keyword

===Concepts===
* [[Computer Programming/Variables|Variables]]
* [[Computer Programming/Types|Types]]
* [[Data Structures]]
* [[Data Structures/Arrays|Arrays]]

===In this section===
*[[C Programming/Variables|C variables]]
**[[C Programming/Arrays|C arrays]]

== References ==
{{reflist}}

[[de:C-Programmierung: Variablen und Konstanten]]
[[et:Programmeerimiskeel C/Muutujad]]
[[fi:C/Muuttujat]]
[[fr:Programmation C/Bases du langage]]
[[it:C/Variabili, operatori e costanti/Variabili]]
[[ja:C言語 変数]]
[[pl:C/Zmienne]]
[[pt:Programar em C/Variáveis]]

{{C Programming/Navigation|Structure and style|Simple Input and Output}}</text>
      <sha1>hf515lbowg1gn02lh6d5z2w8piwswxo</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/What you need before you can learn</title>
    <ns>0</ns>
    <id>31448</id>
    <revision>
      <id>3367690</id>
      <parentid>3367686</parentid>
      <timestamp>2018-01-27T21:49:33Z</timestamp>
      <contributor>
        <username>Atcovi</username>
        <id>1015207</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/Baebyseton|Baebyseton]] ([[User talk:Baebyseton|talk]]) to last version by Fredddii</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7805" xml:space="preserve">{{C Programming/Navigation|History|Using a Compiler}}

== Getting Started ==
The goal of this book is to introduce you to and teach you the C programming language. Basic computer literacy is assumed, but no special knowledge is needed.

Before you can start programming in C, you will need a '''C [[w:Compiler|compiler]]'''. A compiler is a program that converts C code into executable [[w:machine code|machine code]].&lt;ref&gt;Actually, GCC’s (GNU C Compiler) '''cc''' (C Compiler) translates the input .c file to the target CPU’s [[w:Assembly language|assembly]], output is written to an .s file. Then '''as''' (assembler) generates a machine code file from the .s file. Pre-processing is done by another sub-program '''cpp ''' (C PreProcessor), which is not to be confused with '''c++''' (a compiler for another programming language).&lt;/ref&gt;


'''Popular C compilers/IDEs include:'''
{| style="border: 1px #aaa solid;" 
! align="left"|Name
! align="left"|Website
! align="left"|Platform
! align="left"|License
! align="left"|Details
|-
| [[w:Microsoft Visual Studio#Community|Microsoft Visual Studio Community]]
| [https://www.visualstudio.com/vs/community/ Visual Studio]
| Windows
| Proprietary, free of charge
| Powerful and student-friendly version of an industry standard compiler.
|-
|[[wikipedia:Xcode|Xcode]]
|Xcode
|macOS, OSX
|Proprietary, free of charge
|Default IDE on macOS
|-
| [[w:Tiny C Compiler|Tiny C Compiler (TCC)]]
| [https://bellard.org/tcc/ tinycc]
| GNU/Linux, Windows
| [[w:GNU Lesser General Public License|LGPL]]
| Small, fast and simple compiler.
|-
| [[w:Clang|Clang]]
| [https://clang.llvm.org clang]
| GNU/Linux, Windows, Unix, OS X
| [http://opensource.org/licenses/UoI-NCSA.php University of Illinois/NCSA License]
| A free, permissively licensed front-end using a LLVM backend.
|-
| [[w:GNU Compiler Collection|GNU C Compiler]]
| [https://gcc.gnu.org gcc]
| GNU/Linux, [http://mingw.org MinGW] or [https://mingw-w64.org mingw-w64] (Windows), Unix, OS X.
| [[w:GNU General Public License|GPL]]
| The De facto standard. Ships with most Unix systems.
|}


The minimum software requirements to program in C is a [[w:Text Editor|text editor]], as opposed to a [[w:Word Processor|word processor]]. A plain text Notepad editor can be used but it does not offer any advanced capabilities such as syntax highlighting and code completion. There are many text editors (see [[w:List of text editors|List of Text Editors]]), among the most popular are [[w:Notepad++|Notepad++]] for Windows as well as [https://atom.io/ Atom], [[w:Sublime Text|Sublime Text]], [[w:gedit|gedit]], [[w:Vim (text editor)|Vim]] and [[w:Emacs|Emacs]] which are also available on other operating systems (“cross-platform”). These text editors come with [[w:syntax highlighting|syntax highlighting]] and line numbers, which makes code easier to read at a glance, and to spot syntax errors.

Though not absolutely needed, many programmers prefer and recommend using an [[w:Integrated development environment|Integrated development environment]] ('''IDE''') instead of a text editor. An IDE is a suite of programs that developers need, combined into one convenient package, usually with a graphical user interface. These programs include a text editor and file browser and are sometimes bundled with an easily accessible compiler. They also typically include a debugger, a tool that will enable you to do such things as step through the program you develop manually one source code line at a time, or alter data as an aid to finding and correcting programming errors.

Many IDEs do not offer their users a console-based interface to the compiler and for executing the developed program but offer only graphical buttons. For beginners it is recommended not to use such an IDE, since it hides most of what is going on. Using the command line builds up familiarity with the toolchain. Such an IDE may still be useful to somebody with programming experience who knows how the IDE works. So as a general guideline: Do not use an IDE unless you know what the IDE does!


'''Other popular compilers/IDEs include:'''
{| style="border: 1px #aaa solid;"
! align="left"|Name
! align="left"|Website
! align="left"|Platform
! align="left"|License
! align="left"|Details
|-
| [[w:Eclipse_(software)|Eclipse CDT]]
| [https://www.eclipse.org/downloads/packages/all Eclipse]
| Windows, Mac OS X, GNU/Linux
| Free/Libre and Open Source
| [[w:Eclipse (software)|Eclipse]] IDE for C/C++ developement, a popular open source IDE.
|-
| [[w:Netbeans|Netbeans]]
| [https://netbeans.org Netbeans]
| Cross-platform
| [[w:Common Development and Distribution License|CDDL]] and [[w:GNU General Public License|GPL]] 2.0
| A Good comparable matured IDE to Eclipse.
|-
| [[w:GNOME Builder|GNOME Builder]]
| [https://wiki.gnome.org/Apps/Builder Builder]
| GNU/Linux
| [[w:GNU General Public License|GPL]]
| A feature-rich but simple IDE for the [[w:GNOME|GNOME]] desktop environment.
|-
| [[w:Anjuta|Anjuta]]
| [http://anjuta.org Anjuta]
| GNU/Linux
| [[w:GNU General Public License|GPL]]
| An extensible GTK+3 IDE for the [[w:GNOME|GNOME]] desktop environment.
|-
| [[w:Geany|Geany]]
| [http://www.geany.org geany]
| Cross-platform
| [[w:GNU General Public License|GPL]]
| A lightweight cross-platform GTK+ notepad based on Scintilla, with basic IDE features.
|-
| [[w:KDevelop|KDevelop]]
| [https://www.kdevelop.org/ KDevelop]
| Cross-platform
| [[w:GNU General Public License|GPL]]
| A cross-platform IDE for the [[w:KDE|KDE]] project.
|-
| [[w:LCC (compiler)|Little C Compiler (LCC)]]
| [https://www.cs.virginia.edu/~lcc-win32 lcc]
| Windows
| Open Source but not Libre
| Small open source compiler.
|-
| [[w:Xcode|Xcode]]
| [https://developer.apple.com/xcode Xcode]
| Mac OS X
| Proprietary, free of charge
| Available free of charge at [https://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;mt=12 Mac App Store].
|-
| [[w:Pelles C|Pelles C]]
| [http://smorgasbordet.com/pellesc Pelles C]
| Windows, Pocket PC
| Proprietary, free of charge
| A complete C development kit for Windows.
|-
| [[w:Dev-C++ | Dev-C++]]
| [https://sourceforge.net/projects/orwelldevcpp/ Dev C++]
| Windows
| [[w:GNU General Public License|GPL]]
| Updated version of the formerly popular Bloodshed Dev-C++.
|-
| [[w:Microsoft Visual Studio#Community|Microsoft Visual Studio Community]]
| [https://www.visualstudio.com/vs/community/ Visual Studio]
| Windows
| Proprietary, free of charge
| Microsoft’s compiler already mentioned above comes bundled with an IDE.
|-
| [[w:CodeLite|CodeLite]]
| [https://codelite.org/ CodeLite]
| Cross-platform
| [[w:GNU General Public License|GPL]] 2
| Free IDE for C/C++ development.
|-
| [[w:Code::Blocks|Code::Blocks]] 
| [http://codeblocks.org/ Code::Blocks]
| Cross-platform
| [[w:GNU General Public License|GPL]] 3.0
| Built to meet users' most demanding needs. Very extensible and fully configurable.
|}

On '''GNU/Linux''', GCC is almost always included by default.

On '''Microsoft Windows''', Dev-C++ is recommended for beginners because it is easy to use, free, and simple to install. Although the initial developer (Bloodshed) hasn’t updated it since 2005, a new version appeared in 2011, made by an independent programmer, and is being actively developed.&lt;ref&gt;http://orwelldevcpp.blogspot.com/&lt;/ref&gt; An alternate option for those working only in the Windows environment is the proprietary Microsoft Visual Studio Community which is free of charge and has an excellent debugger.

On '''Mac OS X''', the Xcode IDE provides the compilers needed to compile various source files. The newer versions do not include the command line tools. They need to be downloaded via Xcode-&gt;Preferences-&gt;Downloads.

== Footnotes ==

{{reflist|2}}
{{C Programming/Navigation|History|Using a Compiler}}

[[pl:C/Czego potrzebujesz]]</text>
      <sha1>mzojjru5t7kaevkuuelchzeemlwnlgq</sha1>
    </revision>
  </page>
  <page>
    <title>C Programming/Why learn C?</title>
    <ns>0</ns>
    <id>31467</id>
    <revision>
      <id>3534860</id>
      <parentid>3289177</parentid>
      <timestamp>2019-04-04T07:30:03Z</timestamp>
      <contributor>
        <ip>41.78.79.70</ip>
      </contributor>
      <comment>/* Why C, and not assembly language? */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5785" xml:space="preserve">{{C Programming/Navigation|next=History}}

{{Wikipedia|C (programming language)}}

[[Wikipedia:C (programming language)|C]] is the most commonly used programming language for writing [[Wikipedia:operating systems|operating systems]]. The first operating system written in C is [[Wikipedia:Unix|Unix]]. Later operating systems like [[Wikipedia:Linux|GNU/Linux]] were all written in C. Not only is C the language of operating systems, it is the precursor and inspiration for almost all of the most popular high-level languages available today. In fact, [[Wikipedia:Perl|Perl]], [[Wikipedia:PHP|PHP]], [[Wikipedia:Python (programming language)|Python]] and [[Wikipedia:Ruby_(programming_language)|Ruby]] are all written in C.

By way of analogy, let's say that you were going to be learning Spanish, Italian, French, or Romanian. Do you think knowing Latin would be helpful? Just as Latin was the basis of all of those languages, knowing C will enable you to understand and appreciate an entire family of programming languages built upon the traditions of C. Knowledge of C enables freedom.

===Why C and not assembly language? ===

While [[w:Assembly language|assembly language]] can provide speed and maximum control of the program, C provides portability.

Different processors are programmed using different Assembly languages and having to choose and learn only one of them is too arbitrary. In fact, one of the main strengths of C is that it combines  universality and portability across various computer architectures while retaining most of the control of the hardware provided by assembly language.

For example, C programs can be compiled and run on the HP 50g calculator ([[w:ARM architecture|ARM]] processor), the TI-89 calculator ([[w:Motorola 68000|68000]] processor), Palm OS Cobalt smartphones (ARM processor), the original iMac ([[w:PowerPC|PowerPC]]), the Arduino ([[w:Atmel AVR|Atmel AVR]]), and the Intel iMac ([[w:x86|Intel]] Core 2 Duo).  Each of these devices has its own assembly language that is completely incompatible with the assembly language of any other.

Assembly, while extremely powerful, is simply too difficult to program large applications and hard to read or interpret in a logical way. C is a compiled language, which creates fast and efficient executable files. It is also a small “what you see is all you get” language: a C statement corresponds to at most a handful of assembly statements, everything else is provided by library functions.

So is it any wonder that C is such a popular language?

Like toppling dominoes, the next generation of programs follows the trend of its ancestors. Operating systems designed in C always have system libraries designed in C. Those system libraries are in turn used to create higher-level libraries (like [[Wikipedia:OpenGL|OpenGL]], or [[Wikipedia:GTK|GTK]]), and the designers of those libraries often decide to use the language the system libraries used. Application developers use the higher-level libraries to design word processors, games, media players and the like. Many of them will choose to program in the language that the higher-level library uses. And the pattern continues on and on and on...

=== Why C, and not another language? ===

The primary design of C is to produce portable code while maintaining performance and minimizing footprint ([[Wikipedia:CPU time|CPU time]], [[Wikipedia:Computer memory|memory]] usage, disk I/O, etc.). This is useful for [[Wikipedia:Operating systems|operating systems]], [[Wikipedia:Embedded systems|embedded systems]] or other programs where performance matters a lot (“high-level” interface would affect performance). With C it’s relatively easy to keep a mental picture of what a given line really does, because most of the things are written explicitly in the code. C has a big codebase for low level applications. It is the “native” language of [[w:Unix|UNIX]], which makes it flexible and portable. It is a stable and mature language which is unlikely to disappear for a long time and has been ported to most, if not all, platforms.

One powerful reason is memory allocation. Unlike most programming languages, C allows the programmer to write directly to memory. Key constructs in C such as structs, pointers and arrays are designed to structure and manipulate memory in an efficient, machine-independent fashion. In particular, C gives control over the memory layout of data structures. Moreover dynamic memory allocation is under the control of the programmer (which also means that memory deallocation has to be done by the programmer). Languages like [[Wikipedia:Java (programming language)|Java]] and Perl shield the programmer from having to manage most details of memory allocation and pointers (except for [[w:Memory leak|memory leaks]] and some other forms of excess memory usage). This can be useful since dealing with memory allocation when building a high-level program is a highly error-prone process. However, when dealing with low-level code such as the part of the OS that controls a device, C provides a uniform, clean interface. These capabilities just do not exist in most other languages.

While Perl, PHP, Python and Ruby may be powerful and support many features not provided by default in C, they are not normally implemented in their own language. Rather, most such languages initially relied on being written in C (or another high-performance programming language), and would require their implementation be ported to a new platform before they can be used.

As with all programming languages, whether you want to choose C over another high-level language is a matter of opinion and both technical and business requirements could dictate which language is required. 

{{C Programming/Navigation|next=History}}</text>
      <sha1>1r6dyg4t64431g80miv7au9znd4jj3l</sha1>
    </revision>
  </page>
  <page>
    <title>Template:-</title>
    <ns>10</ns>
    <id>40298</id>
    <revision>
      <id>1869753</id>
      <parentid>1869704</parentid>
      <timestamp>2010-06-30T18:02:00Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>35 revisions from [[:w:Template:-]]: history merge</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="66" xml:space="preserve">&lt;br style="clear:both;" /&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>na9lai3gcfrb6vhonby2kgdepx0ui5e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ambox</title>
    <ns>10</ns>
    <id>384875</id>
    <redirect title="Template:Bmbox" />
    <revision>
      <id>3228920</id>
      <timestamp>2017-06-12T23:26:41Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>JackPotte moved page [[Template:Ambox]] to [[Template:Bmbox]] over redirect: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="28" xml:space="preserve">#REDIRECT [[Template:Bmbox]]</text>
      <sha1>dxps9o5us57jnv4ru2ijugfl7l7m3fr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ambox/core</title>
    <ns>10</ns>
    <id>384876</id>
    <redirect title="Template:Bmbox/core" />
    <revision>
      <id>3228922</id>
      <timestamp>2017-06-12T23:26:42Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>JackPotte moved page [[Template:Ambox/core]] to [[Template:Bmbox/core]]: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="33" xml:space="preserve">#REDIRECT [[Template:Bmbox/core]]</text>
      <sha1>h9ijn3lsvc1xiywalc32i94xf9ujsdf</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKCATEGORY</title>
    <ns>10</ns>
    <id>378612</id>
    <revision>
      <id>3365859</id>
      <parentid>3318591</parentid>
      <timestamp>2018-01-24T02:52:43Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>BOOKNAME (new-style)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="131" xml:space="preserve">&lt;includeonly&gt;Category:Book:{{{book|{{BOOKNAME|{{{1|{{FULLPAGENAME}}}}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>lloy4fm1jzvf8hvj4tiuynvt6q10c3o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKNAME</title>
    <ns>10</ns>
    <id>200630</id>
    <revision>
      <id>3365699</id>
      <parentid>3365668</parentid>
      <timestamp>2018-01-23T20:13:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>moved</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="185" xml:space="preserve">&lt;includeonly&gt;{{BOOKNAME/core|namespace={{ARTICLESPACE:{{{1|{{FULLPAGENAME}}}}}}}|pagename={{PAGENAME:{{{1|{{FULLPAGENAME}}}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>2zoc5zvlxanv2krulr6gt7b6cby47sa</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKNAME/core</title>
    <ns>10</ns>
    <id>377904</id>
    <revision>
      <id>3365708</id>
      <parentid>3365674</parentid>
      <timestamp>2018-01-23T20:25:43Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>moved</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="236" xml:space="preserve">{{#switch:{{{namespace}}}
|Template={{#invoke:TScope|override|BOOKNAME/refactor}}
|Category={{#invoke:TScope|override|BOOKNAME/category}}
|#default={{#invoke:TScope|override|BOOKNAME/inbook}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>qi6t884khyp7aou5pr0g0bdratkpv3e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKNAME/inbook</title>
    <ns>10</ns>
    <id>379921</id>
    <revision>
      <id>3415335</id>
      <parentid>3365706</parentid>
      <timestamp>2018-04-22T21:58:27Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>department, shelf</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="523" xml:space="preserve">{{#switch:{{{namespace}}}
|={{#if:{{evalx|
          (let (x (get-arg 2))
            (if (equal? (get-substring x 1 11) "Department:")
                "x"
                (if (equal? (get-substring x 1 6) "Shelf:")
                    "x"
                    "")))
          |{{ucfirst:{{{pagename}}}}}}}
    |Wikibooks Stacks
    |{{#titleparts:{{{pagename}}}|1}}}}
|User    ={{#invoke:TScope|override|BOOKNAME/user}}
|#default={{{namespace}}}:{{#titleparts:{{{pagename}}}|1}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gkue6tkj35d5gklu0t2d6o38tkpp9w6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Bmbox</title>
    <ns>10</ns>
    <id>151630</id>
    <revision>
      <id>3228919</id>
      <parentid>1764517</parentid>
      <timestamp>2017-06-12T23:26:41Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>JackPotte moved page [[Template:Ambox]] to [[Template:Bmbox]] over redirect: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="944" xml:space="preserve">&lt;!--{{Ambox}} begin--&gt;{{#switch:{{{small|}}}
| left = 
  {{Ambox/core
  | small      = left
  | type       = {{{type|}}}
  | image      = {{#if:{{{smallimage|}}}
                 | {{{smallimage}}}
                 | {{{image|}}}
                 }}
  | imageright = {{#if:{{{smallimageright|}}}
                 | {{{smallimageright}}}
                 | {{{imageright|}}}
                 }}
  | style      = {{{style|}}}
  | textstyle  = {{{textstyle|}}}
  | text       = {{#if:{{{smalltext|}}}
                 | {{{smalltext}}} 
                 | {{{text}}} 
                 }}
  }}
| #default = 
  {{Ambox/core
  | type       = {{{type|}}}
  | image      = {{{image|}}}
  | imageright = {{{imageright|}}}
  | style      = {{{style|}}}
  | textstyle  = {{{textstyle|}}}
  | text       = {{{text}}}
  }}
}}&lt;!--{{Ambox}} end--&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>71dedvqsi5zx5gybeme7bvom2cuhqki</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Bmbox/core</title>
    <ns>10</ns>
    <id>224716</id>
    <revision>
      <id>3228921</id>
      <parentid>2054530</parentid>
      <timestamp>2017-06-12T23:26:42Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>JackPotte moved page [[Template:Ambox/core]] to [[Template:Bmbox/core]]: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2195" xml:space="preserve">&lt;table class="metadata plainlinks ambox {{#switch:{{{small|}}}
| left = mbox-small-left
}} {{#switch:{{{type|}}}
| speedy     = ambox-speedy
| delete     = ambox-delete
| content    = ambox-content
| style      = ambox-style
| move       = ambox-move
| protection = ambox-protection
| notice     &lt;!-- notice = default --&gt;
| #default   = ambox-notice
}}" style="{{{style|}}}"&gt;
&lt;tr&gt;
{{#switch:{{{image|}}}
| blank    &lt;!-- Fall back to "none", since deprecated. --&gt;
| none = &lt;td class="mbox-empty-cell"&gt;&lt;/td&gt;   &lt;!-- No image. Cell with some width or padding necessary for text cell to have 100% width. --&gt;
| #default = 
  &lt;td class="mbox-image"&gt;{{
  #switch:{{{small|}}}
  | left = &lt;!-- Don't use the DIV --&gt; 
  | #default = &lt;div style="width: 52px;"&gt; 
  }}
  {{#if:{{{image|}}}
  | {{{image}}}
  | [[File:{{#switch:{{{type|}}}
    | speedy     = Ambox warning pn.svg
    | delete     = Ambox warning pn.svg
    | content    = Book important2.svg
    | style      = Edit-clear.svg
    | move       = Merge-split-transwiki default.svg
    | protection = Padlock-silver-medium.svg
    | notice          &lt;!-- notice = default --&gt;
    | #default   = Information icon4.svg
    }} | {{#switch:{{{small|}}} 
      | left = 20x20px 
      | #default = 40x40px 
      }} |link=|alt=]]
  }}{{#switch:{{{small|}}}
  | left = &lt;!-- Don't use the /DIV --&gt;
  | #default = &lt;/div&gt; 
  }}&lt;/td&gt;
}}
&lt;td class="mbox-text" style="{{{textstyle|}}}"&gt; {{{text}}} &lt;/td&gt;
{{#if:{{{imageright|}}}
| {{#ifeq:{{{imageright|}}}|none
  | &lt;!-- No image. --&gt;
  | &lt;td class="mbox-imageright"&gt;{{#switch:{{{small|}}}
    | left = {{{imageright}}}
    | #default = &lt;div style="width: 52px;"&gt; {{{imageright}}} &lt;/div&gt;
    }}&lt;/td&gt;
  }}
}}
&lt;/tr&gt;
&lt;/table&gt;&lt;!-- 
Detect and report usage with faulty "type" parameter:
--&gt;{{#switch:{{{type|}}}
|   &lt;!-- No type fed, is also valid input --&gt;
| speedy
| delete
| content
| style
| move
| protection
| notice     = &lt;!-- Do nothing, valid "type" --&gt;
| #default   = &lt;div style="text-align: center;"&gt;This message box is using an invalid "type={{{type|}}}" parameter and needs fixing.&lt;/div&gt;
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>tb1vy56jqr2f8rxcta3c3zxkitwyn88</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BookCat</title>
    <ns>10</ns>
    <id>133076</id>
    <revision>
      <id>3369509</id>
      <parentid>3369369</parentid>
      <timestamp>2018-01-30T00:44:35Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>fix</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="511" xml:space="preserve">&lt;includeonly&gt;{{#invoke:TScope|shiftLeft|BookCat/core|1
|namespace   ={{#if:{{{1|}}}|{{NAMESPACE:{{{1}}}}}|{{NAMESPACE}}}}
|pagename    ={{#if:{{{1|}}}|{{PAGENAME:{{{1}}}}}|{{PAGENAME}}}}
|fullpagename={{#if:{{{1|}}}|{{{1}}}|{{FULLPAGENAME}}}}
|sortkey     ={{{sort|{{{sortkey|}}}}}}
}}{{#if:{{{1|}}}                  |[[Category:Pages passing page name to BookCat]]}}&lt;!--
--&gt;{{#if:{{{sort|{{{sortkey|}}}}}}|[[Category:Pages passing sort key to BookCat]]}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>nw1barqxaok3ax2jtswg2fq40n07xkm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BookCat/core</title>
    <ns>10</ns>
    <id>395128</id>
    <revision>
      <id>3415301</id>
      <parentid>3369280</parentid>
      <timestamp>2018-04-22T20:06:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>department, shelf</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="550" xml:space="preserve">&lt;includeonly&gt;{{#invoke:TScope|override|BookCat/{{#switch:{{{namespace}}}
|{{TALKSPACE:{{{namespace}}}:{{{pagename}}}}}=talk
|Category =category
|Subject  =subject
|Template =template
|User     =user
|Wikibooks=category
|={{evalx|
    (let (x (get-arg 2))
      (if (equal? (get-substring x 1 11) "Department:")
          "department"
          (if (equal? (get-substring x 1 6) "Shelf:")
              "shelf"
              "default")))
    |{{ucfirst:{{{pagename}}}}}}}
|#default =default
}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>8tn25ac4mqo1m1z6kwtwsnkadjnnq8d</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BookCat/default</title>
    <ns>10</ns>
    <id>377931</id>
    <revision>
      <id>3369433</id>
      <parentid>3364961</parentid>
      <timestamp>2018-01-29T21:02:08Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="563" xml:space="preserve">&lt;includeonly&gt;{{#ifeq: {{{filing|}}} | deep
|[[{{BOOKCATEGORY|{{{fullpagename}}}|book={{#if:{{#titleparts:{{{fullpagename}}}||2}}|{{#titleparts:{{{fullpagename}}}|-1}}|{{{fullpagename}}}}}}}|{{#if:{{{sortkey|}}}|{{{sortkey}}}|{{#if:{{#titleparts:{{{fullpagename}}}||2}}|{{#titleparts:{{{pagename}}}||-1}}}}}} ]][[Category:Pages with deep filing]]
|[[{{BOOKCATEGORY|{{{fullpagename}}}|book={{NAIVEBOOKNAME|{{{fullpagename}}}}}}}|{{#if:{{{sortkey|}}}|{{{sortkey}}}|{{#titleparts:{{{fullpagename}}}||2}}}} ]]
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>19zdiuubcgqk688r91b773tk23n2n05</sha1>
    </revision>
  </page>
  <page>
    <title>Template:C Programming/Navigation</title>
    <ns>10</ns>
    <id>179752</id>
    <revision>
      <id>3365911</id>
      <parentid>3289175</parentid>
      <timestamp>2018-01-24T04:30:25Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>BOOKNAME (new-style)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="546" xml:space="preserve">{| class="noprint" style="border:1px solid black; width:100%; border-spacing:0px; margin:0.25em;"
 | style="width:33%; background:#ffffe0;" | {{#if:{{{previous|{{{1| }}}}}}|[[{{BOOKNAME}}/{{{previous|{{{1| }}}}}}|Previous: {{{previous|{{{1| }}}}}}]]| }}
 | style="width:33%; background:#ffffe0; text-align:center;" | [[{{BOOKNAME}}]]
 | style="width:33%; background:#ffffe0; text-align:right;" | {{#if:{{{next|{{{2| }}}}}}|[[{{BOOKNAME}}/{{{next|{{{2| }}}}}}|Next: {{{next|{{{2| }}}}}}]]| }}
|} {{BookCat}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>lltmb4tl2h7vfo9h5ynejxgifo4cxti</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cat handler</title>
    <ns>10</ns>
    <id>246659</id>
    <revision>
      <id>2182435</id>
      <parentid>2014960</parentid>
      <timestamp>2011-10-14T21:22:30Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3365" xml:space="preserve">{{#if:
  {{#ifeq: {{lc: {{{nocat|}}} }} | true
  | dontcat    &lt;!--"nocat=true", don't categorize--&gt;
  }}{{#ifeq: {{lc: {{{categories|}}} }} | no
  | dontcat
  }}{{#switch: {{lc: {{{category2|¬}}} }}
  | yes
  | ¬   =   &lt;!--Not defined--&gt;
  | #default = dontcat   &lt;!--"category2 = no/'defined but empty'/'anything'"--&gt;
  }}{{#switch: {{lc: {{{subpage|}}} }}
  | no = 
    {{basepage subpage
    | 
    | dontcat    &lt;!--"subpage=no" and on a subpage--&gt;
    | page = {{{page|}}}   &lt;!--For testing--&gt;
    }}
  | only = 
    {{basepage subpage
    | dontcat    &lt;!--"subpage=only" and not on a subpage--&gt;
    | page = {{{page|}}}   &lt;!--For testing--&gt;
    }}
  }}

|   &lt;!--Don't categorize (result was "dontcat" or "dontcatdontcat" and so on)--&gt;
| &lt;!--Check blacklist--&gt;
  {{#switch:
    {{#ifeq: {{lc: {{{nocat|}}} }} | false
    |   &lt;!--"nocat=false", skip blacklist check--&gt;
    | {{#ifeq: {{lc: {{{categories|}}} }} | yes
      |   &lt;!--Skip blacklist check--&gt;
      | {{#ifeq: {{lc: {{{category2|}}} }} | yes
        |   &lt;!--Skip blacklist check--&gt;
        | {{cat handler/blacklist| page = {{{page|}}} }}   &lt;!--Check blacklist--&gt;
        }}
      }}
    }}
  | hide = &lt;!--Blacklist returned "hide", don't categorize--&gt;
  | #default  = 
    &lt;!--Check if any namespace parameter is defined--&gt;
    {{#ifeq: h0#384!5nea+w9 | {{{all| {{{main| {{{talk| {{{user| {{{wikibooks| {{{file| {{{mediawiki| {{{template| {{{help| {{{category| {{{subject| {{{cookbook| {{{wikijunior| {{{other| h0#384!5nea+w9 }}} }}} }}} }}} }}} }}} }}} }}} }}} }}} }}} }}} }}} }}}
    | &lt;!--No namespace parameters fed, basic usage--&gt;
      {{namespace detect
      | main = {{{1|}}}
      | file = {{{1|}}}
      | help = {{{1|}}}
      | category = {{{1|}}}
      | subject = {{{1|}}}
      | cookbook = {{{1|}}}
      | wikijunior = {{{1|}}}
      | page = {{{page|}}}   &lt;!--For testing and demonstration--&gt;
      }}
    | &lt;!--Namespace parameters fed, advanced usage.
          If "data" is a number, return the corresponding 
          numbered parameter, else return "data".  --&gt;
      {{{all|}}}{{cat handler/numbered
      | 1 = {{{1|}}}
      | 2 = {{{2|}}}
      | 3 = {{{3|}}}
      | 4 = {{{4|}}}
      | 5 = {{{5|}}}
      | 6 = {{{6|}}}
      | 7 = {{{7|}}}
      | 8 = {{{8|}}}
      | 9 = {{{9|}}}
      | 10 = {{{10|}}}
      | data = 
        &lt;!--Check what namespace, and return the data for it.
            Respecting empty parameters on purpose.  --&gt;
        {{namespace detect
        | main = {{{main| {{{other|}}} }}}
        | talk = {{{talk| {{{other|}}} }}}
        | user = {{{user| {{{other|}}} }}}
        | wikibooks = {{{wikibooks| {{{project| {{{other|}}} }}} }}}
        | file = {{{file| {{{image| {{{other|}}} }}} }}}
        | mediawiki = {{{mediawiki| {{{other|}}} }}}
        | template = {{{template| {{{other|}}} }}}
        | help = {{{help| {{{other|}}} }}}
        | category = {{{category| {{{other|}}} }}}
        | subject = {{{subject| {{{other|}}} }}}
        | cookbook = {{{cookbook| {{{other|}}} }}}
        | wikijunior = {{{wikijunior| {{{other|}}} }}}
        | other = {{{other|}}}  &lt;!--Namespace special or a new namespace--&gt;
        | page = {{{page|}}}   &lt;!--For testing and demonstration--&gt;
        }}
      }}
    }}
  }}
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>ijq689ibkvgpn6062pl2c3r5e07ltvc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cat handler/blacklist</title>
    <ns>10</ns>
    <id>246665</id>
    <revision>
      <id>2014991</id>
      <parentid>2014990</parentid>
      <timestamp>2011-01-09T23:06:42Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Cat handler/blacklist]]": Uses complex features of wiki syntax ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="523" xml:space="preserve">&lt;noinclude&gt;'''Actual code of this blacklist:'''&lt;pre&gt;&lt;/noinclude&gt;{{if pagename
&lt;!-- Start of blacklist --&gt;

| Wikibooks:Templates/* = hide   &lt;!-- Don't categorize on its subpages --&gt;
| /archiv* = hide   &lt;!-- Don't categorize on /archive pages --&gt;

| Main Page = hide   &lt;!-- Don't categorize the main page --&gt;

&lt;!-- End of blacklist --&gt;
| page = {{{page|}}}   &lt;!-- Never change this one, see the doc --&gt;
}}&lt;noinclude&gt;&lt;/pre&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>hfnh3bhg5j0yyu54qr78jscgwabsjut</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cat handler/numbered</title>
    <ns>10</ns>
    <id>246661</id>
    <revision>
      <id>2014957</id>
      <parentid>2014956</parentid>
      <timestamp>2011-01-09T22:59:54Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>spacing</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="323" xml:space="preserve">&lt;includeonly&gt;{{#iferror: {{#expr: 1 + {{{data|}}} }} 
| {{{data|}}}   &lt;!--Not a number, return "data" as is--&gt; 
| {{{ {{{data|}}} |}}}   &lt;!--"data" is a number, return that numbered parameter--&gt;
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>lf3golbovq259j9nbpmf7vx2z1pxkrc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation</title>
    <ns>10</ns>
    <id>136635</id>
    <revision>
      <id>1777471</id>
      <parentid>1777470</parentid>
      <timestamp>2010-04-27T03:58:19Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Citation]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6346" xml:space="preserve">&lt;includeonly&gt;{{
  #if: {{{inventor-surname|{{{inventor1-surname|{{{inventor-last|{{{inventor1-last|{{{inventor|}}}}}}}}}}}}}}}
&lt;!--
    CITATIONS FOR PATENTS
--&gt;
|{{Citation/patent
 |Surname1 = {{{inventor-surname|{{{inventor1-surname|{{{inventor-last|{{{inventor1-last|{{{inventor}}}}}}}}}}}}}}}
 |Surname2={{{inventor2-surname|{{{inventor2-last|{{{inventor2|}}}}}}}}}
 |Surname3={{{inventor3-surname|{{{inventor3-last|{{{inventor3|}}}}}}}}}
 |Surname4={{{inventor4-surname|{{{inventor4-last|{{{inventor4|}}}}}}}}}
 |Given1 = {{{inventor-given|{{{inventor1-given|{{{inventor-first|{{{inventor1-first|}}}}}}}}}}}}
 |Given2={{{inventor2-given|{{{inventor2-first|}}}}}}
 |Given3={{{inventor3-given|{{{inventor3-first|}}}}}}
 |Given4={{{inventor4-given|{{{inventor4-first|}}}}}}
 |Inventorlink1={{{inventorlink1|{{{inventorlink|}}}}}}
 |Inventorlink2={{{inventorlink2|}}}
 |Inventorlink3={{{inventorlink3|}}}
 |Inventorlink4={{{inventorlink4|}}}
 |Title={{{title|}}}
 |CountryCode={{{country-code}}}
 |PublicationNumber={{{publication-number|{{{patent-number}}}}}}
 |Description={{{description|}}}
 |PublicationDate={{{publication-date|}}}
 |IssueDate={{{issue-date|}}}
 |Year={{{year}}}
}}&lt;!--
    CITATIONS FOR THINGS LIKE BOOKS AND PERIODICALS
--&gt;
|{{Citation/core
  |AuthorMask = {{{author-mask|{{{authormask|}}}}}}
  |Surname1 = {{{last|{{{surname|{{{last1|{{{surname1|{{{author1|{{{author|{{{authors|}}}}}}}}}}}}}}}}}}}}}
  |Surname2 = {{{last2|{{{surname2|{{{author2|}}}}}}}}}
  |Surname3 = {{{last3|{{{surname3|{{{author3|}}}}}}}}}
  |Surname4 = {{{last4|{{{surname4|{{{author4|}}}}}}}}}
  |Surname5 = {{{last5|{{{surname5|{{{author5|}}}}}}}}}
  |Surname6 = {{{last6|{{{surname6|{{{author6|}}}}}}}}}
  |Surname7 = {{{last7|{{{surname7|{{{author7|}}}}}}}}}
  |Surname8 = {{{last8|{{{surname8|{{{author8|}}}}}}}}}
  |Surname9 = {{{last9|{{{surname9|{{{author9|}}}}}}}}}
  |Given1 = {{{first1|{{{given1|{{{first|{{{given|}}}}}}}}}}}}
  |Given2 = {{{first2|{{{given2|}}}}}}
  |Given3 = {{{first3|{{{given3|}}}}}}
  |Given4 = {{{first4|{{{given4|}}}}}}
  |Given5 = {{{first5|{{{given5|}}}}}}
  |Given6 = {{{first6|{{{given6|}}}}}}
  |Given7 = {{{first7|{{{given7|}}}}}}
  |Given8 = {{{first8|{{{given8|}}}}}}
  |Given9 = {{{first9|{{{given9|}}}}}}
  |Authorlink1 = {{{author-link|{{{author1-link|{{{authorlink|{{{authorlink1|}}}}}}}}}}}}
  |Authorlink2 = {{{author2-link|{{{authorlink2|}}}}}}
  |Authorlink3 = {{{author3-link|{{{authorlink3|}}}}}}
  |Authorlink4 = {{{author4-link|{{{authorlink4|}}}}}}
  |Authorlink5 = {{{author5-link|{{{authorlink5|}}}}}}
  |Authorlink6 = {{{author6-link|{{{authorlink6|}}}}}}
  |Authorlink7 = {{{author7-link|{{{authorlink7|}}}}}}
  |Authorlink8 = {{{author8-link|{{{authorlink8|}}}}}}
  |Authorlink9 = {{{author9-link|{{{authorlink9|}}}}}}
  |Coauthors   = {{{coauthor|{{{coauthors|}}}}}}
  |Year={{{year|{{    &lt;!-- attempt to derive year from date, if possible --&gt;
             #if: {{{date|}}}
             |{{
                #iferror:{{#time:Y|{{{date|}}} }}
                |{{#iferror:{{#time:Y|{{{publication-date|einval}}} }}||{{#time:Y|{{{publication-date|}}} }}}}
                |{{#time:Y|{{{date|}}} }}
              }}
             |{{{publication-date|}}} &lt;!-- last resort --&gt;
           }}
        }}}
  |YearNote = {{{origyear|}}}
  |Date = {{#if:{{{date|}}}|{{{date}}}|{{{day|}}} {{{month|}}} {{{year|{{{publication-date|}}}}}}}}
  |DateFormat={{{dateformat|}}}
  |Title={{{title|}}}
  |URL={{#if:{{{archiveurl|}}}|{{{archiveurl|}}}|{{{url|}}}}}
  |Series={{{series|{{{version|}}}}}}
  |Periodical = {{{journal|{{{periodical|{{{newspaper|{{{magazine|{{{work|}}}}}}}}}}}}}}}
  |Volume = {{{volume|}}}
  |Issue = {{{issue|{{{number|}}}}}}
  |At = {{
          #if: {{{journal|{{{periodical|{{{newspaper|{{{magazine|}}}}}}}}}}}}
          |{{{pages|{{{page|{{{at|}}}}}}}}}
          |{{
             #if: {{{page|}}}
             |{{#if:{{{nopp|}}}||p.&amp;nbsp;}}{{{page}}} 
             |{{
                #if: {{{pages|}}}
                |{{#if:{{{nopp|}}}||pp.&amp;nbsp;}}{{{pages}}}
                |{{{at|}}}
              }}
           }}
        }}
  |IncludedWorkTitle = {{{chapter|{{{contribution|}}}}}}
  |IncludedWorkURL = {{{chapter-url|{{{chapterurl|{{{contribution-url|}}}}}}}}}
  |Other = {{{others|}}}
  |Edition = {{{edition|}}}
  |Place = {{{place|{{{location|}}}}}}
  |PublicationPlace = {{{publication-place|{{{place|{{{location|}}}}}}}}}
  |Publisher = {{{publisher|}}}
  |PublicationDate = {{{publication-date|}}}
  |EditorSurname1 = {{{editor-last|{{{editor-surname|{{{editor1-last|{{{editor1-surname|{{{editor1|{{{editor|{{{editors|}}}}}}}}}}}}}}}}}}}}}
  |EditorSurname2 = {{{editor2-last|{{{editor2-surname|{{{editor2|}}}}}}}}}
  |EditorSurname3 = {{{editor3-last|{{{editor3-surname|{{{editor3|}}}}}}}}}
  |EditorSurname4 = {{{editor4-last|{{{editor4-surname|{{{editor4|}}}}}}}}}
  |EditorGiven1 = {{{editor-first|{{{editor-given|{{{editor1-first|{{{editor1-given|}}}}}}}}}}}}
  |EditorGiven2={{{editor2-first|{{{editor2-given|}}}}}}
  |EditorGiven3={{{editor3-first|{{{editor3-given|}}}}}}
  |EditorGiven4={{{editor4-first|{{{editor4-given|}}}}}}
  |Editorlink1={{{editor-link|{{{editor1-link|}}}}}}
  |Editorlink2={{{editor2-link|}}}
  |Editorlink3={{{editor3-link|}}}
  |Editorlink4={{{editor4-link|}}}
  |language = {{{language|{{{in|}}}}}}
  |format = {{{format|}}}
  |ID={{{id|{{{ID|}}}}}}
  |ISBN={{{isbn|{{{ISBN|}}}}}}
  |ISSN={{{issn|{{{ISSN|}}}}}}
  |OCLC={{{oclc|{{{OCLC|}}}}}}
  |PMID={{{pmid|{{{PMID|}}}}}}
  |PMC={{{pmc|{{{PMC|}}}}}}
  |Embargo={{{pmc-embargo-date|1010-10-10}}}
  |Bibcode={{{bibcode|}}}
  |DOI={{{doi|{{{DOI|}}}}}}
  |DoiBroken={{{doi_brokendate|}}}
  |AccessDate={{{access-date|{{{accessdate|}}}}}}
  |laysummary = {{{laysummary|}}}
  |quote = {{{quote|}}}
  |laydate = {{{laydate|}}}
  |Ref={{{ref|harv}}}
  |Sep = {{#ifeq:{{{separator|{{{seperator}}}}}}|;|&amp;#059;|{{{separator|{{{seperator|,}}}}}}}}
  |PS = {{#if:{{{quote|}}}||{{{postscript|}}}}}
  |AuthorSep = {{#ifeq:{{{author-separator|}}}|;|&amp;#059;|{{{author-separator|&amp;#059;}}}}}&amp;#32;
  |NameSep = {{{author-name-separator|,}}}&amp;#32;
  |amp = {{{lastauthoramp|}}}
  |Trunc = {{#if:{{{display-authors|}}}|{{{display-authors}}}|8}}
  |ArchiveURL= {{{archiveurl|}}}
  |OriginalURL = {{{url|}}}|ArchiveDate= {{{archivedate|}}}
}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>s1q436zaeaag3ty9d9gt4b7rrbcmzba</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation/core</title>
    <ns>10</ns>
    <id>179448</id>
    <revision>
      <id>1777757</id>
      <parentid>1777756</parentid>
      <timestamp>2010-04-27T04:06:15Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Citation/core]]": Uses complex features of wiki syntax ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="24993" xml:space="preserve">&lt;span class="citation {{{Citation class|{{{Citation type|}}}}}}"
{{
  #switch:{{{Ref|}}}
  ||none =
  |#default = id="{{anchorencode:{{{Ref}}}}}"
  |harv = {{#if:{{{Surname1|}}}{{{EditorSurname1|}}}
    |id="CITEREF{{anchorencode:{{#if:{{{Surname1|}}}
      |{{{Surname1}}}{{{Surname2|}}}{{{Surname3|}}}{{{Surname4|}}}
      |{{{EditorSurname1|}}}{{{EditorSurname2|}}}{{{EditorSurname3|}}}{{{EditorSurname4|}}}
    }}{{{Year|{{{Date|}}}}}}}}"
  }}
}}&gt;{{
&lt;!--============  Author or editor and date  ============--&gt;
  #if:{{{Surname1|}}}
  |{{
     #if: {{{AuthorMask|}}}
     |{{
        #iferror: {{ #expr: 1*{{{AuthorMask}}} }}
        |{{{AuthorMask}}}
        |&lt;del&gt;{{loop|{{{AuthorMask}}}|2=&amp;emsp;}}&lt;/del&gt;
      }}
     |{{
        #if: {{{Authorlink1|}}}
        |[[w:{{{Authorlink1}}} |{{{Surname1}}}{{
          #if: {{{Given1|}}}
          |{{{NameSep|,&amp;#32;}}}{{{Given1}}}
         }}]]
        |{{{Surname1}}}{{
           #if: {{{Given1|}}}
           |{{{NameSep|,&amp;#32;}}}{{{Given1}}}
         }}
      }}
   }}{{
     #if: {{{Surname2|}}}
     |{{#ifexpr:{{{Trunc|8}}}&lt;2
       |&amp;#32;''et al''.
       |{{
          #iferror: {{ #expr: 1*0.0{{{AuthorMask|}}} }}
          |&amp;#32;&lt;!-- then punctuation should be included in AuthorMask --&gt;
          |{{
            #if: {{{Surname3|}}}
            |{{{AuthorSep|&amp;#059;&amp;#32;}}}
            |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
          }}
        }}{{
          #if: {{{Authorlink2|}}}
          |[[w:{{{Authorlink2}}} |{{{Surname2}}}{{
             #if: {{{Given2|}}}
             |{{{NameSep|,&amp;#32;}}}{{{Given2}}}
           }}]]
          |{{{Surname2}}}{{
             #if: {{{Given2|}}}
             |{{{NameSep|,&amp;#32;}}}{{{Given2}}}
           }}
        }}{{
          #if: {{{Surname3|}}}
          |{{#ifexpr:{{{Trunc|8}}}&lt;3
            |&amp;#32;''et al''.
            |{{
               #if: {{{Surname4|}}}
               |{{{AuthorSep|&amp;#059;&amp;#32;}}}
               |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
             }}{{
               #if: {{{Authorlink3|}}}
               |[[w:{{{Authorlink3}}} |{{{Surname3}}}{{
                  #if: {{{Given3|}}}
                  |{{{NameSep|,&amp;#32;}}}{{{Given3}}}
                }}]]
               |{{{Surname3}}}{{
                  #if: {{{Given3|}}}
                  |{{{NameSep|,&amp;#32;}}}{{{Given3}}}
                }}
             }}{{
               #if:{{{Surname4|}}}
               |{{#ifexpr:{{{Trunc|8}}}&lt;4
                 |&amp;#32;''et al''.
                 |{{
                    #if: {{{Surname5|}}}
                    |{{{AuthorSep|&amp;#059;&amp;#32;}}}
                    |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
                  }}{{
                    #if: {{{Authorlink4|}}}
                    |[[w:{{{Authorlink4}}} |{{{Surname4}}}{{
                       #if: {{{Given4|}}}
                       |{{{NameSep|,&amp;#32;}}}{{{Given4}}}
                     }}]]
                    |{{{Surname4}}}{{
                       #if: {{{Given4|}}}
                       |{{{NameSep|,&amp;#32;}}}{{{Given4}}}
                    }}
                  }}{{
                  #if:{{{Surname5|}}}
                  |{{#ifexpr:{{{Trunc|8}}}&lt;5
                    |&amp;#32;''et al''.
                    |{{
                     #if: {{{Surname6|}}}
                     |{{{AuthorSep|&amp;#059;&amp;#32;}}}
                     |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
                    }}{{
                     #if: {{{Authorlink5|}}}
                     |[[w:{{{Authorlink5}}} |{{{Surname5}}}{{
                        #if: {{{Given5|}}}
                        |{{{NameSep|,&amp;#32;}}}{{{Given5}}}
                      }}]]
                     |{{{Surname5}}}{{
                        #if: {{{Given5|}}}
                        |{{{NameSep|,&amp;#32;}}}{{{Given5}}}
                      }}
                   }}{{
                     #if:{{{Surname6|}}}
                     |{{#ifexpr:{{{Trunc|8}}}&lt;6
                     |&amp;#32;''et al''.
                      |{{
                        #if: {{{Surname7|}}}
                        |{{{AuthorSep|&amp;#059;&amp;#32;}}}
                        |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
                      }}{{
                        #if: {{{Authorlink6|}}}
                        |[[w:{{{Authorlink6}}} |{{{Surname6}}}{{
                           #if: {{{Given6|}}}
                           |{{{NameSep|,&amp;#32;}}}{{{Given6}}}
                         }}]]
                        |{{{Surname6}}}{{
                           #if: {{{Given6|}}}
                           |{{{NameSep|,&amp;#32;}}}{{{Given6}}}
                         }}
                      }}{{
                        #if:{{{Surname7|}}}
                         |{{#ifexpr:{{{Trunc|8}}}&lt;7
                           |&amp;#32;''et al''.
                        |{{
                           #if: {{{Surname8|}}}
                           |{{{AuthorSep|&amp;#059;&amp;#32;}}}
                           |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
                         }}{{
                           #if: {{{Authorlink7|}}}
                           |[[w:{{{Authorlink7}}} |{{{Surname7}}}{{
                              #if: {{{Given7|}}}
                              |{{{NameSep|,&amp;#32;}}}{{{Given7}}}
                            }}]]
                           |{{{Surname7}}}{{
                              #if: {{{Given7|}}}
                              |{{{NameSep|,&amp;#32;}}}{{{Given7}}}
                            }}
                                    }}{{
                                       #if:{{{Surname8|}}}
                                       |{{#ifexpr:{{{Trunc|8}}}&lt;8
                                           |&amp;#32;''et al''.
                                           |{{
                                              #if: {{{Surname9|}}}
                                              |{{{AuthorSep|&amp;#059;&amp;#32;}}}
                                              |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
                                            }}{{
                                              #if: {{{Authorlink8|}}}
                                              |[[w:{{{Authorlink8}}} |{{{Surname8}}}{{
                                                 #if: {{{Given8|}}}
                                                 |{{{NameSep|,&amp;#32;}}}{{{Given8}}}
                                               }}]]
                                              |{{{Surname8}}}{{
                                                 #if: {{{Given8|}}}
                                                 |{{{NameSep|,&amp;#32;}}}{{{Given8}}}
                                               }}
                                            }}{{
                                              #if:{{{Surname9|}}}
                                              |&amp;#32;''et al''.
                                            }}
                                         }}
                                      }}
                                   }}
                                }}
                             }}
                          }}
                       }}
                     }}
                  }}
               }}
            }}
         }}
      }}

   }}{{
     #if: {{{Coauthors|}}}
     |{{{AuthorSep|&amp;#059;&amp;#32;}}}{{{Coauthors|}}}|
   }}{{
     #if: {{{Date|}}}
     |&amp;#32;({{{Date}}}){{
       #if:{{{YearNote|}}}
     |&amp;#32;[{{{YearNote}}}]
     }}
   }}
  |{{&lt;!-- ============== No author: display editors first == --&gt;
     #if: {{{EditorSurname1|}}}
     |{{
        #if: {{{Editorlink1|}}}
        |[[w:{{{Editorlink1}}} |{{{EditorSurname1}}}{{
           #if: {{{EditorGiven1|}}}
           |, {{{EditorGiven1}}}
         }}]]
        |{{{EditorSurname1}}}{{
           #if: {{{EditorGiven1|}}}
           |, {{{EditorGiven1}}}
         }}
      }}{{
        #if: {{{EditorSurname2|}}}
        |{{
          #if: {{{EditorSurname3|}}}
          |{{{AuthorSep|&amp;#059;&amp;#32;}}}
          |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
        }}{{
           #if: {{{Editorlink2|}}}
           |[[w:{{{Editorlink2}}} |{{{EditorSurname2}}}{{
              #if: {{{EditorGiven2|}}}
              |, {{{EditorGiven2}}}
            }}]]
           |{{{EditorSurname2}}}{{
              #if: {{{EditorGiven2|}}}
              |, {{{EditorGiven2}}}
            }}
         }}{{
           #if: {{{EditorSurname3|}}}
           |{{
              #if: {{{EditorSurname4|}}}
              |{{{AuthorSep|&amp;#059;&amp;#32;}}}
              |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
            }}{{
              #if: {{{Editorlink3|}}}
              |[[w:{{{Editorlink3}}} |{{{EditorSurname3}}}{{
                 #if: {{{EditorGiven3|}}}
                 |, {{{EditorGiven3}}}
               }}]]
              |{{{EditorSurname3}}}{{
                 #if: {{{EditorGiven3|}}}
                 |, {{{EditorGiven3}}}
               }}
            }}{{
              #if:{{{EditorSurname4|}}}
              |&amp;#32;et al.
            }}
         }}
       }}, ed{{#if:{{{EditorSurname2|}}}|s}}{{#ifeq:{{{Sep|,}}}|.||.}}{{
        #if: {{{Date|}}}
        |&amp;#32;({{{Date}}}){{
         #if:{{{YearNote|}}}
       |&amp;#32;[{{{YearNote}}}]
       }}
      }}
   }}
}}{{
&lt;!--============  Title of included work  ============--&gt;
  #if: {{{IncludedWorkTitle|}}}{{#if:{{{Periodical|}}}||{{#if:{{{TransItalic|}}}||{{{TransTitle|}}}}}}}
  |{{
     #if:{{{Surname1|}}}{{{EditorSurname1|}}}
     |{{{Sep|,}}}&amp;#32;
   }}{{Citation/make link
     | 1={{
           #if: {{{IncludedWorkURL|}}}
           |{{{IncludedWorkURL}}}
           |{{
              #if: {{{URL|}}}
              |{{{URL}}}
&lt;!-- Only link URL if to a free full text - as at PubMedCentral (PMC)--&gt;
              |{{#ifexpr:{{#time: U}} &gt; {{#time: U | {{{Embargo|2001-10-10}}} }}
                |{{
                   #if: {{{PMC|}}}
                   |http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pmcentrez&amp;artid={{{PMC}}}
                 }}
               }}
            }}
         }}
     | 2={{
           #if: {{{Periodical|}}}
           |''&lt;nowiki /&gt;{{{IncludedWorkTitle}}}&lt;nowiki /&gt;''
           |"{{{IncludedWorkTitle|}}}{{
             #if: {{{TransTitle|}}}
             |{{
                #if: {{{IncludedWorkTitle|}}}
                |&amp;#32;
              }}&amp;#91;{{{TransTitle}}}&amp;#93;
           }}"
         }}
   }}
}}{{
&lt;!--============  Place (if different than PublicationPlace) ============--&gt;
  #if: {{{Place|}}}
  |{{
     #ifeq: {{{Place|}}} | {{{PublicationPlace|}}}
     |
     |{{
        #if: {{{Surname1|}}}{{{EditorSurname1|}}}{{{IncludedWorkTitle|}}}
        |{{{Sep|,}}}&amp;#32;written at {{{Place}}}
      }}
   }}
}}{{
&lt;!--============  Editor of compilation  ============--&gt;
  #if: {{{EditorSurname1|}}}
  |{{
     #if: {{{Surname1|}}}
     |{{{Sep|,}}}&amp;#32;{{
        #if: {{{IncludedWorkTitle|}}}
        |in&amp;#32;
      }}{{
        #if: {{{Editorlink1|}}}
        |[[w:{{{Editorlink1}}} |{{{EditorSurname1}}}{{
           #if: {{{EditorGiven1|}}}
           |, {{{EditorGiven1}}}
         }}]]
        |{{{EditorSurname1}}}{{
           #if: {{{EditorGiven1|}}}
           |, {{{EditorGiven1}}}
         }}}}{{
        #if: {{{EditorSurname2|}}}
        |{{
          #if: {{{EditorSurname3|}}}
            |{{{AuthorSep|&amp;#059;&amp;#32;}}}
            |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
          }}{{
           #if: {{{Editorlink2|}}}
           |[[w:{{{Editorlink2}}}|{{{EditorSurname2}}}{{
              #if: {{{EditorGiven2|}}}
              |, {{{EditorGiven2}}}
            }}]]
           |{{{EditorSurname2}}}{{
              #if: {{{EditorGiven2|}}}
              |, {{{EditorGiven2}}}
            }}
         }}{{
           #if: {{{EditorSurname3|}}}
           |{{
              #if: {{{EditorSurname4|}}}
              |&amp;#059;&amp;#32;
              |{{#if:{{{amp|}}}|&amp;#32;&amp;amp;&amp;#32;|{{{AuthorSep|&amp;#059;&amp;#32;}}}}}
            }}{{
              #if: {{{Editorlink3|}}}
              |[[w:{{{Editorlink3}}}|{{{EditorSurname3}}}{{
                 #if: {{{EditorGiven3|}}}
                 |, {{{EditorGiven3}}}
               }}]]
              |{{{EditorSurname3}}}{{
                 #if: {{{EditorGiven3|}}}
                 |, {{{EditorGiven3}}}
               }}
            }}{{
              #if:{{{EditorSurname4|}}}
              |&amp;#32;et al.
            }}
         }}
      }}{{
        #if: {{{IncludedWorkTitle|}}}
        |
        |{{{Sep|,}}}&amp;#32;ed{{#if:{{{EditorSurname2|}}}|s}}{{#ifeq:{{{Sep|,}}}|.||.}}
      }}
   }}
}}{{
  &lt;!--============  Periodicals  ============--&gt;
  #if: {{{Periodical|}}}
  |{{
     #if: {{{Other|}}}
     |{{{Sep|,}}}&amp;#32;{{{Other|}}}
   }}{{
     #if: {{{Surname1|}}}{{{EditorSurname1|}}}{{{IncludedWorkTitle|}}}
     |{{{Sep|,}}}&amp;#32;}}{{
     #if: {{{Title|}}}{{{TransTitle|}}}
     |{{Citation/make link
        | 1={{
              #if: {{{IncludedWorkTitle|}}}
              |{{
                 #if: {{{IncludedWorkURL|}}}
                 |{{
                    #if: {{{URL|}}}
                    |{{{URL}}}
                    |{{
                       #ifexpr: {{#time: U}} &gt; {{#time: U | {{{Embargo|2001-10-10}}} }} | {{
                         #if: {{{PMC|}}}
                         |  http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pmcentrez&amp;artid={{{PMC}}}
                       }}
                     }}
                  }}
               }}
              |{{
                 #if: {{{URL|}}}
                 |{{{URL}}}
                 |{{#ifexpr:{{#time: U}} &gt; {{#time: U | {{{Embargo|2001-10-10}}} }} |{{
                       #if: {{{PMC|}}}
                       |  http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pmcentrez&amp;artid={{{PMC}}}
                    }}
                 }}
               }}
            }}
        | 2="{{{Title}}}{{
          #if: {{{TransTitle|}}}
          |{{
             #if: {{{Title|}}}
             |&amp;#32;
           }}&amp;#91;{{{TransTitle}}}&amp;#93;
        }}"
      }}{{
        #if: {{{TitleNote|}}}
        |{{{Sep|,}}}&amp;#32;{{{TitleNote}}}
      }}
   }}
}}{{
  #if: {{{language|}}}
  |&amp;#32;(in {{{language}}})
}}{{
  #if: {{{format|}}}
  |&amp;#32;({{{format}}})
}}{{
   #if: {{{Periodical|}}}
   |{{
      #if:{{{IncludedWorkTitle|}}}{{{Title|}}}{{{TransTitle|}}}
      |{{{Sep|,}}}&amp;#32;
    }}''&lt;nowiki /&gt;{{{Periodical}}}&lt;nowiki /&gt;''{{
      #if: {{{Series|}}}
      |{{{Sep|,}}}&amp;#32;{{{Series}}}
    }}{{
      #if: {{{PublicationPlace|}}}
      |{{
         #if: {{{Publisher|}}}
         |&amp;#32;({{{PublicationPlace}}}&lt;nowiki&gt;: &lt;/nowiki&gt;{{{Publisher}}})
         |&amp;#32;({{{PublicationPlace}}})
       }}
      |{{
         #if: {{{Publisher|}}}
         |&amp;#32;({{{Publisher}}})
       }}
    }}{{
      #if: {{{Volume|}}}
      |&amp;#32;'''&lt;nowiki /&gt;{{{Volume}}}&lt;nowiki /&gt;'''{{
         #if: {{{Issue|}}}
         |&amp;#32;({{{Issue}}})
       }}
      |{{
         #if: {{{Issue|}}}
         |&amp;#32;({{{Issue}}})
       }}
    }}{{
      #if: {{{At|}}}
      |&lt;nowiki&gt;: &lt;/nowiki&gt; {{{At}}}
    }}
   |{{
      &lt;!--============ Anything else with a title, including books ============--&gt;
      #if: {{{Title|}}}{{{TransItalic|}}}
      |{{
         #if: {{{Surname1|}}}{{{EditorSurname1|}}}{{{IncludedWorkTitle|}}}{{{Periodical|}}}
         |{{{Sep|,}}}
       }}&amp;#32;{{Citation/make link
         | 1={{
               #if: {{{IncludedWorkTitle|}}}
               |{{
                  #if: {{{IncludedWorkURL|}}}
                  |{{
                     #if: {{{URL|}}}
                     |{{{URL}}}
                     |{{#ifexpr:{{#time: U}} &gt; {{#time: U | {{{Embargo|2001-10-10}}} }}|{{
                        #if: {{{PMC|}}}
                        |  http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pmcentrez&amp;artid={{{PMC}}}
                      }}}}
                   }}
                }}
               |{{
                  #if: {{{URL|}}}
                  |{{{URL}}}
                                |{{#ifexpr:{{#time: U}} &gt; {{#time: U | {{{Embargo|2001-10-10}}} }}|{{
                     #if: {{{PMC|}}}
                     |  http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pmcentrez&amp;artid={{{PMC}}}
                   }}}}
                }}
             }}
         | 2=''&lt;nowiki /&gt;{{{Title|}}}{{
            #if:{{{TransItalic|}}}|&amp;#32;&amp;#91;{{{TransItalic}}}&amp;#93;
          }}&lt;nowiki /&gt;''
       }}
    }}{{
      #if: {{{TitleType|}}}
      |&amp;#32;({{{TitleType}}})
    }}{{
      #if: {{{Series|}}}
      |{{{Sep|,}}}&amp;#32;{{{Series}}}
    }}{{
      #if: {{{Volume|}}}
      |{{{Sep|,}}}&amp;#32;'''&lt;nowiki /&gt;{{{Volume}}}&lt;nowiki /&gt;'''
    }}{{
      #if: {{{Other|}}}
      |{{{Sep|,}}}&amp;#32;{{{Other|}}}
    }}{{
      #if: {{{Edition|}}}
      |&amp;#32;({{{Edition}}} ed.)
    }}{{
      #if: {{{PublicationPlace|}}}
      |{{{Sep|,}}}&amp;#32;{{{PublicationPlace}}}
    }}{{
      #if: {{{Publisher|}}}
      |{{
         #if: {{{PublicationPlace|}}}
         |&lt;nowiki&gt;:&lt;/nowiki&gt;
         |{{{Sep|,}}}
       }}&amp;#32;{{{Publisher}}}
    }}
}}{{
&lt;!--============ Date (if no author/editor) ============--&gt;
  #if: {{{Surname1|}}}{{{EditorSurname1|}}}
  |
  |{{
     #if: {{{Date|}}}
     |{{{Sep|,}}}&amp;#32;{{{Date}}}{{
       #if:{{{YearNote|}}}
     |&amp;#32;[{{{YearNote}}}]
     }}
   }}
}}{{
&lt;!--============ Publication date ============--&gt;
  #if: {{{PublicationDate|}}}
  |{{
     #ifeq: {{{PublicationDate|}}} | {{{Date|}}}
     |
     |{{
        #if: {{{EditorSurname1|}}}
        |{{
           #if: {{{Surname1|}}}
           |{{{Sep|,}}}&amp;#32;{{{PublicationDate}}}
           |&amp;#32;(published {{{PublicationDate}}})
         }}
        |{{
           #if: {{{Periodical|}}}
           |{{{Sep|,}}}&amp;#32;{{{PublicationDate}}}
           |&amp;#32;(published {{{PublicationDate}}})
         }}
      }}
   }}
}}{{
&lt;!--============ Page within included work ============--&gt;
  #if: {{{Periodical|}}}
  |
  |{{
     #if: {{{At|}}}
     |{{{Sep|,}}}&amp;#32;{{{At}}}
   }}
}}{{
&lt;!--===============DOI================--&gt;
#if:{{{DOI|}}}
  |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=doi |input1={{{DOI|}}}  |input2={{{DoiBroken|}}} }}
}}{{
&lt;!--============  Misc. Identifier ============--&gt;
  #if: {{{ID|}}}
  |{{
     #if: {{{Surname1|}}}{{{EditorSurname1|}}}{{{IncludedWorkTitle|}}}{{{Periodical|}}}{{{Title|}}}{{{TransItalic|}}}
     |{{{Sep|,}}}&amp;#32;{{{ID}}}
     |{{{ID}}}
   }}
}}{{
&lt;!--============  ISBN ============--&gt;
  #if: {{{ISBN|}}}
  |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=isbn |input1={{{ISBN|}}} }}
}}{{
&lt;!--============  ISSN ============--&gt;
  #if: {{{ISSN|}}}
  |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=issn |input1={{{ISSN|}}} }}
}}{{
&lt;!--============  OCLC ============--&gt;
  #if: {{{OCLC|}}}
  |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=oclc |input1={{{OCLC|}}} }}
}}{{
&lt;!--============  PMID ============--&gt;
  #if: {{{PMID|}}}
  |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=pmid |input1={{{PMID|}}} }}
}}{{
&lt;!--============  PMC ============--&gt;
  #if: {{{PMC|}}}
  |{{
     #if: {{{URL|}}}
     |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=pmc |input1={{{PMC|}}} }}
     |{{only in  print|{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=pmc |input1={{{PMC|}}} }} }}&lt;!--Should  only display by default in print--&gt;
   }}
}}{{
&lt;!--============ BIBCODE ============--&gt;
  #if: {{{Bibcode|}}}
  |{{{Sep|,}}}&amp;#32;{{citation/identifier  |identifier=bibcode |input1={{{Bibcode|}}} }}
}}{{
&lt;!--============  Archive data, etc ===========--&gt;
#if: {{{Archive|}}}
|{{{Sep|,}}}&amp;#32;{{{Archive}}}
|{{
  #if:{{{ArchiveURL|}}}{{{ArchiveDate|}}}
  |{{{Sep|,}}}&amp;#32;{{#ifeq:{{{Sep}}}|.|A|a}}rchived{{
    #if:{{{OriginalURL|}}}{{{IncludedWorkURL|}}}
    |{{#if:{{{ArchiveURL|}}}|&amp;#32;from {{Citation/make link|{{{OriginalURL|{{{IncludedWorkURL|}}}}}}|the original}}}}
    }}{{
    #if:{{{ArchiveDate|}}}
    |&amp;#32;on {{{ArchiveDate}}}
    }}{{
    #if:{{#if:{{{ArchiveURL|}}}||A}}{{#if:{{{OriginalURL|}}}{{{IncludedWorkURL|}}}||B}}{{#if:{{{ArchiveDate|}}}||C}}
    |. {{citation error
       |If you specify &lt;code&gt;&amp;#124;{{#if:{{{ArchiveURL|}}}|archiveurl|archivedate}}&amp;#61;&lt;/code&gt;, you must {{#if:{{{OriginalURL|}}}{{{IncludedWorkURL|}}}| also specify &lt;code&gt;&amp;#124;{{#if:{{{ArchiveURL|}}}|archivedate|archiveurl}}&amp;#61;&lt;/code&gt;|first specify &lt;code&gt;&amp;#124;url&amp;#61;&lt;/code&gt;}}}}
    }}
  }}
}}{{
&lt;!--============ URL and AccessDate ============--&gt;
  #if: {{{URL|}}}{{{IncludedWorkURL|}}}
  |{{
     #if: {{{Title|}}}{{{IncludedWorkTitle|}}}{{{TransTitle|}}}
     |&lt;span class="printonly"&gt;{{{Sep|,}}}&amp;#32;{{
                                      #if: {{{IncludedWorkURL|}}}
                                      |{{{IncludedWorkURL}}}
                                      |{{{URL}}}
                                    }}&lt;/span&gt;
     |{{{Sep|,}}}&amp;#32;{{
              #if: {{{IncludedWorkURL|}}}
              |{{{IncludedWorkURL}}}
              |{{{URL}}}
            }}
   }}{{
     #if: {{{AccessDate|}}}
     | &lt;span class="reference-accessdate"&gt;{{#ifeq:{{{Sep|,}}}|,|,&amp;#32;r|.&amp;#32;R}}etrieved {{{AccessDate}}}&lt;/span&gt;
     }}
}}{{#if:{{{laysummary|}}}
  |{{{Sep|,}}}&amp;#32;[{{{laysummary}}} Lay summary]{{#if: {{{laysource|}}}|&amp;nbsp;&amp;ndash;&amp;nbsp;''&lt;nowiki /&gt;{{{laysource}}}&lt;nowiki /&gt;''}}
}}{{#if:{{{laydate|}}}
  | &amp;#32;({{{laydate}}})
}}{{#if:{{{quote|}}}
  |{{{Sep|,}}}&amp;#32;"{{{quote}}}"
}}{{{PS|}}}&lt;/span&gt;&lt;!--

=== This is a COinS tag (http://ocoins.info), which allows automated tools to parse the citation information: ===

--&gt;&lt;span
    class="Z3988"
    title="ctx_ver=Z39.88-2004&amp;rft_val_fmt={{urlencode:info:ofi/fmt:kev:mtx:}}{{
      #if: {{{Periodical|}}}
      |journal&amp;rft.genre=article&amp;rft.atitle={{urlencode:{{{Title|}}}}}&amp;rft.jtitle={{urlencode:{{{Periodical|}}}}}
      |book{{
         #if: {{{IncludedWorkTitle|}}}
         |&amp;rft.genre=bookitem&amp;rft.btitle={{urlencode:{{{IncludedWorkTitle|}}}}}&amp;rft.atitle={{urlencode:{{{Title|}}}}}
         |&amp;rft.genre=book&amp;rft.btitle={{urlencode:{{{Title|}}}}}
       }}
    }}{{
     #if: {{{Surname1|}}} |&amp;rft.aulast={{urlencode:{{{Surname1}}}}}{{
       #if: {{{Given1|}}} |&amp;rft.aufirst={{urlencode:{{{Given1}}}}}
     }}
   }}{{
     #if: {{{Surname1|}}} |&amp;rft.au={{urlencode:{{{Surname1}}}}}{{
       #if: {{{Given1|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given1}}}}}
     }}
   }}{{
     #if: {{{Surname2|}}} |&amp;rft.au={{urlencode:{{{Surname2}}}}}{{
       #if: {{{Given2|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given2}}}}}
     }}
   }}{{
     #if: {{{Surname3|}}} |&amp;rft.au={{urlencode:{{{Surname3}}}}}{{
       #if: {{{Given3|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given3}}}}}
     }}
   }}{{
     #if: {{{Surname4|}}} |&amp;rft.au={{urlencode:{{{Surname4}}}}}{{
       #if: {{{Given4|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given4}}}}}
     }}
   }}{{
     #if: {{{Surname5|}}} |&amp;rft.au={{urlencode:{{{Surname5}}}}}{{
       #if: {{{Given5|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given5}}}}}
     }}
   }}{{
     #if: {{{Surname6|}}} |&amp;rft.au={{urlencode:{{{Surname6}}}}}{{
       #if: {{{Given6|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given6}}}}}
     }}
   }}{{
     #if: {{{Surname7|}}} |&amp;rft.au={{urlencode:{{{Surname7}}}}}{{
       #if: {{{Given7|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given7}}}}}
     }}
   }}{{
     #if: {{{Surname8|}}} |&amp;rft.au={{urlencode:{{{Surname8}}}}}{{
       #if: {{{Given8|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given8}}}}}
     }}
   }}{{
     #if: {{{Surname9|}}} |&amp;rft.au={{urlencode:{{{Surname9}}}}}{{
       #if: {{{Given9|}}} |{{urlencode:{{{NameSep|,&amp;#32;}}}{{{Given9}}}}}
     }}
    }}{{
      #if: {{{Date|}}} |&amp;rft.date={{urlencode:{{{Date}}}}}
    }}{{
      #if: {{{Series|}}} |&amp;rft.series={{urlencode:{{{Series}}}}}
    }}{{
      #if: {{{Volume|}}} |&amp;rft.volume={{urlencode:{{{Volume}}}}}
    }}{{
      #if: {{{Issue|}}} |&amp;rft.issue={{urlencode:{{{Issue}}}}}
    }}{{
      #if: {{{At|}}} |&amp;rft.pages={{urlencode:{{{At}}}}}
    }}{{
      #if: {{{Edition|}}} |&amp;rft.edition={{urlencode:{{{Edition}}}}}
    }}{{
      #if: {{{PublicationPlace|}}}{{{Place|}}} |&amp;rft.place={{urlencode:{{{PublicationPlace|{{{Place}}}}}}}}
    }}{{
      #if: {{{Publisher|}}} |&amp;rft.pub={{urlencode:{{{Publisher}}}}}
    }}{{
      #if: {{{DOI|}}} |&amp;rft_id=info:doi/{{urlencode:{{{DOI}}}}}
    }}{{
      #if: {{{PMID|}}} |&amp;rft_id=info:pmid/{{urlencode:{{{PMID}}}}}
    }}{{
      #if: {{{Bibcode|}}} |&amp;rft_id=info:bibcode/{{urlencode:{{{Bibcode}}}}}
    }}{{
      #if: {{{OCLC|}}} |&amp;rft_id=info:oclcnum/{{urlencode:{{{OCLC}}}}}
    }}{{
      #if: {{{ISBN|}}} |&amp;rft.isbn={{urlencode:{{{ISBN}}}}}
    }}{{
      #if: {{{ISSN|}}} |&amp;rft.issn={{urlencode:{{{ISSN}}}}}
    }}{{
      #if: {{{URL|}}}{{{IncludedWorkURL|}}} |&amp;rft_id={{urlencode:{{{URL|{{{IncludedWorkURL|}}}}}}}}
    }}&amp;rfr_id=info:sid/en.wikibooks.org:{{FULLPAGENAMEE}}"&gt;&lt;span style="display: none;"&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>f534q1qq5nzb4bi2ovhzuheo8hfy5pi</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation/identifier</title>
    <ns>10</ns>
    <id>225332</id>
    <revision>
      <id>1778209</id>
      <parentid>1777999</parentid>
      <timestamp>2010-04-27T13:42:36Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>fixed links</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3568" xml:space="preserve">{{#switch:{{{identifier}}}
 |arxiv={{hide in print
         |[[w:arXiv|arXiv]]:[http://arxiv.org/abs/{{{input1|}}}{{{input2|}}} {{{input1|}}}{{{input2|}}}]&lt;!--
          --&gt;{{#if:{{{input3|}}}
              |&amp;nbsp;[{{{input3|}}}]
              |
             }}
        }}&lt;!--
     --&gt;{{only in print
         |arXiv:{{{input1|}}}{{{input2|}}}&lt;!--
          --&gt;{{#if:{{{input3|}}}
              |&amp;nbsp;[{{{input3|}}}]
              |
             }}
        }}
 |doi={{hide in print
       |{{#if:{{{input2|}}}
         |[[w:Digital object identifier|doi]]:{{{input1|}}} (inactive {{{input2|}}}) {{#ifeq: {{NAMESPACE}} | {{ns:0}}
                   |[[Category:Pages with DOIs broken since {{#time: Y | {{{input2|}}} }}]]
                   |
                  }}
         |[[w:Digital object identifier|doi]]:[http://dx.doi.org/{{urlencode:{{{input1|}}}}} {{{input1|}}}]
        }}
      }}&lt;!--
   --&gt;{{only in print
       |{{#if:{{{input2|}}}
         |doi:{{{input1|}}} (inactive {{{input2|}}})
         |doi:{{{input1|}}}
        }}
      }}
 |asin={{hide in print
        |[[w:Amazon Standard Identification Number|ASIN]]&amp;nbsp;[http://www.amazon.com/dp/{{{input1|}}} {{{input1|}}}]
       }}&lt;!--
    --&gt;{{only in print
        |ASIN&amp;nbsp;{{{input1|}}}
       }}
 |bibcode={{hide in print
           |[[w:Bibcode|Bibcode]]:&amp;nbsp;[http://adsabs.harvard.edu/abs/{{{input1|}}} {{{input1|}}}]
          }}&lt;!--
       --&gt;{{only in print
           |Bibcode:&amp;nbsp;{{{input1|}}}
          }}
 |jfm={{hide in print
       |[[w:Jahrbuch über die Fortschritte der Mathematik|JFM]]&amp;nbsp;[http://www.zentralblatt-math.org/zmath/en/search/?q{{=}}an:{{{input1|}}}&amp;format{{=}}complete {{{input1|}}}]
      }}&lt;!--
   --&gt;{{only in print
       |JFM&amp;nbsp;{{{input1|}}}
      }}
 |jstor={{hide in print
         |[[w:JSTOR|JSTOR]]&amp;nbsp;[http://www.jstor.org/stable/{{{input1|}}} {{{input1|}}}]
        }}&lt;!--
     --&gt;{{only in print
         |JSTOR&amp;nbsp;{{{input1|}}}
         }}
 |isbn={{hide in print
        |[[w:International Standard Book Number|ISBN]]&amp;nbsp;[[Special:BookSources/{{{input1|}}}|{{{input1|}}}]]
       }}&lt;!--
    --&gt;{{only in print
        |ISBN&amp;nbsp;{{{input1|}}}
       }}
 |issn={{hide in print
        |[[w:International Standard Serial Number|ISSN]]&amp;nbsp;[http://www.worldcat.org/issn/{{{input1|}}} {{{input1|}}}]
       }}&lt;!--
    --&gt;{{only in print
        |ISSN&amp;nbsp;{{{input1|}}}
       }}
 |mr={{hide in print
      |[[w:Mathematical Reviews|MR]][http://www.ams.org/mathscinet-getitem?mr{{=}}{{{input1|}}} {{{input1|}}}]
     }}&lt;!--
  --&gt;{{only in print
      |MR{{{input1|}}}
     }}
 |oclc={{hide in print
        |[[w:Online Computer Library Center|OCLC]]&amp;nbsp;[http://www.worldcat.org/oclc/{{{input1|}}} {{{input1|}}}]
       }}&lt;!--
    --&gt;{{only in print
        |OCLC&amp;nbsp;{{{input1|}}}
       }}
 |pmc={{hide in print
       |[[w:PubMed Central|PMC]]&amp;nbsp;[http://www.pubmedcentral.gov/articlerender.fcgi?tool{{=}}pmcentrez&amp;artid{{=}}{{{input1|}}} {{{input1|}}}] 
      }}&lt;!--
   --&gt;{{only in print
       |PMC&amp;nbsp;{{{input1|}}}
      }}
 |pmid={{hide in print
        |[[w:PubMed Identifier|PMID]]&amp;nbsp;[http://www.ncbi.nlm.nih.gov/pubmed/{{{input1|}}} {{{input1|}}}]
       }}&lt;!--
    --&gt;{{only in print
        |PMID&amp;nbsp;{{{input1|}}}
       }}
 |zbl={{hide in print
        |[[w:Zentralblatt MATH|ZBL]]&amp;nbsp;[http://www.zentralblatt-math.org/zmath/en/search/?q{{=}}an:{{{input1|}}}&amp;format{{=}}complete {{{input1|}}}]
       }}&lt;!--
    --&gt;{{only in print
        |ZBL&amp;nbsp;{{{input1|}}}
       }}
}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>87h9307qvwh4p44dbglfz1ab3icnnzt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation/make link</title>
    <ns>10</ns>
    <id>225330</id>
    <revision>
      <id>1777964</id>
      <parentid>1777950</parentid>
      <timestamp>2010-04-27T13:10:40Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Citation/make link]]": Uses complex features of wiki syntax ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="535" xml:space="preserve">{{#if:{{{1|}}}
 |[{{{1}}} {{{2}}}]
 |{{{2}}}
}}&lt;noinclude&gt;&lt;!--
  Code notes (here so that people /read/ it)
  1. Parameter #2 is always nonempty when called from {{Citation/core}}.
  2. It's up to {{Citation/core}} to stop italicized "'foo' &amp; 'bar'" from becoming
     "'''foo' &amp; 'bar'''". Citation/core does this by having a &lt;nowiki&gt;&lt;/nowiki&gt;
     at both beginning and end of the call to this template. Since this is only
     needed once, it's more efficient to do it in {{Citation/core}} than here.
--&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>kpq1iofpfn0fdo5bshpu1vjve3ehx2d</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Citation needed</title>
    <ns>10</ns>
    <id>72306</id>
    <revision>
      <id>2182425</id>
      <parentid>2182418</parentid>
      <timestamp>2011-10-14T21:14:17Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Citation needed]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="453" xml:space="preserve">{{ {{{|safesubst:}}}ifsubst |&lt;includeonly&gt;{{subst:Unsubst|Citation needed| name|{{{name|¬}}}|reason|{{{reason|¬}}}| date|{{{date|{{subst:CURRENTMONTHNAME}} {{subst:CURRENTYEAR}}}}} }}&lt;/includeonly&gt;|
{{Fix
|name={{{name|Citation needed}}}
|link=WB:OR
|text=citation needed
|class=Template-Fact
|title=This claim needs references to reliable sources
|date={{{date|}}}
|cat=[[Category:Pages needing sources]]
}}
}}&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>5dcw863ups9lqblblw7re3ncvu0f2ca</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite journal</title>
    <ns>10</ns>
    <id>86694</id>
    <revision>
      <id>1779566</id>
      <parentid>1779565</parentid>
      <timestamp>2010-04-27T20:44:38Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Cite journal]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5013" xml:space="preserve">&lt;includeonly&gt;{{Citation/core
  |Citation type=Journal
  |AuthorMask = {{{author-mask|{{{authormask|}}}}}}
  |Surname1 = {{{last|{{{surname|{{{last1|{{{surname1|{{{author1|{{{author|{{{authors|{{{author|}}}}}}}}}}}}}}}}}}}}}}}}
  |Surname2 = {{{last2|{{{surname2|{{{author2|}}}}}}}}}
  |Surname3 = {{{last3|{{{surname3|{{{author3|}}}}}}}}}
  |Surname4 = {{{last4|{{{surname4|{{{author4|}}}}}}}}}
  |Surname5 = {{{last5|{{{surname5|{{{author5|}}}}}}}}}
  |Surname6 = {{{last6|{{{surname6|{{{author6|}}}}}}}}}
  |Surname7 = {{{last7|{{{surname7|{{{author7|}}}}}}}}}
  |Surname8 = {{{last8|{{{surname8|{{{author8|}}}}}}}}}
  |Surname9 = {{{last9|{{{surname9|{{{author9|}}}}}}}}}
  |Given1 = {{{first1|{{{given1|{{{first|{{{given|}}}}}}}}}}}}
  |Given2 = {{{first2|{{{given2|}}}}}}
  |Given3 = {{{first3|{{{given3|}}}}}}
  |Given4 = {{{first4|{{{given4|}}}}}}
  |Given5 = {{{first5|{{{given5|}}}}}}
  |Given6 = {{{first6|{{{given6|}}}}}}
  |Given7 = {{{first7|{{{given7|}}}}}}
  |Given8 = {{{first8|{{{given8|}}}}}}
  |Given9 = {{{first9|{{{given9|}}}}}}
  |Authorlink1 = {{{author-link|{{{author1-link|{{{authorlink|{{{authorlink1|}}}}}}}}}}}}
  |Authorlink2 = {{{author2-link|{{{authorlink2|}}}}}}
  |Authorlink3 = {{{author3-link|{{{authorlink3|}}}}}}
  |Authorlink4 = {{{author4-link|{{{authorlink4|}}}}}}
  |Authorlink5 = {{{author5-link|{{{authorlink5|}}}}}}
  |Authorlink6 = {{{author6-link|{{{authorlink6|}}}}}}
  |Authorlink7 = {{{author7-link|{{{authorlink7|}}}}}}
  |Authorlink8 = {{{author8-link|{{{authorlink8|}}}}}}
  |Authorlink9 = {{{author9-link|{{{authorlink9|}}}}}}
  |Coauthors = {{{coauthor|{{{coauthors|}}}}}}
  |Year={{{year|{{    &lt;!-- attempt to derive year from date, if possible --&gt;
             #if: {{{date|}}}
             |{{
                #iferror:{{#time:Y|{{{date|}}} }}
                |{{#iferror:{{#time:Y|{{{publication-date|einval}}} }}||{{#time:Y|{{{publication-date|}}} }}}}
                |{{#time:Y|{{{date|}}} }}
              }}
             |{{{publication-date|}}} &lt;!-- last resort --&gt;
           }}
        }}}
  |Date = {{#if:{{{date|}}}|{{{date}}}|{{{day|}}} {{{month|}}} {{{year|{{{publication-date|}}}}}}}}
  |Title={{{title|}}}
  |TransTitle={{{trans_title|}}}
  |URL={{#if:{{{archiveurl|}}}|{{{archiveurl}}}|{{{url|}}}}} 
  |Series={{{series|{{{version|}}}}}}
  |Periodical = {{{journal|{{{periodical|{{{magazine|{{{work|}}}}}}}}}}}}
  |Volume = {{{volume|}}}
  |Issue = {{{issue|{{{number|}}}}}}
  |At = {{
          #if: {{{journal|{{{periodical|{{{magazine|{{{work|}}}}}}}}}}}}
          |{{{pages|{{{page|{{{at|}}}}}}}}}
          |{{
             #if: {{{page|}}}
             |p. {{{page}}}
             |{{
                #if: {{{pages|}}}
                |pp. {{{pages}}}
                |{{{at|}}}
              }}
           }}
        }}
  |IncludedWorkTitle = {{{chapter|{{{contribution|}}}}}}
  |IncludedWorkURL = {{{chapter-url|{{{chapterurl|{{{contribution-url|}}}}}}}}}
  |Edition = {{{edition|}}}
  |Place = {{{place|{{{location|}}}}}}
  |PublicationPlace = {{{publication-place|{{{place|{{{location|}}}}}}}}}
  |Publisher = {{{publisher|}}}
  |PublicationDate = {{{publication-date|}}}
  |EditorSurname1 = {{{editor-last|{{{editor-surname|{{{editor1-last|{{{editor1-surname|{{{editor|{{{editors|}}}}}}}}}}}}}}}}}}
  |EditorSurname2 = {{{editor2-last|{{{editor2-surname|}}}}}}
  |EditorSurname3 = {{{editor3-last|{{{editor3-surname|}}}}}}
  |EditorSurname4 = {{{editor4-last|{{{editor4-surname|}}}}}}
  |EditorGiven1 = {{{editor-first|{{{editor-given|{{{editor1-first|{{{editor1-given|}}}}}}}}}}}}
  |EditorGiven2={{{editor2-first|{{{editor2-given|}}}}}}
  |EditorGiven3={{{editor3-first|{{{editor3-given|}}}}}}
  |EditorGiven4={{{editor4-first|{{{editor4-given|}}}}}}
  |Editorlink1={{{editor-link|{{{editor1-link|}}}}}}
  |Editorlink2={{{editor2-link|}}}
  |Editorlink3={{{editor3-link|}}}
  |Editorlink4={{{editor4-link|}}}
  |Other = {{{others|}}}
  |language = {{{language|{{{in|}}}}}}
  |format = {{{format|}}}
  |ID={{{id|{{{ID|}}}}}}
  |ISBN={{{isbn|{{{ISBN|}}}}}}
  |ISSN={{{issn|{{{ISSN|}}}}}}
  |OCLC={{{oclc|{{{OCLC|}}}}}}
  |PMID={{{pmid|{{{PMID|}}}}}}
  |PMC={{{pmc|{{{PMC|}}}}}}
  |Embargo={{{pmc-embargo-date|1010-10-10}}}
  |Bibcode={{{bibcode|}}}
  |DOI={{{doi|{{{DOI|}}}}}}
  |DoiBroken={{{doi_brokendate|}}}
  |AccessDate={{{access-date|{{{accessdate|}}}}}}
  |OriginalURL={{{url|}}}
  |ArchiveURL={{{archiveurl|}}}
  |ArchiveDate={{{archivedate|}}}
  |laysource = {{{laysource|}}}
  |laysummary = {{{laysummary|}}}
  |laydate = {{{laydate|}}}
  |quote = {{{quote|}}}
  |Ref={{{ref|}}}
  |Sep = {{#ifeq:{{{separator|{{{seperator}}} }}}|;|&amp;#059;|{{{separator|{{{seperator|.}}} }}} }}
  |PS = {{{postscript|.}}}
  |AuthorSep = {{#ifeq:{{{author-separator|}}}|;|&amp;#059;|{{{author-separator|&amp;#059;}}}}}&amp;#32;
  |NameSep = {{{author-name-separator|,}}}&amp;#32;
  |Trunc = {{#if:{{{display-authors|}}}|{{{display-authors}}}|8}}
  |amp = {{{use ampersand before last author|}}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>knv88jwm4u3bp3rbzzahe39tk8lt69m</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Clear</title>
    <ns>10</ns>
    <id>66016</id>
    <revision>
      <id>1869650</id>
      <parentid>1869626</parentid>
      <timestamp>2010-06-30T17:52:24Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>22 revisions from [[:w:Template:Clear]]: History merge.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="71" xml:space="preserve">&lt;div style="clear: both"&gt;&lt;/div&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>jaabf7wcm14wgw815ggkx670v69i77e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Column-count</title>
    <ns>10</ns>
    <id>246866</id>
    <revision>
      <id>2017643</id>
      <parentid>2017622</parentid>
      <timestamp>2011-01-14T20:10:31Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Column-count]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="231" xml:space="preserve">&lt;includeonly&gt;column-count: {{{1|2}}}; -moz-column-count: {{{1|2}}}; -webkit-column-count: {{{1|2}}};&lt;/includeonly&gt;&lt;noinclude&gt;

&lt;!-- ADD CATEGORIES AND INTERWIKIS TO THE /doc PAGE, NOT HERE, THANKS --&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>abhspqn5f8y8sn6onmex5yjaiuhq3p1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Evalx</title>
    <ns>10</ns>
    <id>377857</id>
    <revision>
      <id>3149922</id>
      <parentid>3140393</parentid>
      <timestamp>2016-11-18T23:55:55Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Evalx]]": high-impact page ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="116" xml:space="preserve">{{#invoke:{{#if:{{{test-eval|}}}|{{{test-eval}}}|Wikilisp}}|trep|{{{1|}}}}}&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>gi5tdyhnger0muaubi6cl480g1rg8rt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Existlist</title>
    <ns>10</ns>
    <id>122484</id>
    <revision>
      <id>1618516</id>
      <parentid>988019</parentid>
      <timestamp>2009-08-29T03:34:35Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>+category</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1663" xml:space="preserve">&lt;includeonly&gt;&lt;!--
--&gt;{{#ifeq:{{{1|}}}|{{{1|+}}}|{{#ifexist:{{#rel2abs:{{{1}}}}}|{{#rel2abs:{{{1}}}}}|&lt;!--
--&gt;{{#ifeq:{{{2|}}}|{{{2|+}}}|{{#ifexist:{{#rel2abs:{{{2}}}}}|{{#rel2abs:{{{2}}}}}|&lt;!--
--&gt;{{#ifeq:{{{3|}}}|{{{3|+}}}|{{#ifexist:{{#rel2abs:{{{3}}}}}|{{#rel2abs:{{{3}}}}}|&lt;!--
--&gt;{{#ifeq:{{{4|}}}|{{{4|+}}}|{{#ifexist:{{#rel2abs:{{{4}}}}}|{{#rel2abs:{{{4}}}}}|&lt;!--
--&gt;{{#ifeq:{{{5|}}}|{{{5|+}}}|{{#ifexist:{{#rel2abs:{{{5}}}}}|{{#rel2abs:{{{5}}}}}|&lt;!--
--&gt;{{#ifeq:{{{6|}}}|{{{6|+}}}|{{#ifexist:{{#rel2abs:{{{6}}}}}|{{#rel2abs:{{{6}}}}}|&lt;!--
--&gt;{{#ifeq:{{{7|}}}|{{{7|+}}}|{{#ifexist:{{#rel2abs:{{{7}}}}}|{{#rel2abs:{{{7}}}}}|&lt;!--
--&gt;{{#ifeq:{{{8|}}}|{{{8|+}}}|{{#ifexist:{{#rel2abs:{{{8}}}}}|{{#rel2abs:{{{8}}}}}|&lt;!--
--&gt;{{#ifeq:{{{9|}}}|{{{9|+}}}|{{#ifexist:{{#rel2abs:{{{9}}}}}|{{#rel2abs:{{{9}}}}}|&lt;!--
--&gt;{{#ifeq:{{{10|}}}|{{{10|+}}}|{{#ifexist:{{#rel2abs:{{{10}}}}}|{{#rel2abs:{{{10}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}&lt;!--
--&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{esoteric}}

;Example Usage: [[{{tlx|existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}]]
;Result: [[{{existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}]]

;Example Usage: [[{{tlx|existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}|click here]]
;Result: [[{{existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}|click here]]

;What it does: returns the name of the first page which exists up to 10 max.
[[Category:Utility templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>ky5n5d7c3w6km147ef9nw9iawcrdar3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Expand</title>
    <ns>10</ns>
    <id>45599</id>
    <revision>
      <id>2503525</id>
      <parentid>2503498</parentid>
      <timestamp>2013-03-19T17:10:21Z</timestamp>
      <contributor>
        <username>Darklama</username>
        <id>7662</id>
      </contributor>
      <comment>recat for broader scope</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="541" xml:space="preserve">{{ambox|type=notice|text='''A reader requests expansion of this {{{1|{{is book|book|page}}}}} to include more material.'''&lt;br/&gt;You can help by [{{fullurl:{{FULLPAGENAME}}|action=edit}} adding new material] (''[[Using Wikibooks|learn how]]'') or ask for assistance in the [[WB:PROJECTS|reading room]].
}}&lt;includeonly&gt;{{#ifeq:{{{example|no}}}|yes||[[Category:Requests for expansion|{{PAGENAME}}]]}}&lt;/includeonly&gt;&lt;noinclude&gt;

''Places works in [[:Category:Requests for expansion]]''

[[Category:Maintenance templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>0gevt863kam7dzv5bmyyu9doyg8cgd1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Fact</title>
    <ns>10</ns>
    <id>91251</id>
    <redirect title="Template:Citation needed" />
    <revision>
      <id>1783640</id>
      <parentid>1404303</parentid>
      <timestamp>2010-04-29T13:16:06Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>Redirect to [[Template:Citation needed]]- same content</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="37" xml:space="preserve">#REDIRECT[[Template:Citation needed]]</text>
      <sha1>6j6fv8rcs5iutkee2zqsgy6fe8t4p63</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Fix</title>
    <ns>10</ns>
    <id>258062</id>
    <revision>
      <id>2182442</id>
      <parentid>2182438</parentid>
      <timestamp>2011-10-14T21:26:47Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>cat on subpages too</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="581" xml:space="preserve">{{cat handler
 |main={{{cat|}}}
 |wikijunior={{{cat|}}}
 |cookbook={{{cat|}}}
}}{{#if:{{{text|}}}
 |&lt;sup class="{{{class|noprint Inline-Template}}}" style="white-space:nowrap;"&gt;&amp;#91;&lt;i&gt;{{#if:{{{pre-text|}}}
  |{{{pre-text}}}&amp;#32;
 }}[[{{{link|Wikibooks:Maintenance}}}|&lt;span title="{{{title|{{{link|Wikibooks:Maintenance}}}}}}{{#if:{{{date|}}}|&lt;nowiki/&gt; from {{{date}}}}}"&gt;{{{text|}}}&lt;/span&gt;]]{{#if:{{{post-text|}}}
  |&amp;#32;{{{post-text}}}
 }}&lt;/i&gt;&amp;#93;&lt;/sup&gt;|{{{special|}}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add cats and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>phrisfg66nbopsxpaexq1l8e7x34z15</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Hide in print</title>
    <ns>10</ns>
    <id>225341</id>
    <revision>
      <id>1778094</id>
      <parentid>1778093</parentid>
      <timestamp>2010-04-27T13:31:08Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Hide in print]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="109" xml:space="preserve">&lt;includeonly&gt;{{{1|}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
[[Category:Exclude in print| ]]
&lt;/noinclude&gt;</text>
      <sha1>tvnms9jz42yzpfjz17tdfa22mm11pav</sha1>
    </revision>
  </page>
  <page>
    <title>Template:If pagename</title>
    <ns>10</ns>
    <id>225125</id>
    <revision>
      <id>1774220</id>
      <parentid>1774219</parentid>
      <timestamp>2010-04-25T04:03:33Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:If pagename]]": Uses complex features of wiki syntax ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2134" xml:space="preserve">{{#if:x   &lt;!--Remove surrounding whitespace--&gt;
| &lt;!--Check for match with full pagename--&gt;
  {{{ {{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}   &lt;!--Has data, or is empty but defined--&gt;
  | &lt;!--Check for match with "User:Somepage/+"--&gt;
    {{{ {{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|1|1}}/+
    | &lt;!--Else, are we on a subpage or a basepage?--&gt;
      {{#if:{{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|0|2}}
      | &lt;!--We are on a subpage, check for match with "User:Somepage/*"--&gt;
        {{{ {{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|1|1}}/*
        | &lt;!--Check for match with "Somepage/*"--&gt;
          {{{ {{#titleparts:{{#if:{{{page|}}}| {{PAGENAME:{{{page|}}}}} | {{PAGENAME}} }}|1|1}}/*
          | &lt;!--Check for match with "/something"--&gt;
            {{{ /{{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|0|-1}}
            | &lt;!--Check for match with "/somethin*"--&gt;
              {{{ /{{lc: {{padleft:|8| {{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|0|-1}}# }} }}*
              | &lt;!--Check for match with "/someth*"--&gt;
                {{{ /{{lc: {{padleft:|6| {{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|0|-1}}# }} }}*
                | &lt;!--Check for match with "/some*"--&gt;
                  {{{ /{{lc: {{padleft:|4| {{#titleparts:{{#if:{{{page|}}}| {{{page|}}} | {{FULLPAGENAME}} }}|0|-1}}# }} }}*   &lt;!--Pad with # so "/a" doesn't match "/aaaa*"--&gt;
                  | {{{subpage| {{{other|}}} }}}   &lt;!--Respecting empty parameter on purpose--&gt;
                  }}}
                }}}
              }}}
            }}}
          }}}
        }}}
      | &lt;!--We are on a basepage, check for match with "Somepage"--&gt;
        {{{ {{#if:{{{page|}}}| {{PAGENAME:{{{page|}}}}} | {{PAGENAME}} }}
        | {{{basepage| {{{other|}}} }}}   &lt;!--Respecting empty parameter on purpose--&gt;
        }}}
      }}   &lt;!--End if, are we on a subpage or a basepage?--&gt;
    }}}
  }}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>0ht30o8dzwhfxaaiyt9ivhbyqrb2104</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ifsubst</title>
    <ns>10</ns>
    <id>258082</id>
    <revision>
      <id>2182404</id>
      <parentid>2182395</parentid>
      <timestamp>2011-10-14T21:00:38Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Ifsubst]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="157" xml:space="preserve">{{ {{{|safesubst:}}}#ifeq:{{ {{{|safesubst:}}}NAMESPACE}}|{{NAMESPACE}}
 |{{{no|{{{2|}}}}}}
 |{{{yes|{{{1|}}}}}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>99jni9k666z4fxvt1n0lyu62blgom38</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Is book</title>
    <ns>10</ns>
    <id>193965</id>
    <revision>
      <id>1618508</id>
      <parentid>1496623</parentid>
      <timestamp>2009-08-29T03:26:28Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>+category</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="238" xml:space="preserve">&lt;includeonly&gt;{{#ifeq:{{#titleparts:{{FULLPAGENAME}}}}|{{#titleparts:{{FULLPAGENAME}}|1}}|{{{book|{{{1|}}}}}}|{{{page|{{{2|}}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
Is this a book or a page?
[[Category:Utility templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>55ye9l44xuxo6jp80uqjxqst8yozdo2</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Mbox</title>
    <ns>10</ns>
    <id>133968</id>
    <revision>
      <id>1785845</id>
      <parentid>1785843</parentid>
      <timestamp>2010-05-03T12:48:44Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>default to blank if not given</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="675" xml:space="preserve">&lt;includeonly&gt;{{
  {{namespace detect 
  | demospace = {{{demospace|}}}
  | main = ambox
  | wikijunior = ambox
  | cookbook  = ambox
  | talk      = tmbox
  | file      = imbox
  | category  = cmbox
  | other     = ombox
  }}
| type       = {{{type|}}}
| image      = {{{image|}}}
| imageright = {{{imageright|}}}
| style      = {{{style|}}}
| textstyle  = {{{textstyle|}}}
| text       = {{{text|{{{msg|}}}}}}
| small      = {{{small|}}}
| smallimage = {{{smallimage|}}}
| smallimageright = {{{smallimageright|}}}
| smalltext  = {{{smalltext|}}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>pfjrr0v5iqhsxhse6qg9nokplti58t5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Mbox-side</title>
    <ns>10</ns>
    <id>134043</id>
    <revision>
      <id>2308615</id>
      <parentid>2308609</parentid>
      <timestamp>2012-04-18T14:30:41Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Mbox-side]]": High-impact page (‎[edit=sysop] (indefinite) ‎[move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1453" xml:space="preserve">&lt;table class="plainlinks noprint messagebox {{{type|notice}}}" style="width:250px; float:right; clear:right; margin:0px; margin-left:10px;"&gt;  
&lt;tr style="vertical-align:middle;"&gt;{{#ifeq:{{{image|yes}}}|none
 |&lt;!-- no image cell --&gt;
 |&lt;td style="padding:0.1em; text-align:center; vertical-align:middle; width:45px; border:none;"&gt;
{{#if:{{{image|}}}|[[Image:{{{image}}}|{{{size|40x40px}}}|link=]]|{{#switch:{{{type|notice}}}
 | warning  = [[Image:Nuvola apps important.svg|{{{size|40x40px}}}|link=]]
 | serious  = [[Image:Stop hand nuvola.svg|{{{size|40x40px}}}|link=]]
 | content  = [[Image:Book important2.svg|{{{size|45x45px}}}|link=]]
 | style    = [[Image:Applications-office.svg|{{{size|40x40px}}}|link=]]
 | merge    = [[Image:Merge-split-transwiki default.svg|{{{size|40x40px}}}|link=]]
 | move     = [[Image:Merge-split-transwiki default.svg|{{{size|40x40px}}}|link=]]
 | notice   = [[Image:Warning icon WikiBooks.svg|{{{size|40x40px}}}|link=]]
 | growth   = [[Image:Nuvola apps bookcase.svg|{{{size|40x40px}}}|link=]]
 | idea     = [[Image:Dialog-information on.svg|{{{size|40x40px}}}|link=]]
 | query    = [[Image:Emblem-question.svg|{{{size|40x40px}}}|link=]]
 | blank    = &lt;!-- empty image cell --&gt;}}}}&lt;/td&gt;}}
&lt;td style="{{{text style|color:black; text-align:left; vertical-align:middle; padding:0.5em; padding-left:0em; border:none;}}}"&gt;
{{{1|{{{msg|{{{text|Enter a message}}}}}}}}}
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>sqzshy81a0z1bewsjiyas59niao0fw1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Merge from</title>
    <ns>10</ns>
    <id>240376</id>
    <redirect title="Template:Mergefrom" />
    <revision>
      <id>1935720</id>
      <timestamp>2010-09-18T17:22:00Z</timestamp>
      <contributor>
        <username>Darklama</username>
        <id>7662</id>
      </contributor>
      <comment>useful redirect</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="32" xml:space="preserve">#redirect [[Template:Mergefrom]]</text>
      <sha1>sddczspyk0bb5n0mblwpsf7x7th52ez</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Merge to</title>
    <ns>10</ns>
    <id>240377</id>
    <redirect title="Template:Mergeto" />
    <revision>
      <id>1935722</id>
      <timestamp>2010-09-18T17:23:56Z</timestamp>
      <contributor>
        <username>Darklama</username>
        <id>7662</id>
      </contributor>
      <comment>useful redirect</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="30" xml:space="preserve">#redirect [[Template:Mergeto]]</text>
      <sha1>9hs3wxkxdnkf4zxtrwffug4n5wckmlq</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Mergefrom</title>
    <ns>10</ns>
    <id>40808</id>
    <revision>
      <id>2202272</id>
      <parentid>1998660</parentid>
      <timestamp>2011-10-28T04:43:36Z</timestamp>
      <contributor>
        <username>Thenub314</username>
        <id>38087</id>
      </contributor>
      <comment>expanding documentation.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1075" xml:space="preserve">{{ambox|type=move|image=[[File:Mergefrom.svg|50px|link=|alt=]]|text='''A Wikibookian suggests that ''[[:{{{1}}}]]'' be [[Help:Pages#Merging|merged]] into this book or chapter{{#if:{{{2|}}}|&amp;nbsp;because:'''&lt;center&gt;{{{2}}}&lt;/center&gt;|.'''}}&lt;br/&gt;&lt;small&gt;Discuss whether or not this merger should happen on the [[:{{{3|{{TALKPAGENAME}}}}}|discussion page]].&lt;/small&gt;}}
&lt;includeonly&gt;{{#ifeq:{{{example|no}}}|no|[[Category:Books to be merged|{{PAGENAME}}]]}}&lt;/includeonly&gt;&lt;noinclude&gt;
----
''This adds pages to [[:Category:Books to be merged]]''.[[Category:Merge templates]]

===Usage===
This template is used to suggest that another page it should be merged the page the template is added to.

{{tlx|mergefrom|page to be merged into this one}}

Optionally there are two additional arguments that let you specify a reason for merging and give a custom place for the discussion page to happen.
	
{{tlx|mergefrom|page to be merged into this one|reason for merge|discussion page}}

===See also===
{{tl|mergeto}}: used to mark the page intended to be the source of the merge.

&lt;/noinclude&gt;</text>
      <sha1>grre244q1g3o4qqhew4ar2l5j8me9kx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Mergeto</title>
    <ns>10</ns>
    <id>40807</id>
    <revision>
      <id>2202271</id>
      <parentid>2202263</parentid>
      <timestamp>2011-10-28T04:42:44Z</timestamp>
      <contributor>
        <username>Thenub314</username>
        <id>38087</id>
      </contributor>
      <comment>expanding documentation.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1094" xml:space="preserve">{{ambox|type=move|image=[[File:Merge-arrow.svg|50px|link=|alt=]]|text='''A Wikibookian suggests that this book or chapter be [[Help:Pages#Merging|merged]] into ''[[:{{{1}}}]]''{{#if:{{{2|}}}|&amp;nbsp;because:'''&lt;br/&gt;&lt;center&gt;{{{2}}}&lt;/center&gt;|.'''}}&lt;br/&gt;&lt;small&gt;Please discuss whether or not this merge should happen on the [[:{{{3|{{TALKPAGENAME:{{{1|{{TALKPAGENAME}}}}}}}}}}|discussion page]].&lt;/small&gt;}}
&lt;includeonly&gt;{{#ifeq:{{{example|no}}}|no|[[Category:Books to be merged|{{PAGENAME}}]]}}&lt;/includeonly&gt;&lt;noinclude&gt;
''This adds pages to [[:Category:Books to be merged]]''.[[Category:Merge templates]]

===Usage===
This template is used to suggest that the page the template is added to should be merged into another page.

{{tlx|mergeto|page to be merged into}}

Optionally there are two additional arguments that let you specify a reason for merging and give a custom place for the discussion page to happen.	
{{tlx|mergeto|page to be merged into|reason for merge|discussion page}}

===See also===
{{tl|mergefrom}}: used to mark the page intended to be the destination of the merge.

&lt;/noinclude&gt;</text>
      <sha1>s3h2hz3g1jz07ietlkusmwxdu3rweoq</sha1>
    </revision>
  </page>
  <page>
    <title>Template:NAIVEBOOKNAME</title>
    <ns>10</ns>
    <id>153997</id>
    <revision>
      <id>3364930</id>
      <parentid>1767387</parentid>
      <timestamp>2018-01-22T17:55:27Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>Pi zero moved page [[Template:FULLBOOKNAME]] to [[Template:NAIVEBOOKNAME]]: description</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="109" xml:space="preserve">&lt;includeonly&gt;{{#titleparts:{{{1|{{FULLPAGENAME}}}}}|1}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>p6elrbww9zt8w5vven8h68v7asswoj9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:NOTE</title>
    <ns>10</ns>
    <id>57094</id>
    <revision>
      <id>3563141</id>
      <parentid>3563135</parentid>
      <timestamp>2019-08-14T15:54:11Z</timestamp>
      <contributor>
        <username>QuiteUnusual</username>
        <id>134830</id>
      </contributor>
      <comment>Undid revision 3563135 by [[Special:Contributions/Spider 001757|Spider 001757]] ([[User talk:Spider 001757|discuss]]) - WB policy is to retain interwikis</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="835" xml:space="preserve">{| class="notice notice-note noprint" style="background: #f2fff2; border: solid 1px #bfffbf; padding: 0.5em; width: 95%; margin: auto; vertical-align: top; -moz-border-radius:10px;" 
 |
'''Note:'''&lt;br/&gt;
{{{1|{{{note}}}}}}
|}&lt;noinclude&gt;
Use: &lt;pre&gt;{{NOTE|note|Wikibookian}}&lt;/pre&gt;

All parameters are optional.
*note - the text displayed inside the NOTE box.
*Wikibookian - The name of the Wikibookian that wrote the NOTE. (Can be important to know who to contact in regard with a particular note)

This template adds a note intended for readers that should be valid independent of Wikibooks (for an alternatives see {{[[Template:Editor note|Editor note]]}}, {{[[Template:Technote|Technote]]}}, {{[[Template:XNote|XNote]]}} or {{[[Template:Sidenote|Sidenote]]}}).

[[Category:Note templates|{{PAGENAME}}]]
[[pl:Szablon:NOTE]]
&lt;/noinclude&gt;</text>
      <sha1>6ta3vgv4oid6mijnjq4x0ldor2p4xuy</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Namespace detect</title>
    <ns>10</ns>
    <id>225046</id>
    <revision>
      <id>2181525</id>
      <parentid>1773589</parentid>
      <timestamp>2011-10-14T20:19:39Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>transwiki</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1562" xml:space="preserve">{{#switch:
  {{lc:               &lt;!--Lower case the result--&gt;
    &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
    {{#if:{{{demospace|}}} 
    | {{{demospace}}}
    | {{#if:{{{page|}}} 
      | &lt;!--Detect the namespace in the "page" parameter--&gt;
        {{#ifeq:{{NAMESPACE:{{{page}}} }}|{{TALKSPACE:{{{page}}} }}
        | talk
        | {{SUBJECTSPACE:{{{page}}} }} 
        }}
      | &lt;!--No "demospace" or "page" parameters, so detect actual namespace--&gt;
        {{#ifeq:{{NAMESPACE}}|{{TALKSPACE}}
        | talk
        | {{SUBJECTSPACE}} 
        }}
      }}
    }}
  }}
&lt;!-- Only one of the lines below will be executed --&gt;
&lt;!-- Respecting empty parameters on purpose --&gt;
| main        &lt;!--"demospace=main" or {{SUBJECTSPACE}}={{ns:0}}=""--&gt;
|           = {{{main| {{{other|}}} }}}
| talk      = {{{talk| {{{other|}}} }}}
| user      = {{{user| {{{other|}}} }}}
| wikibooks = {{{wikibooks| {{{other|}}} }}}
| file
| image     = {{{file| {{{image| {{{other|}}} }}} }}}
| mediawiki = {{{mediawiki| {{{other|}}} }}}
| template  = {{{template| {{{other|}}} }}}
| help      = {{{help| {{{other|}}} }}}
| subject   = {{{subject| {{{other|}}} }}}
| category  = {{{category| {{{other|}}} }}}
| wikijunior = {{{wikijunior| {{{other|}}} }}}
| cookbook  = {{{cookbook| {{{other|}}} }}}
| transwiki = {{{transwiki| {{{other|}}} }}}
| other
| #default  = {{{other|}}}   &lt;!--"demospace=other" or a new namespace--&gt;

}}&lt;!--End switch--&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>sm3jo7sylwxikvmc9l7or66sq8rafu6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Only in print</title>
    <ns>10</ns>
    <id>225339</id>
    <revision>
      <id>1778065</id>
      <parentid>1778057</parentid>
      <timestamp>2010-04-27T13:27:10Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Only in print]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="79" xml:space="preserve">{{#if:{{hide in print|1}}||{{{1|}}}}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rm8emca34tsah296fr9jh9dzgyhnfxo</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Print version cover</title>
    <ns>10</ns>
    <id>110276</id>
    <revision>
      <id>3477419</id>
      <parentid>3419430</parentid>
      <timestamp>2018-10-15T20:11:47Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>[[Special:UncategorizedPages]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="967" xml:space="preserve">&lt;div style="text-align: center; margin: 4em auto;"&gt;
{{{2|}}}

{{#if:{{{authors|}}}|&lt;div style="margin-top: 3em;"&gt;{{{authors}}}&lt;/div&gt;}}
&lt;div style="font-size: 350%; font-weight: bold; margin-top: 1em"&gt;{{{1|{{BASEPAGENAME}} }}}&lt;/div&gt;&lt;/div&gt;

&lt;div style="text-align: center; padding: 5em 5em 0em; border-bottom: 1px solid black"&gt;
The current, editable version of this book is available in Wikibooks, the open-content textbooks collection, at &lt;br&gt;
&lt;span class="plainlinks"&gt;https:{{fullurl:{{BASEPAGENAMEE}}}}&lt;/span&gt;

&lt;div style="font-size: 95%; padding: 1em 5em 2em;"&gt;Permission is granted to copy, distribute, and/or modify this document under the terms of the [[Wikibooks:Creative Commons Attribution-ShareAlike 3.0 Unported License|Creative Commons Attribution-ShareAlike 3.0 License]].&lt;/div&gt;
&lt;/div&gt;&lt;includeonly&gt;
__TOC__
[[Category:Print Versions|{{{1|{{PAGENAME}}}}}]]
&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
[[Category:Print templates|Version cover]]
&lt;/noinclude&gt;</text>
      <sha1>mo8v6utvxo81l902p1wi9pzn5c0iqe1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Print version notice</title>
    <ns>10</ns>
    <id>27932</id>
    <revision>
      <id>3366073</id>
      <parentid>3364335</parentid>
      <timestamp>2018-01-24T16:58:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>BOOKNAME (new-style)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="402" xml:space="preserve">{{ambox|type=notice|image=[[File:Printer.svg|40x40px]]|text='''This is the [[Help:Print versions|print version]] of [[{{{1|{{BOOKNAME}}}}}]]'''&lt;br/&gt;You won't see this message or any elements not part of the book's content when you print or [{{fullurl:{{existlist|{{{2|{{{1|{{BOOKNAME}}}}}/Print version}}}|{{FULLPAGENAME}}}}|printable=yes}} preview] this page.}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>0t02h1isu1ka7z7xxb4wk9np5o5d7xn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Quote</title>
    <ns>10</ns>
    <id>89472</id>
    <revision>
      <id>1887728</id>
      <parentid>1887727</parentid>
      <timestamp>2010-07-13T21:19:20Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Quote]]": High-impact page ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="502" xml:space="preserve">&lt;blockquote class="templatequote"&gt;&lt;div&gt;{{{text|{{{1|&lt;noinclude&gt;{{lorem ipsum}}&lt;/noinclude&gt;}}}}}}
&lt;/div&gt;{{#if:{{{sign|{{{2|&lt;noinclude&gt;TRUE&lt;/noinclude&gt;}}}}}}|&lt;div class="templatequotecite"&gt;&amp;#8212;{{{sign|{{{2|&lt;noinclude&gt;Someone&lt;/noinclude&gt;}}}}}}{{#if:{{{source|{{{3|&lt;noinclude&gt;TRUE&lt;/noinclude&gt;}}}}}}|,&amp;nbsp;&lt;cite&gt;{{{source|{{{3|&lt;noinclude&gt;''Source''&lt;/noinclude&gt;}}}}}}&lt;/cite&gt;}}&lt;/div &gt;}}&lt;/blockquote&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add cats and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>tg6tbas6ju9m79uu4ztv8lexjl10jvi</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Refbegin</title>
    <ns>10</ns>
    <id>238049</id>
    <revision>
      <id>2017609</id>
      <parentid>1917890</parentid>
      <timestamp>2011-01-14T19:42:05Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>update</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="651" xml:space="preserve">&lt;includeonly&gt;&lt;div class="refbegin references &lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | references-column-width 
      | references-column-count references-column-count-{{{1}}} }}
    | {{#if: {{{colwidth|}}}
      | references-column-width }} }}" style="&lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | {{column-width|{{{1}}}}}
      | {{column-count|{{{1}}}}} }}
    | {{#if: {{{colwidth|}}}
      | {{column-width|{{{colwidth}}}}} }} }}"&gt;&lt;!--
 --&gt;{{#if: {{{indent|}}}
    | &lt;dl style="text-indent: -{{{indentsize|3.5}}}em;"&gt;}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>17aeb4ki4hiqghgtn2sw39azjyq3vo9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Refend</title>
    <ns>10</ns>
    <id>238051</id>
    <revision>
      <id>2017611</id>
      <parentid>1917894</parentid>
      <timestamp>2011-01-14T19:44:11Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>update</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="99" xml:space="preserve">&lt;includeonly&gt;&lt;/dl&gt;&lt;/div&gt;&lt;/includeonly&gt;&lt;noinclude&gt;{{template doc|Template:refbegin/doc}}&lt;/noinclude&gt;</text>
      <sha1>5q6q9n0eam4eymsypg5yndwibu6ogyw</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist</title>
    <ns>10</ns>
    <id>102914</id>
    <revision>
      <id>2017696</id>
      <parentid>2017608</parentid>
      <timestamp>2011-01-14T20:30:40Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <comment>fix class</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="591" xml:space="preserve">&lt;div class="reflist references &lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | references-column-width 
      | references-column-count references-column-count-{{{1}}} }}
    | {{#if: {{{colwidth|}}}
      | references-column-width }} }}" style="&lt;!--
 --&gt;{{#if: {{{1|}}}
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }}
      | {{column-width|{{{1}}}}}
      | {{column-count|{{{1}}}}} }}
    | {{#if: {{{colwidth|}}}
      | {{column-width|{{{colwidth}}}}} }} }}"&gt;
{{#tag:references|{{{refs|}}}|group={{{group|}}}}}&lt;/div&gt;&lt;noinclude&gt;
{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>2ym9hjf4imgqkgn1igzsgqk5gkfii5z</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sec link/relative url</title>
    <ns>10</ns>
    <id>224918</id>
    <revision>
      <id>2177845</id>
      <parentid>2177843</parentid>
      <timestamp>2011-10-08T12:44:55Z</timestamp>
      <contributor>
        <username>Darklama</username>
        <id>7662</id>
      </contributor>
      <comment>relative url</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1489" xml:space="preserve">//{{#switch: {{lc: {{{project|}}} }}
| wikipedia | w = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wikipedia
| wiktionary | wikt = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wiktionary
| wikinews | n = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wikinews
| wikibooks | b = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wikibooks
| wikiquote | q = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wikiquote
| wikiversity | v = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wikiversity
| wikisource | s = {{#if:{{{lang|}}}|{{{lang}}}|{{CONTENTLANG}}}}.wikisource
| oldwikisource = wikisource
| wikispecies | species = species.wikimedia
| wikimedia | foundation | wmf = wikimediafoundation
| commons = commons.wikimedia
| meta | metawikipedia | m = meta.wikimedia
| strategy = strategy.wikimedia
| incubator = incubator.wikimedia
| mw = www.mediawiki
| nost = nostalgia.wikimedia
| testwiki = test.wikipedia
| #default = 

&lt;!-- Other Wikibooks language fed, or no project fed.
     (If copying this template to a non-Wikibooks project,
     then update the below code line.) --&gt;
| #default = {{#if:{{{project|{{{lang|}}}}}}|{{{project|{{{lang}}}}}}|{{CONTENTLANG}}}}.wikibooks

}}.org/wiki/{{#if: {{{anchor|}}}
| {{PAGENAMEE:Template:{{{pagename|}}} }}#{{anchorencode:{{{anchor}}} }}
| {{PAGENAMEE:Template:{{{pagename|}}} }}{{#if: {{{query|}}}
  | ?{{{query|}}}
  }}
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>iqa4lhftir8q1l98mi3d1yc5gmxs5gl</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sec link/text</title>
    <ns>10</ns>
    <id>224916</id>
    <revision>
      <id>1769318</id>
      <parentid>1769317</parentid>
      <timestamp>2010-04-22T19:58:52Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Sec link/text]]": can/will be used in system messages ([edit=sysop] (indefinite) [move=sysop] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="522" xml:space="preserve">{{#if: {{{text|}}}
| {{{text}}}
| {{#if: {{{project|}}} 
  | {{{project}}}:{{#if: {{{lang|}}}
    | {{{lang}}}:
    }}{{{pagename|}}}
  | &lt;!--No project, so a local link--&gt;
    {{#if: {{{pagename|}}}
    | {{{pagename}}}
    | {{MediaWiki:Mainpage}}   &lt;!--Main page name at the local project--&gt;
    }}
  }}{{
  #if: {{{query|}}}
  | ?{{{query|}}}
  | {{#if: {{{anchor|}}}
    | &amp;#35;{{{anchor}}}
    }}
  }}
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>i09uy7kjf2sxoakgfjm7roehyq4op69</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sec link auto</title>
    <ns>10</ns>
    <id>224910</id>
    <revision>
      <id>2177854</id>
      <parentid>1769365</parentid>
      <timestamp>2011-10-08T13:00:54Z</timestamp>
      <contributor>
        <username>Darklama</username>
        <id>7662</id>
      </contributor>
      <comment>updated using new implementation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="668" xml:space="preserve">{{#switch: {{lc: {{{padlock|}}} }}
  | yes    &lt;!--Supress CSS icon, to not get double icon--&gt;
  | no = &lt;span class="plainlinks"&gt;
}}[{{sec link/relative url
  | project = {{{1|}}}
  | pagename = {{{2|}}}
  | lang = {{{lang|}}}
  | query = {{{query|}}}
  | anchor = {{{anchor|}}}
}} {{sec link/text
  | project = {{{1|}}}
  | pagename = {{{2|}}}
  | text = {{{3|}}}
  | lang = {{{lang|}}}
  | query = {{{query|}}}
  | anchor = {{{anchor|}}}
}}]{{#switch: {{lc: {{{padlock|}}} }}
  | no = &lt;/span&gt;
  | yes = &lt;/span&gt;[[File:Lock icon blue.gif|16x13px|link=]]
}}&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>k1a7lwtbp7vzny1xe81121hy8ymnmo6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sect-stub</title>
    <ns>10</ns>
    <id>49470</id>
    <redirect title="Template:Sectstub" />
    <revision>
      <id>285726</id>
      <timestamp>2005-11-17T22:52:04Z</timestamp>
      <contributor>
        <username>Derbeth</username>
        <id>6139</id>
      </contributor>
      <minor/>
      <comment>redirect</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="31" xml:space="preserve">#REDIRECT [[Template:sectstub]]</text>
      <sha1>qhsuv8e0ne4emnlwzwjt0iylsdens8n</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sectstub</title>
    <ns>10</ns>
    <id>21996</id>
    <revision>
      <id>2349794</id>
      <parentid>1862411</parentid>
      <timestamp>2012-05-20T09:32:47Z</timestamp>
      <contributor>
        <username>Liam987</username>
        <id>582918</id>
      </contributor>
      <comment>small parameter</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="365" xml:space="preserve">{{ambox|type=content|small={{{small|}}}|text='''This section is a stub.'''&lt;br/&gt;You can help Wikibooks by [{{fullurl:{{FULLPAGENAME}}|action=edit}} expanding it].}}&lt;includeonly&gt;{{#ifeq:{{{example|no}}}|no|[[Category:Section stubs]]}}&lt;/includeonly&gt;&lt;noinclude&gt;''This adds the page to [[:Category:Section stubs]].''
[[Category:Stub templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>4r0f8j2rnzv38jz5fur3rikmj71clge</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Side note</title>
    <ns>10</ns>
    <id>59662</id>
    <revision>
      <id>3447478</id>
      <parentid>3447460</parentid>
      <timestamp>2018-07-31T16:38:47Z</timestamp>
      <contributor>
        <username>Leaderboard</username>
        <id>1176064</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/171.253.134.220|171.253.134.220]] ([[User talk:171.253.134.220|talk]]) to last version by Adrignola</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="200" xml:space="preserve">&lt;div bgcolor="#f0f0ff" style="float:{{{side|left}}}; width:17ex; border: 1px solid #C6C9FF; padding: 1em; margin:1em;"&gt;''{{{1}}}''&lt;/div&gt;&lt;noinclude&gt;[[Category:Note templates|{{PAGENAME}}}]]&lt;/noinclude&gt;</text>
      <sha1>4gbeo8jjpxj16s242mvpol7dhkzqrmw</sha1>
    </revision>
  </page>
  <page>
    <title>Template:TODO</title>
    <ns>10</ns>
    <id>106920</id>
    <redirect title="Template:Todo" />
    <revision>
      <id>710694</id>
      <timestamp>2007-01-07T08:28:23Z</timestamp>
      <contributor>
        <username>Darklama</username>
        <id>7662</id>
      </contributor>
      <comment>[[Template:TODO]] moved to [[Template:Todo]]: so capitalization isn't required.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="27" xml:space="preserve">#REDIRECT [[Template:Todo]]</text>
      <sha1>fem4f2slp3gk2iijdzkjyy1q611qfis</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Todo</title>
    <ns>10</ns>
    <id>29044</id>
    <revision>
      <id>2458775</id>
      <parentid>2458428</parentid>
      <timestamp>2012-12-11T20:04:37Z</timestamp>
      <contributor>
        <username>Ftiercel</username>
        <id>239666</id>
      </contributor>
      <comment>Fix the model.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="511" xml:space="preserve">&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;{{clear}}
{| style="background: {{{background|#ffd}}}; border: 1px solid #aaaaaa; padding: 6pt; margin: 12pt 8%; width: 60%; margin: auto;" class="notice noprint notice-todo" 
 | style="width: 58px;" | [[Image:Clipboard.svg|45 px|left|alt=Clipboard|link=]]
 |
'''{{{header|{{{title|To do:}}}}}}'''&lt;br /&gt;{{{1&lt;includeonly&gt;|&lt;/includeonly&gt;}}}
|}
&lt;includeonly&gt;{{clear}}&lt;/includeonly&gt;&lt;noinclude&gt;
[[Category:Maintenance templates|{{PAGENAME}}]]
[[pl:Szablon:TODO]]&lt;/noinclude&gt;</text>
      <sha1>a3cduhaiixs20bco9vmdkmjke08v0mq</sha1>
    </revision>
  </page>
  <page>
    <title>Template:W</title>
    <ns>10</ns>
    <id>305334</id>
    <redirect title="Template:Wp" />
    <revision>
      <id>3243414</id>
      <parentid>2714723</parentid>
      <timestamp>2017-07-11T22:19:52Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>Perfect double</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="24" xml:space="preserve">#REDIRECT[[Template:Wp]]</text>
      <sha1>ffxbrebm5l81ms584q9ild5tujt5mw5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Warning</title>
    <ns>10</ns>
    <id>29337</id>
    <restrictions>edit=autoconfirmed:move=autoconfirmed</restrictions>
    <revision>
      <id>2679333</id>
      <parentid>2618686</parentid>
      <timestamp>2014-07-07T11:52:08Z</timestamp>
      <contributor>
        <username>Sudozero</username>
        <id>379158</id>
      </contributor>
      <minor/>
      <comment>added documenting sample text</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="453" xml:space="preserve">&lt;includeonly&gt;{{mbox|type=delete|image=[[File:Nuvola_apps_important_yellow.svg|40px|link=|alt=warning]]|text={{{1}}}}}{{{style|}}}&lt;/includeonly&gt;&lt;noinclude&gt;{{Warning|To include this info box on your page, insert the following text: &lt;code&gt;&lt;nowiki&gt;{{Warning|Text to display}}&lt;/nowiki&gt;&lt;/code&gt;}}
See [[Template:PrintWarning]] for how this template will be rendered in a [[Help:Collections|collection]].
[[Category:Infobox templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>t5deze548fp48djozt95dsns2y7q5cc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikipedia</title>
    <ns>10</ns>
    <id>140088</id>
    <revision>
      <id>3509735</id>
      <parentid>3233955</parentid>
      <timestamp>2019-01-14T16:29:02Z</timestamp>
      <contributor>
        <username>Thomas Linard</username>
        <id>1044626</id>
      </contributor>
      <comment>PNG --&gt; SVG</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="701" xml:space="preserve">{{mbox-side|type=notice|image=Wikipedia-logo-v2.svg|text= [[w:|Wikipedia]] has related information at {{sec link auto| wikipedia | {{{1| Special:Search/{{PAGENAME}} }}} | '''''{{{1|{{PAGENAME}}}}}''''' }}{{#if:{{{2|}}}|{{#if:{{{3|}}}|,|&amp;nbsp; and}}&amp;nbsp;{{sec link auto| wikipedia | Special:Search/{{{2}}} | '''''{{{2}}}''''' }}}}{{#if:{{{3|}}}|{{#if:{{{4|}}}|,|&amp;nbsp; and}}&amp;nbsp;{{sec link auto| wikipedia | Special:Search/{{{3}}} | '''''{{{3}}}''''' }}}}{{#if:{{{4|}}}|&amp;nbsp; and {{sec link auto| wikipedia | Special:Search/{{{4}}} | '''''{{{4}}}''''' }}}}
}}&lt;noinclude&gt;&lt;div style="width:250px; float:right; clear:right; margin:0px; margin-top:10px !important;"&gt;&lt;/div&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gx4f87di78abt1tg4nq1tg3wfmen0ig</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikipediapar</title>
    <ns>10</ns>
    <id>28587</id>
    <revision>
      <id>3509734</id>
      <parentid>1619358</parentid>
      <timestamp>2019-01-14T16:27:10Z</timestamp>
      <contributor>
        <username>Thomas Linard</username>
        <id>1044626</id>
      </contributor>
      <comment>PNG --&gt; SVG</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="278" xml:space="preserve">{{mbox-side|type=notice|image=Wikipedia-logo-v2.svg|msg=[[Wikipedia:{{{1}}}|Wikipedia {{{1}}}]] has more about this subject:
&lt;div style="margin-left: 10px;"&gt;'''''[[Wikipedia:{{{1}}}:{{{2}}}|{{{2}}}]]'''''&lt;/div&gt;}}&lt;noinclude&gt;
[[Category:Wikipedia link templates|Par]]
&lt;/noinclude&gt;</text>
      <sha1>fwwtn6o70fjwphxf259ds5d0mrk0kup</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wp</title>
    <ns>10</ns>
    <id>292206</id>
    <revision>
      <id>3243413</id>
      <parentid>2541319</parentid>
      <timestamp>2017-07-11T22:19:14Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>+&lt;includeonly&gt;{{#if:{{{lang|}}}|{{{lang|}}}:|}}&lt;/includeonly&gt;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="641" xml:space="preserve">[[wikipedia:&lt;includeonly&gt;{{#if:{{{lang|}}}|{{{lang|}}}:|}}&lt;/includeonly&gt;{{{1}}}|{{{2|{{{1}}}}}}]]&lt;noinclude&gt;
[[category:Trainz Templates|{{PAGENAME}}]]
;Usage
Use this template to make a pretty link to a en.wikipedia page named &lt;code&gt;&lt;nowiki&gt;{{{1}}}&lt;/nowiki&gt;&lt;/code&gt; (The frist default pass parameter. It can be given a second 'pretty text' alternative name such as for example:
* &lt;code&gt;&lt;nowiki&gt;{{wp|grapical user interface|GUI}}&lt;/nowiki&gt;&lt;/code&gt; forming the link  &lt;code&gt;&lt;nowiki&gt;[[wikipedia:grapical user interface|GUI]]&lt;/nowiki&gt;&lt;/code&gt;
[[Category:Link templates|{{PAGENAME}}]]
[[Category:self-documenting templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>1yj12u8obto1ik1lwptrpd52ve54qu1</sha1>
    </revision>
  </page>
  <page>
    <title>Module:TScope</title>
    <ns>828</ns>
    <id>378746</id>
    <revision>
      <id>3149555</id>
      <parentid>3149438</parentid>
      <timestamp>2016-11-18T20:02:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Module:TScope]]": high-impact page ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3756" xml:space="preserve">local export = {}

export.override = function( frame )
	local title = frame.args[1]
	local args = {}
	for v, k in pairs( frame:getParent().args ) do
		args[v] = k
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v ~= 1 then
				args[ v - 1 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.prepend = function( frame )
	local title = frame.args[1]
	local args = {}
	local displace = 0;
	for v, k in pairs( frame.args ) do
		if (type( v ) == "number") and (v ~= 1) then
			args[ v - 1 ] = k
			displace = math.max( displace, (v - 1) )
		end
	end
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) == "number" then
			args[ displace + v ] = k
		else
			args[v] = k
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) ~= "number" then
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.append = function( frame )
	local title = frame.args[1]
	local args = {}
	local displace = 0;
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) == "number" then
			displace = math.max( displace, v )
		end
		args[v] = k
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v ~= 1 then
				args[ displace + v - 1 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.drop = function( frame )
	local title = frame.args[1]
	local args = {}
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) ~= "number" then
			args[v] = k
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v ~= 1 then
				args[ v - 1 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.shiftLeft = function( frame )
	local title = frame.args[1]
	local args = {}
	local displace = tonumber( frame.args[2] )
	if displace == nil then displace = 0 end
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) == "number" then
			if v &gt;= displace then
				args[ v - displace ] = k
			end
		else
			args[v] = k
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v &gt; 2 then
				args[ v - 2 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.map = function( frame )
	local title = frame.args[1]
	local displace = frame.args[2]
	if displace == nil then
		displace = 0
	else
		displace = tonumber( displace )
	end
	local args = {}
	local data = {}
	local maxv = 0
	for v, k in pairs( frame:getParent().args ) do
		if (type( v ) ~= "number") then
			args[v] = k
		elseif v &lt;= displace then
			args[v + 1] = k
		else
			data[v] = k
			maxv = math.max( v, maxv )
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) ~= "number" then
			args[v] = k
		elseif v &gt; 2 then
			args[v - 1] = k
		end
	end
	local result = ""
	for v = 1, maxv do
		if data[v] ~= nil then
			args[1] = data[v]
			result = result .. frame:expandTemplate{ title = title, args = args }
		end
	end
	return result
end

export.static = function( frame )
	return frame:getParent():getTitle()
end

local function tabulate( args )
	local s = ''
	for k, v in pairs( args ) do
		s = s .. '|-\n| ' .. k .. '\n| &lt;code&gt;' .. v .. '&lt;/code&gt;\n'
	end
	if s ~= '' then
		s = '{| class="wikitable"\n|-\n! key\n! value\n' .. s .. '|}'
	end
	return s
end

export.echo = function( frame )
	local mp = tabulate( frame.args )
	local cp = tabulate( frame:getParent().args )
	if mp ~= '' then
		mp = 'module parameters:\n' .. mp .. '\n'
	end
	if cp ~= '' then
		cp = 'context parameters:\n' .. cp .. '\n'
	else
		cp = 'no context parameters.\n'
	end
	return mp .. cp
end

return export</text>
      <sha1>n3blx1g9jcetmcolf1n2fiuhyaql9nh</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wikilisp</title>
    <ns>828</ns>
    <id>377838</id>
    <revision>
      <id>3182515</id>
      <parentid>3182514</parentid>
      <timestamp>2017-02-14T18:13:35Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>1 revision imported from [[:n:Module:Wikilisp]]: update</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="47989" xml:space="preserve">local export = {}

local wikilispversion = "0.18 (February 14, 2017)"

--[[ some basic abstractions ]]

local function stype( x ) -- type of sexpr
	local t = type( x )
	if t == "table" then t = x.type end
	return t
end

local function seterr( x, ... )
	if type(x) ~= "table" then
		return seterr( {}, x, ... )
	else
		x.type = "error"
		x.msg = mw.ustring.format( ... )
		return x
	end
end

--[[ parse text to a sequence of sexprs ]]

local function tok3( ls, t )
	-- tokenize lua string t, with no string literals comments or parens;
	--   append to ls
	local p1,p2 = mw.ustring.find( t, "[^%s]+" )
	while p1 ~= nil do
		local t1 = mw.ustring.sub(t, p1, p2)
		local n1 = tonumber(t1)
		if n1 ~= nil then
			ls[1 + #ls] = n1
		elseif t1 == "true" then
			ls[1 + #ls] = true
		elseif t1 == "false" then
			ls[1 + #ls] = false
		else
			ls[1 + #ls] = {
				type = "symbol",
				name = t1
			}
		end
		t = mw.ustring.sub(t, (p2 + 1))
		p1,p2 = mw.ustring.find( t, "[^%s]+" )
	end
end

local function tok2( ls, t )
	-- tokenize lua string t, with no string literals or comments; append to ls
	local p1 = mw.ustring.find( t, "[()\\]" )
	while p1 ~= nil do
		tok3( ls, mw.ustring.sub(t, 1, (p1 - 1)) )
		ls[1 + #ls] = { type = mw.ustring.sub(t, p1, p1) }
		if ls[#ls].type == "\\" then
			ls[#ls].name = ls[#ls].type
			ls[#ls].type = "symbol"
		end
		t = mw.ustring.sub(t, (p1 + 1))
		p1 = mw.ustring.find( t, "[()\\]" )
	end
	tok3( ls, t )
end

local function tok1( ls, t )
	-- tokenize lua string t, thru first string literal or comment; append to ls
	-- if not finished, append untokenized remainder string and return true
	local p0 = mw.ustring.find( t, ';' )
	local p1 = mw.ustring.find( t, '"' )
	local p2 = mw.ustring.find( t, "'" )
	if (p0 ~= nil) and (((p1 == nil) or (p0 &lt; p1)) and
						((p2 == nil) or (p0 &lt; p2))) then
		tok2( ls, mw.ustring.sub( t, 1, (p0 - 1) ) )
		p1 = mw.ustring.find( t, '\n', (p0 + 1) )
		if p1 == nil then
			return false
		else
			ls[1 + #ls] = mw.ustring.sub( t, (p1 + 1) )
			return true
		end
	elseif (p1 ~= nil) and ((p2 == nil) or (p1 &lt; p2)) then
		p2 = p1 + 1
		while true do
			p2 = mw.ustring.find( t, '"', p2 )
			if p2 == nil then
				seterr(ls, 'mismatched string-literal delimiter (")')
				return false
			elseif (p2 &lt; mw.ustring.len( t )) and
				(mw.ustring.codepoint( t, (p2 + 1) ) == 34)
			then
				p2 = (p2 + 2)
			else
				tok2( ls, mw.ustring.sub( t, 1, (p1 - 1) ) )
				ls[1 + #ls] = mw.ustring.gsub(
					mw.ustring.sub( t, (p1 + 1), (p2 - 1) ),
					'""', '"')
				ls[1 + #ls] = mw.ustring.sub( t, (p2 + 1) )
				return true
			end
		end
	elseif p2 ~= nil then
		-- side benefit: precludes Lisp shorthand for "suppress eval"
		p1 = p2
		p2 = mw.ustring.find( t, "'", (p1 + 1) )
		if p2 == nil then
			seterr(ls, "mismatched string-literal delimiter (')")
			return false
		else
			tok2( ls, mw.ustring.sub( t, 1, (p1 - 1) ) )
			ls[1 + #ls] = mw.ustring.sub( t, (p1 + 1), (p2 - 1) )
			ls[1 + #ls] = mw.ustring.sub( t, (p2 + 1) )
			return true
		end
	else
		tok2( ls, t )
		return false
	end
end

local function parse_next( x1, p1, x2 )
	-- parse one sexpr from token list x1 position p1, append sexpr to p2
	-- return new value for p1
	if stype(x1[p1]) == ")" then
		seterr(x2, "unmatched right-paren")
		return 1 + #x1
	elseif stype(x1[p1]) ~= "(" then
		x2[1 + #x2] = x1[p1]
		return p1 + 1
	else
		p1 = p1 + 1
		local x3 = { type = "list" }
		x2[1 + #x2] = x3
		while p1 &lt;= #x1 do
			if stype(x1[p1]) == ")" then
				return p1 + 1
			end
			p1 = parse_next( x1, p1, x3 )
		end
		seterr(x2, "unmatched left-paren")
		return p1
	end
end

local function parse_sexpr( x1 )
	-- x1 is an error or a list of tokens
	if x1.type ~= "list" then
		return x1
	else
		local p1 = 1 --next item to read from x1
		local x2 = { type = "list" }
		while p1 &lt;= #x1 do
			p1 = parse_next( x1, p1, x2 )
		end
		return x2
	end
end

local function text_to_sexpr( t )
	local ls = { type = "list" }
	while tok1( ls, t ) do
		t = ls[#ls]
		ls[#ls] = nil
	end
	ls = parse_sexpr( ls )
	return ls
end

--[[ write/display a sexpr ]]

local function write_sexpr( x )
	if type(x) == "number" then
		return tostring( x )
	elseif type(x) == "string" then
		return mw.ustring.format('"%s"', mw.ustring.gsub( x, '"', '""' ))
	elseif type(x) == "boolean" then
		if x then return "true" else return "false" end
	elseif type(x) ~= "table" then
		return mw.ustring.format("&amp;lt;unrecognized internal type: %s&amp;gt;", type(x))
	elseif x.type == "symbol" then
		return x.name
	elseif x.type == "fn" then
		return mw.ustring.format("&amp;lt;%s&amp;gt;", write_sexpr( x.comb ))
	elseif x.type == "op" then
		if x.name ~= nil then
			return mw.ustring.format("[op: %s]", x.name)
		else
			return "[op]"
		end
	elseif x.type == "list" then
		local r = {}
		r[1] = "("
		for k = 1, #x do
			r[k+1] = write_sexpr( x[k] )
		end
		r[#r + 1] = ")"
		return table.concat(r, " ")
	elseif x.type == "error" then
		return mw.ustring.format("&amp;lt;error: %s&amp;gt;", x.msg)
	elseif x.type == "pattern" then
		return mw.ustring.format('&amp;lt;pattern: "%s"&amp;gt;', x.pat)
	elseif x.type ~= nil then
		return mw.ustring.format("&amp;lt;unrecognized type: %s&amp;gt;", x.type)
	else
		return "&amp;lt;missing type&amp;gt;"
	end
end

local function display_sexpr( x )
	if stype(x) == "string" then
		return x
	else
		return write_sexpr( x )
	end
end

--[[ evaluation tools ]]

local maxdepth = 4 -- maximum call-nesting depth

local combine

local function eval( x, env, depth )
	if type(x) ~= "table" then -- literal
		return x
	elseif x.type == "symbol" then
		local v = env[x.name]
		if v == nil then
			return seterr("undefined symbol: %s", x.name)
		else
			return v
		end
	elseif x.type ~= "list" then -- literal
		return x
	elseif #x == 0 then -- empty list
		return x
	else -- combination
		local c = eval( x[1], env, depth )
		if stype(c) == "error" then return c end
		local ls = { type = "list" }
		for k = 2, #x do
			ls[k - 1] = x[k]
		end
		return combine( c, ls, env, depth )
	end
end

combine = function( c, ls, env, depth )
	while stype(c) == "fn" do
		local ls2 = { type = "list" }
		for k = 1, #ls do
			ls2[k] = eval( ls[k], env, depth )
			if stype(ls2[k]) == "error" then return ls2[k] end
		end
		c = c.comb
		ls = ls2
	end
	if stype(c) ~= "op" then
		return seterr("called object is not a combiner: %s", write_sexpr(c))
	elseif (c.shallow ~= nil) then
		return c.op(ls, env, depth)
	elseif (depth == nil) or (depth &lt; 1) then
		if maxdepth &gt; 1 then
			return seterr(
				"exceeded maximum call-nesting depth (%i)",
				maxdepth)
		else
			return seterr("exceeded maximum call-nesting depth")
		end
	else
		return c.op(ls, env, (depth - 1))
	end
end

local function eval_seq( ls, env, depth )
	-- ls must be an error or a list
	if ls.type == "error" then return ls end
	if #ls == 0 then return ls end
	for k = 1, (#ls - 1) do
		local x = eval( ls[k], env, depth )
		if stype(x) == "error" then return x end
	end
	return eval( ls[#ls], env, depth )
end

local function eval_all( ls, env, depth, cutoff )
	-- ls must be an error or a list
	if ls.type == "error" then return ls end
	local ls2 = { type="list" }
	for k = 1, #ls do
		ls2[k] = eval( ls[k], env, depth )
		if stype(ls2[k]) == "error" then return ls2[k] end
		if (cutoff ~= nil) and cutoff(ls2[k]) then return ls2 end
	end
	return ls2
end

local function combine_all( ops, args, env, depth, cutoff )
	-- ops must be a list; args must be an error or a list
	if args.type == "error" then return args end
	local ls2 = { type="list" }
	for k = 1, #ops do
		ls2[k] = combine( ops[k], args, env, depth )
		if stype(ls2[k]) == "error" then return ls2[k] end
		if (cutoff ~= nil) and cutoff(ls2[k]) then return ls2 end
	end
	return ls2
end

--[[ generic combiner constructors ]]

local function make_op( f, nm, sh )
	return {
		type = "op",
		op = f,
		name = nm,
		shallow = sh
	}
end

local function checktype( t, o, k ) -- types list, operands list, index
	if #t == 0 then return "" end
	o = o[k] -- particular operand
	if k &gt; #t then k = #t end
	t = t[k] -- particular type
	-- t should now be a string or internal function
	if type(t) == "string" then
		if stype(o) == t then t = "" end -- clear if no error
	else
		t = t(o) -- assume internal function works correctly
	end
	-- t should now be type name if error, empty string if okay
	return t
end

local function type_err( cname, tname, x )
	-- combiner name, type name(s), operand
	-- type name may be a string or an array of strings
	local where = ""
	if cname ~= nil then where = " to [op: " .. cname .. "]" end
	if type(tname) == "table" then
		if #tname == 0 then tname = "[unknown]"
		else
			for k = 1, #tname do
				while tname[k] == "" do
					for j = (k + 1), #tname do tname[j - 1] = tname[j] end
					tname[#tname] = nil
				end
				if tname[k] ~= nil then
					for j = (k + 1), #tname do
						if tname[k] == tname[j] then tname[j] = "" end
					end
				end
			end
			if #tname == 1 then tname = tname[1]
			else
				tname[#tname] = "or " .. tname[#tname]
				if #tname == 2
				then tname = table.concat( tname, " " )
				else tname = table.concat( tname, ", " )
				end
			end
		end
	end
	local what = write_sexpr(x)
	if #what &gt; 64 then what = stype(x) end
	return seterr(
		"bad operand%s: expected %s, got %s", where, tname, what)
end

local function typed_op( ... )
	-- alternating type (string or function) and op (table or function)
	-- strong recommendation: first op should be a table
	local ls0 = { ... }
	local n0 = select( '#', ... )
	local opname, shallow
	if type(ls0[2]) == "table" then
		opname = ls0[2].name
		shallow = ls0[2].shallow
	end
	local f = function(ls, env, depth)
		if #ls == 0 then
			local op = ls0[2]
			if type(op) == "table" then op = op.op end
			return op( ls, env, depth )
		end
		local ek = 1 -- operand number of accumulated error type names
		local enames = {} -- list of failed types for ls[ek]
		for j = 1, n0, 2 do
			local types = ls0[j]
			local op = ls0[j + 1]
			if type(op) == "table" then op = op.op end
			local t = ""
			for k = 1, #ls do
				if #t == 0 then
					t = checktype( types, ls, k )
					if #t &gt; 0 then
						if k &gt; ek then
							ek = k
							enames = { t }
						elseif k == ek then
							enames[1 + #enames] = t
						end
					end
				end
			end
			if #t == 0 then return op( ls, env, depth ) end
		end
		return type_err( opname, enames, ls[ek] )
	end
	return make_op( f, opname, shallow )
end

local function nary_op( c, n, m )
	local f = function(ls, env, depth)
		if n &lt; 0 then
			if #ls &lt; -n then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"too few operands%s: expected at least %i, got %i",
					where, -n, #ls)
			end
		elseif m == nil then
			if #ls ~= n then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"wrong number of operands%s: expected %i, got %i",
					where, n, #ls)
			end
		else
			if #ls &lt; n then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"too few operands%s: expected at least %i, got %i",
					where, n, #ls)
			elseif #ls &gt; m then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"too many operands%s: expected at most %i, got %i",
					where, m, #ls)
			end
		end
		return c.op( ls, env, depth )
	end
	return make_op( f, c.name, c.shallow )
end

local function binary_pred( test, nm )
	return make_op(function (ls)
			for k = 2, #ls do
				if not test(ls[k - 1], ls[k]) then
					return false
				end
			end
			return true
		end, nm, true)
end

local function unary_pred( test, nm )
	return make_op(function (ls)
			for k = 1, #ls do
				if not test(ls[k]) then
					return false
				end
			end
			return true
		end, nm, true)
end

local function wrap( c )
	return {
		type = "fn",
		comb = c
	}
end

--[[ wiki parsing stuff
	entry:  (char-code  (first-pos  last-pos  left-index))
	        (descriptor  (first-pos  last-pos  left-index)  entry  entry  ...)
	item entries contain part entries, part entries contain item entries
	left-index is removed at end of parse
]]

local lsquare,rsquare, lcurly,rcurly, pipe = 91,93, 123,125, 124

local function wikileft(e) -- is entry a left-delimiter?
	return ((e[1] == lsquare) or (e[1] == lcurly)) and (e[2][1] ~= e[2][2])
end

local function wikilen(e) -- how long is this entry?
	return 1 + e[2][2] - e[2][1]
end

local function wikisub( m, d ) -- parse, descriptor
	local k2 = #m          -- index of right delimiter
	local k1 = m[k2][2][3] -- index of left delimiter
	local p = { type = "list", "part", { type = "list" } } -- first part
	p[2][1] = (m[k1][2][2] + 1) -- start of first part
	local e = { -- entry containing parts
		type = "list",
		d,
		{ type = "list",
		  (m[k1][2][2] - (m[k2][2][2] - m[k2][2][1])),
		  m[k2][2][2],
		  k1
		},
		p
	}
	for k = (k1 + 1), (k2 - 1) do
		if type(m[k][1]) ~= "number" then
			m[k][2][3] = nil
			p[1 + #p] = m[k]
		elseif m[k][1] == pipe then
			p[2][2] = (m[k][2][1] - 1) -- end of current part
			p = { type = "list", "part", { type = "list" } } -- next part
			p[2][1] = (m[k][2][2] + 1) -- start of this part
			e[1 + #e] = p -- add to list of parts
		end
		m[k] = nil
	end
	p[2][2] = (m[k2][2][1] - 1) -- end of last part
	m[k2] = nil
	m[k1][2][2] = (e[2][1] - 1)
	if (m[k1][2][1] &gt; m[k1][2][2]) then
		e[2][3] = m[k1][2][3]
		m[k1] = nil
	end
	m[1 + #m] = e
end

local function parse_wiki( ls )
	local s = ls[1]                             -- string to parse
	local m = { type = "list" }                 -- result of parse
	local k = mw.ustring.find( s, "[%[%]{}|]" ) -- position in string
	while k ~= nil do
		local c = mw.ustring.codepoint(s,k)
		if #m == 0 then
			if (c == lsquare) or (c == lcurly) then
				m[1] = {type="list", c, {type="list", k, k, 0}}
			end
		elseif (k == (m[#m][2][2] + 1)) and (c == m[#m][1]) and (c ~= pipe) then
			m[#m][2][2] = k
			if m[#m][2][3] &gt; 0 then
				local e2 = m[#m]
				local e1 = m[e2[2][3]]
				if (e2[1] == rcurly) and (e1[1] == lcurly) and
					(wikilen(e2) == 3) and (wikilen(e1) &gt; 2)
				then
					wikisub( m, "param" )
				elseif (e2[1] == rsquare) and (e1[1] == lsquare) and
					(wikilen(e2) == 2) and (wikilen(e1) &gt; 1)
				then
					wikisub( m, "link" )
				end
			end
		else
			if m[#m][2][3] &gt; 0 then
				local e2 = m[#m]
				local e1 = m[e2[2][3]]
				if (e2[1] == rcurly) and (e1[1] == lcurly) and
					(wikilen(e2) == 2) and (wikilen(e1) &gt; 1)
				then
					wikisub( m, "call" )
				end
			end
			m[1 + #m] = {type="list", c, {type="list", k, k}}
			if wikileft(m[#m - 1]) then
				m[#m][2][3] = (#m - 1)
			else
				m[#m][2][3] = m[#m - 1][2][3]
			end
		end
		k = mw.ustring.find( s, "[%[%]{}|]", (k + 1) )
	end
	if #m == 0 then return m end
	if m[#m][2][3] &gt; 0 then
		local e2 = m[#m]
		local e1 = m[e2[2][3]]
		if (e2[1] == rcurly) and (e1[1] == lcurly) and
			(wikilen(e2) == 2) and (wikilen(e1) &gt; 1)
		then
			wikisub( m, "call" )
		end
	end
	local m2 = { type = "list" }
	for j = 1, #m do
		if type(m[j][1]) ~= "number" then
			m[j][2][3] = nil
			m2[1 + #m2] = m[j]
		end
	end
	return m2
end

--[[ miscellaneous ]]

local function int_tc(x)
	if (type(x) ~= "number") or (x ~= math.floor(x)) then
		return "integer"
	else
		return ""
	end
end

local function posint_tc(x)
	if (type(x) ~= "number") or (x ~= math.floor(x)) or (x &lt; 1) then
		return "positive integer"
	else
		return ""
	end
end

local function logical_and( ls ) -- for and?
	for k = 1, #ls do
		if stype(ls[k]) ~= "boolean" then
			return seterr(
				"bad operand to [op: and?]: expected boolean, got %s",
				write_sexpr(ls[k]))
		end
	end
	for k = 1, #ls do if not ls[k] then return false end end
	return true
end

local function logical_or( ls ) -- for or?
	for k = 1, #ls do
		if stype(ls[k]) ~= "boolean" then
			return seterr(
				"bad operand to [op: or?]: expected boolean, got %s",
				write_sexpr(ls[k]))
		end
	end
	for k = 1, #ls do if ls[k] then return true end end
	return false
end

local function and_fn(ls, env, depth)
	ls = eval_all( ls, env, depth,
		function (x)
			return (stype(x) == "boolean") and not x
		end)
	if stype(ls) == "error" then return ls end
	if (#ls == 0) or (stype(ls[1]) == "boolean") then
		return logical_and(ls)
	end
	local ops = { type="list" }
	for k = 1, #ls do
		if stype(ls[k]) == "fn" then ops[k] = ls[k].comb
		elseif stype(ls[k]) == "op" then ops[k] = ls[k]
		elseif k == 1 then
			return seterr(
				"bad operand to [op: and?]: expected boolean or combiner, got %s",
				write_sexpr(ls[k]))
		else
			return seterr(
				"bad operand to [op: and?]: expected combiner, got %s",
				write_sexpr(ls[k]))
		end
	end
	return wrap(make_op(function (ls, env, depth)
			ls = combine_all(ops, ls, env, depth,
				function (x)
					return (stype(x) ~= "boolean") or not x
				end)
			if ls.type == "error" then return ls end
			return logical_and(ls)
		end, "and?", true))
end

local function or_fn(ls, env, depth)
	ls = eval_all(ls, env, depth,
		function (x)
			return (stype(x) == "boolean") and x
		end)
	if stype(ls) == "error" then return ls end
	if (#ls == 0) or (stype(ls[1]) == "boolean") then
		return logical_or(ls)
	end
	local ops = { type="list" }
	for k = 1, #ls do
		if stype(ls[k]) == "fn" then ops[k] = ls[k].comb
		elseif stype(ls[k]) == "op" then ops[k] = ls[k]
		elseif k == 1 then
			return seterr(
				"bad operand to [op: or?]: expected boolean or combiner, got %s",
				write_sexpr(ls[k]))
		else
			return seterr(
				"bad operand to [op: or?]: expected combiner, got %s",
				write_sexpr(ls[k]))
		end
	end
	return wrap(make_op(function (ls, env, depth)
			ls = combine_all(ops, ls, env, depth,
				function (x)
					return (stype(x) ~= "boolean") or x
				end)
			if ls.type == "error" then return ls end
			return logical_or(ls)
		end, "or?", true))
end

local function valid_parmlist( ls ) -- for \
	if stype(ls) ~= "list" then return false end
	for k = 1, #ls do
		if stype(ls[k]) ~= "symbol" then return false end
	end
	return true
end

local function match_parmlist( parms, ls ) -- for \
	local env = {}
	for k = 1, #parms do env[parms[k].name] = ls[k] end
	return env
end

local function lambda_fn(ls, senv)
	local parms = ls[1]
	if stype(parms) == "symbol" then
		parms = { type="list", parms }
	elseif not valid_parmlist(parms) then
		return seterr(
			"bad parameter-list operand to [op: \\]: %s",
			write_sexpr(parms))
	end
	local body = { type = "list" }
	for k = 2, #ls do body[k - 1] = ls[k] end
	return wrap(nary_op(make_op(function (ls, denv, depth)
		-- denv is ignored
		local env = match_parmlist( parms, ls )
		setmetatable(env, { __index = senv })
		return eval_seq(body, env, depth)
	end), #parms))
end

local relevantFrame = mw.getCurrentFrame()

local function getarg_fn(ls)
	local args = relevantFrame.args
	local t = nil
	if stype(ls[1]) == "number" then
		t = ls[1]
	else -- must be number or string
		t = ls[1]
	end
	t = args[t]
	if t == nil then return { type = "list" } end
	return t
end

local function getargexpr_fn(ls)
	local args = relevantFrame.args
	local t = nil
	if stype(ls[1]) == "number" then
		t = ls[1]
	else -- must be number or string
		t = ls[1]
	end
	t = args[t]
	if t == nil then return { type = "list" } end
	t = text_to_sexpr(t)
	if stype(t) == "error" then return { type = "list" } end
	if #t ~= 1 then return { type = "list" } end
	return t[1]
end

local function filter_fn(ls, env, depth)
	local preds = { type = "list" }
	for k = 2, #ls do preds[k - 1] = ls[k].comb end -- predicates
	local function hof(ls, n, f, app)
		-- copy first n elements of ls, apply f to later elements
		-- if app, instead skip first n, and return result,app
		if app == nil then app = false end
		local ls2 = { type = "list" }
		if #ls &lt;= n then
			if app then return ls2,app else return ls end
		end
		if not app then for k = 1, n do ls2[k] = ls[k] end end
		for k = (n + 1), #ls do
			local x,app2 = f(ls[k])
			if stype(x) == "error" then return x end
			if app2 == nil then app2 = false end
			if app2 then
				for j = 1, #x do ls2[1 + #ls2] = x[j] end
			else
				ls2[1 + #ls2] = x
			end
		end
		return ls2,app
	end
	local function filter_entry(entry)
		local b = combine_all(preds, {type="list", entry}, env, depth,
			function (x)
				return (stype(x) ~= "boolean") or not x
			end)
		if stype(b) == "error" then return b end
		b = logical_and(b)
		if stype(b) == "error" then return b end
		if b then
			if stype(entry) == "list" then
				return hof(entry, 2, function (part)
						return hof(part, 2, filter_entry)
					end)
			else
				return entry
			end
		else
			if stype(entry) == "list" then
				return hof(entry, 2, function (part)
						return hof(part, 2, filter_entry, true)
					end, true)
			else
				return { type = "list" }, true
			end
		end
	end
	return hof(ls[1], 0, filter_entry)
end

local function item_tc(x)
	if (stype(x) == "list") and (#x &gt; 1) and
		(stype(x[1]) == "string") and (x[1] ~= "part") and
		(stype(x[2]) == "list") and (#x[2] == 2) and
		(int_tc(x[2][1]) == "") and (int_tc(x[2][2]) == "")
	then
		return ""
	else
		return "item"
	end
end

local function part_tc(x)
	if (stype(x) == "list") and (#x &gt; 1) and (x[1] == "part") and
		(stype(x[2]) == "list") and (#x[2] == 2) and
		(int_tc(x[2][1]) == "") and (int_tc(x[2][2]) == "")
	then
		return ""
	else
		return "part"
	end
end

local function cd_tc(x)
	if (stype(x) == "list") and (#x &gt; 0) then
		if stype(x[1]) == "string" then x = x[2] end
		if (x ~= nil) and (stype(x) == "list") and (#x == 2) and
			(int_tc(x[1]) == "") and (int_tc(x[2]) == "")
		then
			return ""
		end
	end
	return "coordinates descriptor"
end

local function cd_ls_tc(x)
	local ok = true
	if stype(x) ~= "list" then ok = false
	else for k = 1, #x do if cd_tc(x[k]) ~= "" then ok = false end end
	end
	if ok then return ""
	else return "list of coordinates descriptors"
	end
end

local function getsubstr_ntv(s, k1, k2) -- k1, k2 ints if provided
	if k1 == nil then return s end
	if k1 &lt; 1 then k1 = 1 end
	if k2 ~= nil then
		if k2 &gt;= mw.ustring.len(s) then k2 = nil end
	end
	return mw.ustring.sub( s, k1, k2 )
end

local function cd_norm(x) -- assumes cd_tc
	if stype(x[1]) == "number" then return x else return x[2] end
end

local function getsubstr_int_fn(ls)
	local s = ls[1]
	return getsubstr_ntv(s, ls[2], ls[3])
end

local function getsubstr_cd_fn(ls)
	local s = ls[1]
	local c = cd_norm(ls[2])
	return getsubstr_ntv(s, c[1], c[2])
end

local function getsubstr_ls_fn(ls)
	local s = ls[1]
	local r = { type = "list" }
	for k = 1, #ls[2] do
		r[k] = cd_norm(ls[2][k])
	end
	for k = 1, #r do r[k] = getsubstr_ntv(s, r[k][1], r[k][2]) end
	return r
end

local function setsubstr_ls(s, lsc, lss)
	-- string, array of cds, array of strings
	local n = math.min(#lsc, #lss) -- just ignore extras of either
	if n == 0 then return s end
	local function berr(...)
		return seterr("bounds violation in [op: set-substring]: %s",
			mw.ustring.format( ... ))
	end
	if lsc[1][1] &lt; 1 then
		return berr("segment starts left of string start (%i)", lsc[1][1])
	end
	if lsc[n][2] &gt; mw.ustring.len(s) then
		return berr("segment ends right of string end (%i, %i)",
			lsc[n][2], mw.ustring.len(s))
	end
	local r = {}
	for k = 1, n do
		if lsc[k][1] &gt; (lsc[k][2] + 1) then
			return berr("segment starts right of its own end (%i, %i)",
				lsc[k][1], lsc[k][2])
		end
		r[2 * k] = lss[k]
	end
	r[1] = mw.ustring.sub(s, 1, (lsc[1][1] - 1))
	r[1 + (2 * n)] = mw.ustring.sub(s, (lsc[n][2] + 1))
	for k = 2, n do
		if lsc[k - 1][2] &gt;= lsc[k][1] then
			return berr("segment ends right of next segment start (%i, %i)",
				lsc[k - 1][2], lsc[k][1])
		end
		r[(2 * k) - 1] = mw.ustring.sub(s,
			(lsc[k - 1][2] + 1),
			(lsc[k][1] - 1))
	end
	return table.concat(r)
end

local function str_ls_tc(x)
	local ok = true
	if stype(x) ~= "list" then ok = false
	else for k = 1, #x do if stype(x[k]) ~= "string" then ok = false end end
	end
	if ok then return ""
	else return "list of strings"
	end
end

local function getsublist_fn(ls)
	local n1 = ls[2]
	local n2 = ls[3]
	local ls = ls[1]
	local x = { type = "list" }
	if n1 &lt; 1 then n1 = 1 end
	if n2 == nil then n2 = #ls elseif n2 &gt; #ls then ns = #ls end
	for k = n1, n2 do x[1 + #x] = ls[k] end
	return x
end

local function setsublist_fn(ls)
	local base = ls[1]
	local n1 = ls[2] - 1
	local n2 = ls[3] + 1
	local seg = ls[4]
	if n1 &lt; 0 then n1 = 0 end
	if n2 &lt;= n1 then n2 = n1 + 1 end
	local r = { type = "list" }
	for k = 1, n1 do r[k] = base[k] end
	for k = 1, #seg do r[1 + #r] = seg[k] end
	for k = n2, #base do r[1 + #r] = base[k] end
	return r
end

local function findprd_fn(ls, env, depth)
	local x = ls[1]
	local p = ls[2].comb
	local x2 = { type = "list" }
	for k = 1, #x do
		local q = combine( p, { type="list", x[k] }, env, depth )
		if stype(q) == "error" then return q end
		if stype(q) ~= "boolean" then
			return seterr(
				"bad predicate result type to [op: find]: got %s",
				stype(q))
		end
		if q then x2[1 + #x2] = k end
	end
	return x2
end

local function findstr_fn(ls)
	local s = ls[1]
	local p = ls[2]
	local x2 = { type = "list" }
	if #p == 0 then return x2 end
	local k = 1
	repeat
		local x3 = { mw.ustring.find( s, p, k, true ) }
		if #x3 == 0 then return x2 end
		x2[1 + #x2] = { type = "list", x3[1], x3[2] }
		k = 1 + x3[2]
	until false
end

local function findpat_fn(ls)
	local s = ls[1]
	local p = ls[2].pat
	local x2 = { type = "list" }
	local k = 1
	repeat
		local x3 = { mw.ustring.find( s, p, k ) }
		if #x3 == 0 then return x2 end
		x2[1 + #x2] = { type = "list", x3[1], x3[2] }
		k = 1 + x3[2]
	until false
end

local function any_tc(x) return "" end
local function none_tc(x) return "no operand here" end

local function member_fn(ls) -- 1 or 2 operands, second must be a list
	local t = write_sexpr(ls[1])
	if ls[2] ~= nil then
		ls = ls[2]
		for k = 1, #ls do
			if write_sexpr(ls[k]) == t then return true end
		end
		return false
	else
		return wrap(nary_op(typed_op({ "list" }, make_op(function(ls)
			ls = ls[1]
			for k = 1, #ls do
				if write_sexpr(ls[k]) == t then return true end
			end
			return false
		end, nil, true)), 1))
	end
end

local lang = mw.language.getContentLanguage()

local function let_tc(x)
	if (stype(x) == "list") and (#x == 2) and (stype(x[1]) == "symbol")
	then return ""
	else return "symbol-value binding"
	end
end

local function sorp_tc(x)
	if (stype(x) == "string") or (stype(x) == "pattern")
	then return ""
	else return "string or pattern"
	end
end

local function split_tc(x)
	if (stype(x) == "list") and (#x &gt;= 1) and (sorp_tc(x[1]) == "") and
		((#x == 1) or
		 ((#x == 2) and ((sorp_tc(x[2]) == "") or (split_tc(x[2]) == ""))) or
		 ((#x == 3) and (sorp_tc(x[2]) == "") and (split_tc(x[3]) == "")))
	then
		return ""
	else
		return "valid string-split descriptor"
	end
end

local function strnest_tc(x)
	if stype(x) == "string" then return ""
	elseif stype(x) == "list" then
		for k = 1, #x do
			local msg = strnest_tc(x[k])
			if msg ~= "" then return msg end
		end
		return ""
	end
	return "string or tree of strings"
end

local function splitsep_fn(s, p)
	local x
	if (stype(p) == "string")
	then x = mw.text.split( s, p, true )
	else x = mw.text.split( s, p.pat )
	end
	x.type = "list"
	return x
end

local function splitdelim_fn(s, lt, rt)
	local lp = (stype(lt) == "string")
	local rp = (stype(rt) == "string")
	if not lp then lt = lt.pat end
	if not rp then rt = rt.pat end
	local snarf -- find next unmatched right-delimiter
	snarf = function (k)
		repeat
			local xl = { mw.ustring.find( s, lt, k, lp ) }
			local xr = { mw.ustring.find( s, rt, k, rp ) }
			if #xr == 0 then return xr end
			if #xl == 0 then return xr end
			if xr[1] &lt;= xl[1] then return xr end
			xr = snarf(xl[2] + 1)
			if #xr == 0 then return xr end
			k = (xr[2] + 1)
		until false
	end
	local results = { type = "list" }
	local k = 1 -- leftmost character of interest
	repeat
		local xl = { mw.ustring.find( s, lt, k, lp ) }
		if #xl == 0 then return results end
		k = xl[2] + 1
		local xr = snarf(k)
		if #xr &gt; 0 then
			results[1 + #results] = mw.ustring.sub( s, k, (xr[1] - 1) )
			k = xr[2] + 1
		end
	until false
end

local function splitrec_fn(s, rc)
	local ls
	if (#rc &gt; 1) and (stype(rc[2]) ~= "list") then
		ls = splitdelim_fn(s, rc[1], rc[2])
	else
		ls = splitsep_fn(s, rc[1])
	end
	ls.type = "list"
	rc = rc[#rc]
	if (stype(rc) == "list") then
		for k = 1, #ls do
			ls[k] = splitrec_fn(ls[k], rc)
		end
	end
	return ls
end

local function splitnest_fn(s, rc)
	if stype(s) == "string" then return splitrec_fn(s, rc) end
	local result = { type="list" }
	for k = 1, #s do
		result[k] = splitnest_fn(s[k], rc)
		if stype(result[k]) == "error" then return result[k] end
	end
	return result
end

local function split_fn(ls)
	local rc = { type = "list" }
	for k = 2, #ls do rc[k - 1] = ls[k] end
	return splitnest_fn(ls[1], rc)
end

local function join_tc(x)
	if (stype(x) == "list") and (#x &gt;= 1) and (stype(x[1]) == "string") and
		((#x == 1) or
		 ((#x == 2) and ((stype(x[2]) == "string") or (join_tc(x[2]) == ""))) or
		 ((#x == 3) and (stype(x[2]) == "string") and (join_tc(x[3]) == "")))
	then
		return ""
	else
		return "valid string-join descriptor"
	end
end

local function neststr_tc(x)
	if stype(x) == "list" then
		for k = 1, #x do
			if stype(x[k]) ~= "string" then
				local msg = neststr_tc(x[k])
				if msg ~= "" then return msg end
			end
		end
		return ""
	end
	return "tree of strings"
end

local function joinsep_fn(t, s)
	if #t == 0 then return "" end
	if stype(t[1]) == "string" then
		for k = 2, #t do if stype(t[k]) ~= "string" then
			return seterr("bad target for [op: join]: uneven tree depth")
		end end
		return table.concat( t, s )
	end
	for k = 2, #t do if stype(t[k]) == "string" then
		return seterr("bad target for [op: join]: uneven tree depth")
	end end
	local result = { type = "list" }
	for k = 1, #t do
		result[k] = joinsep_fn(t[k], s)
		if stype(result[k]) == "error" then return result[k] end
	end
	return result
end

local function joindelim_fn(t, lf, rg)
	if #t == 0 then return "" end
	if stype(t[1]) == "string" then
		for k = 2, #t do if stype(t[k]) ~= "string" then
			return seterr("bad target for [op: join]: uneven tree depth")
		end end
		return lf .. table.concat( t, (rg .. lf) ) .. rg
	end
	for k = 2, #t do if stype(t[k]) == "string" then
		return seterr("bad target for [op: join]: uneven tree depth")
	end end
	local result = { type = "list" }
	for k = 1, #t do
		result[k] = joindelim_fn(t[k], lf, rg)
		if stype(result[k]) == "error" then return result[k] end
	end
	return result
end

local function joinnest_fn(t, rc)
	if stype(t) == "error" then return t end
	if stype(t) == "string" then
		return seterr("bad target for [op: join]: tree not deep enough")
	end
	if #rc == 1 then
		return joinsep_fn(t, rc[1])
	elseif #rc == 3 then
		return joinnest_fn(joindelim_fn(t, rc[1], rc[2]), rc[3])
	elseif stype(rc[2]) == "string" then
		return joindelim_fn(t, rc[1], rc[2])
	else
		return joinnest_fn(joinsep_fn(t, rc[1]), rc[2])
	end
end

local function join_fn(ls)
	local rc = { type = "list" }
	for k = 2, #ls do rc[k - 1] = ls[k] end
	return joinnest_fn(ls[1], rc)
end

local function xformer_fn(pred, basis, succ, n)
	return wrap(nary_op(typed_op({ "fn", "fn", any_tc },
		make_op(function (ls, denv, depth)
			local leaf = ls[1]
			local parent = ls[2]
			local data = ls[3]
			local function xform(basis, data)
				local recurse = false
				if stype(data) == "list" then
					if stype(pred) ~= "fn" then
						recurse = true
					else
						recurse = combine( pred.comb, { type="list", data }, env, depth )
						if stype(recurse) ~= "boolean" then
							if stype(recurse) == "error" then return recurse end
							return seterr(
								"bad predicate result type to [op transform]: %s",
								stype(recurse))
						end
					end
				end
				local comb
				if recurse then
					local b2
					if stype(succ) == "fn"
					then b2 = combine( succ.comb, { type="list", basis }, env, depth )
					else b2 = basis
					end
					local d2 = { type="list" }
					for k = 1, #data do
						if k &lt;= n then
							d2[k] = data[k]
						else
							d2[k] = xform(b2, data[k])
							if stype(d2[k]) == "error" then return d2[k] end
						end
					end
					data = d2
					comb = parent.comb
				else
					comb = leaf.comb
				end
				if stype(succ) == "fn"
				then data = { type="list", basis, data }
				else data = { type="list",        data }
				end
				return combine( comb, data, env, depth )
			end
			return xform(basis, data)
		end, "transform", true)), 3))
end

--[[ standard environment ]]

local ground_env = {
	list = wrap(make_op(function (ls) return ls end, "list", true)),
	["+"] = wrap(typed_op(
		{ "number" }, make_op(function (ls)
			local sum = 0
			for k = 1, #ls do sum = sum + ls[k] end
			return sum
		end, "add", true),
		{ "string" }, function (ls)
			local s = {}
			for k = 1, #ls do s[k] = ls[k] end
			return table.concat(s)
		end,
		{ "boolean" }, function (ls)
			local sum = true
			for k = 1, #ls do sum = sum and ls[k] end
			return sum
		end,
		{ "list" }, function (ls)
			local x = { type = "list" }
			for j = 1, #ls do
				for k = 1, #ls[j] do
					x[1 + #x] = ls[j][k]
				end
			end
			return x
		end)),
	["*"] = wrap(typed_op({ "number" }, make_op(function (ls)
			local product = 1
			for k = 1, #ls do product = product * ls[k] end
			return product
		end, "multiply", true))),
	["-"] = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			local result = ls[1]
			for k = 2, #ls do result = result - ls[k] end
			return result
		end, "subtract", true)), -2)),
	["/"] = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			local result = ls[1]
			for k = 2, #ls do result = result / ls[k] end
			return result
		end, "divide", true)), -2)),
	["^"] = wrap(nary_op(typed_op({ "number" }, make_op(function  (ls)
			return ls[1] ^ ls[2]
		end, "exponentiation", true)), 2)),
	["\\"] = nary_op(make_op(lambda_fn, "\\", true), -1),
	abs = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			return math.abs(ls[1])
		end, "abs", true)), 1)),
	anchorencode = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return mw.uri.anchorEncode( ls[1] )
		end, "anchorencode", true)), 1)),
	["and?"] = make_op(and_fn, "and?", true),
	apply = wrap(nary_op(typed_op(
		{ "fn", "list" }, make_op(function (ls, env, depth)
			return combine(ls[1].comb, ls[2], env, depth)
		end, "apply", "true")), 2)),
	["boolean?"] = wrap(unary_pred(function (x)
			return stype(x) == "boolean"
		end, "boolean?")),
	["call?"] = wrap(unary_pred(function (x)
			return (stype(x) == "list") and (#x &gt; 0) and
				(stype(x[1]) == "string") and (x[1] == "call")
		end, "call?")),
	canonicalurl = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			if #ls == 1
			then return tostring( mw.uri.canonicalUrl( ls[1] ) )
			else return tostring( mw.uri.canonicalUrl( ls[1], ls[2] ) )
			end
		end, "canonicalurl", true)), 1, 2)),
	ceil = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			return math.ceil(ls[1])
		end, "ceil", true)), 1)),
	define = nary_op(make_op(function (ls, env, depth)
			if stype(ls[1]) ~= "symbol" then
				return seterr(
					"bad definiend to [op: define]: expected symbol, got %s",
					write_sexpr(ls[1]))
			end
			local x = eval(ls[2], env, depth)
			if stype(x) == "error" then return x end
			env[ls[1].name] = x
			while stype(x) == "fn" do x = x.comb end
			if stype(x) == "op" and x.name == nil then x.name = ls[1].name end
			return { type = "list" }
		end, "define", true), 2),
	["equal?"] = wrap(make_op(function (ls)
			if #ls &gt;= 2 then
				local t = write_sexpr(ls[1])
				for k = 2, #ls do
					if write_sexpr(ls[k]) ~= t then
						return false
					end
				end
			end
			return true
		end, "equal?", true)),
	filter = wrap(nary_op(typed_op({ "list", "fn" }, make_op(filter_fn,
		"filter", true)), -1)),
	find = wrap(nary_op(typed_op(
		{ "list", "fn" }, make_op(findprd_fn, "find", true),
		{ "string", "string" }, findstr_fn,
		{ "string", "pattern" }, findpat_fn
		), 2)),
	floor = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			return math.floor(ls[1])
		end, "floor", true)), 1)),
	["fn?"] = wrap(unary_pred(function (x)
			return stype(x) == "fn"
		end, "fn?")),
	fullurl = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			if #ls == 1
			then return tostring( mw.uri.fullUrl( ls[1] ) )
			else return tostring( mw.uri.fullUrl( ls[1], ls[2] ) )
			end
		end, "fullurl", true)), 1, 2)),
	["ge?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &gt;= x2 end, "ge?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &gt;= x2 end))),
	['get-arg'] = wrap(nary_op(typed_op(
		{ "number" }, make_op(getarg_fn, "get-arg", true),
		{ "string" }, getarg_fn), 1)),
	['get-arg-expr'] = wrap(nary_op(typed_op(
		{ "number" }, make_op(getargexpr_fn, "get-arg-expr", true),
		{ "string" }, getargexpr_fn), 1)),
	['get-args'] = nary_op(make_op(function ()
			local ls = { type = "list" }
			for v, k in pairs( relevantFrame.args ) do
				ls[1 + #ls] = v
			end
			return ls
		end, "get-args"), 0),
	['get-coords'] = wrap(nary_op(typed_op({ cd_tc },make_op(function (ls)
			ls = ls[1]
			if stype(ls[1]) == "string" then ls = ls[2] end
			return { type="list", ls[1], ls[2] }
		end, "get-coords", true)), 1)),
	["get-items"] = wrap(nary_op(typed_op({ part_tc }, make_op(function (ls)
			ls = ls[1]
			local ls2 = { type="list" }
			for k = 3, #ls do ls2[k - 2] = ls[k] end
			return ls2
		end, "get-items", true)), 1)),
	["get-parts"] = wrap(nary_op(typed_op({ item_tc }, make_op(function (ls)
			ls = ls[1]
			local ls2 = { type="list" }
			for k = 3, #ls do ls2[k - 2] = ls[k] end
			return ls2
		end, "get-parts", true)), 1)),
	["get-sublist"] = wrap(nary_op(typed_op(
		{ "list", int_tc },
		make_op(getsublist_fn, "get-sublist", true)), 2, 3)),
	["get-substring"] = wrap(typed_op(
		{ "string", int_tc },
		nary_op(make_op(getsubstr_int_fn, "get-substring", true), 2, 3),
		{ "string", cd_tc },
		nary_op(make_op(getsubstr_cd_fn, "get-substring", true), 2),
		{ "string", cd_ls_tc },
		nary_op(make_op(getsubstr_ls_fn, "get-substring", true), 2))),
	["gt?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &gt; x2 end, "gt?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &gt; x2 end))),
	["if"] = nary_op(make_op(function (ls, env, depth)
			local test = eval(ls[1], env, depth)
			if stype(test) == "error" then return test end
			if stype(test) ~= "boolean" then
				return seterr(
					"bad test-result in [op: if]: %s",
					write_sexpr(test))
			elseif test then
				return eval(ls[2], env, depth)
			else
				return eval(ls[3], env, depth)
			end
		end, "if", true), 3),
	join = wrap(typed_op(
		{ neststr_tc, "string", join_tc },
		nary_op(make_op(join_fn, "join", true), 2, 3),
		{ neststr_tc, "string", "string", join_tc },
		nary_op(make_op(join_fn, "split", true), 3, 4))),
	lc = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:lc(ls[1])
		end, "lc", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:lc(ls[k]) end
			return r
		end), 1)),
	lcfirst = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:lcfirst(ls[1])
		end, "lcfirst", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:lcfirst(ls[k]) end
			return r
		end), 1)),
	["le?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &lt;= x2 end, "le?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &lt;= x2 end))),
	length = wrap(nary_op(typed_op(
		{ "list" }, make_op(function (ls)
			return #ls[1]
		end, "length", true),
		{ "string" }, function (ls)
			return mw.ustring.len( ls[1] )
		end), 1)),
	let = nary_op(typed_op({ let_tc, any_tc }, make_op(function (ls, env, depth)
			local p = ls[1][1]
			local v = eval( ls[1][2], env, depth )
			if stype(v) == "error" then return v end
			local body = { type = "list" }
			for k = 2, #ls do body[k - 1] = ls[k] end
			local e = {}
			e[p.name] = v
			setmetatable(e, { __index = env})
			return eval_seq(body, e, depth)
		end, "let", true)), -1),
	["link?"] = wrap(unary_pred(function (x)
			return (stype(x) == "list") and (#x &gt; 0) and
				(stype(x[1]) == "string") and (x[1] == "link")
		end, "link?")),
	["list?"] = wrap(unary_pred(function (x)
			return stype(x) == "list"
		end, "list?")),
	["lt?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &lt; x2 end, "lt?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &lt; x2 end))),
	map = wrap(nary_op(typed_op({ "fn", "list" }, make_op(
		function (ls, env, depth)
			local n = #ls[2]
			for k = 3, #ls do if #ls[k] &lt; n then n = #ls[k] end end
			local x = { type = "list" }
			for j = 1, n do
				local x2 = { type = "list" }
				for k = 2, #ls do x2[k - 1] = ls[k][j] end
				x[j] = combine( ls[1].comb, x2, env, depth )
				if stype(x[j]) == "error" then return x[j] end
			end
			return x
		end, "map", true)), -2)),
	["member?"] = wrap(nary_op(typed_op(
		{ any_tc, "list" }, make_op(member_fn, "member?", true)), 1, 2)),
	merge = wrap(nary_op(typed_op({ "fn", "list" }, make_op(
		function (ls, env, depth)
			local ks = {}
			for k = 2, #ls do ks[k] = 1 end
			local result = { type = "list" }
			while true do
				local j = nil
				for k = 2, #ls do
					if ks[k] &lt;= #ls[k] then
						if j == nil then j = k else
							local x = combine( ls[1].comb,
								{ ls[k][ks[k]], ls[j][ks[j]] }, env, depth )
							if stype(x) == "error" then return x end
							if x then j = k end
						end
					end
				end
				if j == nil then return result else
					result[#result + 1] = ls[j][ks[j]]
					ks[j] = ks[j] + 1
				end
			end
		end, "merge", true)), -2)),
	["not?"] = wrap(nary_op(typed_op({ "boolean" }, make_op(function (ls)
			return not ls[1]
		end, "not?", true)), 1)),
	nth = wrap(nary_op(typed_op({ "list", posint_tc }, make_op(function (ls)
			local x = ls[1]
			for k = 2, #ls do
				local n = ls[k]
				if #x &lt; n then
					return seterr(
						"bad index to [op: nth]: asked for %i, list length is %i",
						n, #x)
				end
				x = x[n]
				if (k &lt; #ls) and (stype(x) ~= "list") then
					return seterr("bad multi-index to [op: nth]: tree too shallow")
				end
			end
			return x
		end, "nth", true)), -2)),
	["number?"] = wrap(unary_pred(function (x)
			return stype(x) == "number"
		end, "number?")),
	["op?"] = wrap(unary_pred(function (x)
			return stype(x) == "op"
		end, "op?")),
	["or?"] = make_op(or_fn, "or?", true),
	["param?"] = wrap(unary_pred(function (x)
			return (stype(x) == "list") and (#x &gt; 0) and
				(stype(x[1]) == "string") and (x[1] == "param")
		end, "param?")),
	parse = wrap(nary_op(typed_op({ "string" }, make_op(parse_wiki,
		"parse", true)), 1)),
	pattern = wrap(nary_op(typed_op({ "string" }, make_op(function (ls)
			local p = ls[1]
			if #p == 0 then p = "[^%z%Z]" end -- disable null pattern
			return { type="pattern", pat=p }
		end, "pattern", true)), 1)),
	sequence = make_op(function (ls, env, depth)
			return eval_seq(ls, env, depth)
		end, "sequence", true),
	["set-sublist"] = wrap(nary_op(typed_op(
		{ "list", int_tc, int_tc, "list" },
		make_op(setsublist_fn, "set-sublist", true)), 4)),
	["set-substring"] = wrap(typed_op(
		{ "string", int_tc, int_tc, "string" },
		nary_op(make_op(function (ls)
				return setsubstr_ls(ls[1], { { ls[2], ls[3] } }, { ls[4] })
			end, "set-substring", true), 4),
		{ "string", cd_tc, "string" },
		nary_op(make_op(function (ls)
				return setsubstr_ls(ls[1], { cd_norm(ls[2]) }, { ls[3] })
			end, "set-substring", true), 3),
		{ "string", cd_ls_tc, str_ls_tc },
		nary_op(make_op(function (ls)
				local lsc = {}
				for k = 1, #ls[2] do lsc[k] = cd_norm(ls[2][k]) end
				return setsubstr_ls(ls[1], lsc, ls[3])
			end, "set-substring", true), 3)
		)),
	split = wrap(typed_op(
		{ strnest_tc, sorp_tc, split_tc },
		nary_op(make_op(split_fn, "split", true), 2, 3),
		{ strnest_tc, sorp_tc, sorp_tc, split_tc },
		nary_op(make_op(split_fn, "split", true), 3, 4))),
	["string?"] = wrap(unary_pred(function (x)
			return stype(x) == "string"
		end, "string?")),
	["symbol?"] = wrap(unary_pred(function (x)
			return stype(x) == "symbol"
		end, "symbol?")),
	["to-entity"] = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			local s = ls[1]
			if #s == 0 then return s end
			return "&amp;#" .. mw.ustring.codepoint(s, 1) .. ";"
		end, "to-entity", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do
				local s = ls[k]
				if #s == 0 then r[k] = s
				else r[k] = "&amp;#" .. mw.ustring.codepoint(s, 1) .. ";"
				end
			end
			return r
		end), 1)),
	["to-number"] = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			local n = tonumber(ls[1])
			if n == nil then return { type="list" } else return n end
		end, "to-number", true)), 1)),
	["to-string"] = wrap(nary_op(typed_op(
		{ "number" }, make_op(function (ls)
			return write_sexpr(ls[1])
		end, "to-string", true)),1)),
	transformer = wrap(typed_op(
		{ none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(    0,     0,     0,     0)
			end, "transformer", true),
		{ "fn", none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(ls[1],     0,     0,     0)
			end, "transformer", true),
		{ posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(    0,     0,     0, ls[1])
			end, "transformer", true),
		{ any_tc, "fn", none_tc },
		nary_op(make_op(function (ls, env, depth)
				return xformer_fn(    0, ls[1], ls[2],     0)
			end, "transformer", true), -2),
		{ "fn", posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(ls[1],     0,     0, ls[2])
			end, "transformer", true),
		{ "fn", any_tc, "fn", none_tc },
		nary_op(make_op(function (ls, env, depth)
				return xformer_fn(ls[1], ls[2], ls[3],     0)
			end, "transformer", true), -3),
		{ any_tc, "fn", posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(    0, ls[1], ls[2], ls[3])
			end, "transformer", true),
		{ "fn", any_tc, "fn", posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(ls[1], ls[2], ls[3], ls[4])
			end, "transformer", true)
		)),
	trim = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return mw.text.trim(ls[1])
		end, "trim", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = mw.text.trim(ls[k]) end
			return r
		end), 1)),
	uc = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:uc(ls[1])
		end, "uc", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:uc(ls[k]) end
			return r
		end), 1)),
	ucfirst = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:ucfirst(ls[1])
		end, "ucfirst", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:ucfirst(ls[k]) end
			return r
		end), 1)),
	urlencode = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			if #ls == 1 then ls[2] = 'QUERY' end
			return mw.uri.encode( ls[1], ls[2] )
		end, "urlencode", true)), 1, 2)),
	["wikilisp-version"] = wrap(nary_op(make_op(function (ls)
			return wikilispversion
		end, "wikilisp-version", true), 0)),
	write = wrap(nary_op(make_op(function (ls)
			return write_sexpr(ls[1])
		end, "write", true), 1))
}

local function make_standard_env()
	local standard_env = {}
	setmetatable(standard_env, { __index = ground_env})
	return standard_env
end

--[[ read-eval-print]]

function export.rep( frame )
	local t = frame.args[1]
	if t == nil then t = "" end
	return display_sexpr(
		eval_seq(
			text_to_sexpr(t),
			make_standard_env(),
			maxdepth))
end

function export.trep( frame )
	relevantFrame = frame:getParent()
	return export.rep(frame)
end

return export</text>
      <sha1>pj4vm8qb5jh0xuqywm926aeq903pofc</sha1>
    </revision>
  </page>
</mediawiki>
