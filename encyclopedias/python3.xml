<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikibooks</sitename>
    <dbname>enwikibooks</dbname>
    <base>https://en.wikibooks.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.35.0-wmf.16</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikibooks</namespace>
      <namespace key="5" case="first-letter">Wikibooks talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="102" case="first-letter">Cookbook</namespace>
      <namespace key="103" case="first-letter">Cookbook talk</namespace>
      <namespace key="108" case="first-letter">Transwiki</namespace>
      <namespace key="109" case="first-letter">Transwiki talk</namespace>
      <namespace key="110" case="first-letter">Wikijunior</namespace>
      <namespace key="111" case="first-letter">Wikijunior talk</namespace>
      <namespace key="112" case="first-letter">Subject</namespace>
      <namespace key="113" case="first-letter">Subject talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Print version</title>
    <ns>0</ns>
    <id>221838</id>
    <revision>
      <id>3412786</id>
      <parentid>3296330</parentid>
      <timestamp>2018-04-14T16:52:39Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1779" xml:space="preserve">{{Print version notice}}
{{Print version cover}}
&lt;noinclude&gt;
----


__NOEDITSECTION__
__TOC__
&lt;/noinclude&gt;

= 1. Front matter =
{{:Non-Programmer's Tutorial for Python 3/Front matter}}
----
= 2. Intro =
{{:Non-Programmer's Tutorial for Python 3/Intro}}
----
= 3. Hello, World =
{{:Non-Programmer's Tutorial for Python 3/Hello, World}}
----
=4. Who Goes There?=
{{:Non-Programmer's Tutorial for Python 3/Who Goes There?}}
----
=5. Count to 10=
{{:Non-Programmer's Tutorial for Python 3/Count to 10}}
----
=6. Decisions =
{{:Non-Programmer's Tutorial for Python 3/Decisions}}
----
= 7. Debugging =
{{:Non-Programmer's Tutorial for Python 3/Debugging}}
----
= 8. Defining Functions =
{{:Non-Programmer's Tutorial for Python 3/Defining Functions}}
----
= 9. Advanced Functions Example =
{{:Non-Programmer's Tutorial for Python 3/Advanced Functions Example}}
----
= 10. Lists =
{{:Non-Programmer's Tutorial for Python 3/Lists}}
----
= 11. For Loops =
{{:Non-Programmer's Tutorial for Python 3/For Loops}}
----
= 12. Boolean Expressions =
{{:Non-Programmer's Tutorial for Python 3/Boolean Expressions}}
----
= 13. Dictionaries =
{{:Non-Programmer's Tutorial for Python 3/Dictionaries}}
----
= 14. Using Modules =
{{:Non-Programmer's Tutorial for Python 3/Using Modules}}
----
= 15. More on Lists =
{{:Non-Programmer's Tutorial for Python 3/More on Lists}}
----
= 16. Revenge of the Strings =
{{:Non-Programmer's Tutorial for Python 3/Revenge of the Strings}}
----
= 17. File IO =
{{:Non-Programmer's Tutorial for Python 3/File IO}}
----
= 18. Dealing with the imperfect =
{{:Non-Programmer's Tutorial for Python 3/Dealing with the imperfect}}
----
= 19. The End =
{{:Non-Programmer's Tutorial for Python 3/The End}}
----
= 20. FAQ =
{{:Non-Programmer's Tutorial for Python 3/FAQ}}
----</text>
      <sha1>qle6qdb8e0zgrhhu5j5cqb4qh1rmsrx</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Advanced Functions Example</title>
    <ns>0</ns>
    <id>181460</id>
    <revision>
      <id>3544329</id>
      <parentid>3544328</parentid>
      <timestamp>2019-05-09T13:28:54Z</timestamp>
      <contributor>
        <ip>154.115.9.18</ip>
      </contributor>
      <comment>/* Examples */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7967" xml:space="preserve">Some people find this section useful, and some find it confusing.  If you find it confusing you can skip it.  Now we will do a walk through for the following program:
&lt;source lang="python"&gt;
def mult(a, b):
    if b == 0:
        return 0
    rest = mult(a, b - 1)
    value = a + rest
    return value
result = mult(3, 2)
print("3 * 2 = ", result)
&lt;/source&gt;
 
Basically this program creates a positive integer multiplication function
(that is far slower than the built in multiplication function) and then
demonstrates this function with a use of the function. This program demonstrates the use of recursion, that is a form of iteration (repetition) in which there is a function that repeatedly calls itself until an exit condition is satisfied. It uses repeated additions to give the same result as mutiplication: e.g. 3&amp;nbsp;+&amp;nbsp;3 (addition) gives the same result as 3&amp;nbsp;*&amp;nbsp;2 (multiplication).

; ''Question:'' What is the first thing the program does?
: ''Answer:'' The first thing done is the function mult is defined with the lines:
&lt;source lang="python"&gt;
def mult(a, b):
    if b == 0:
        return 0
    rest = mult(a, b - 1)
    value = a + rest
    return value
&lt;/source&gt;
: This creates a function that takes two parameters and returns a value when it is done.  Later this function can be run.
; What happens next?  
: The next line after the function, &lt;code&gt;result = mult(3, 2)&lt;/code&gt; is run.
; What does this line do?
: This line will assign the return value of &lt;code&gt;mult(3, 2)&lt;/code&gt; to the variable &lt;code&gt;result&lt;/code&gt;.
; And what does &lt;code&gt;mult(3, 2)&lt;/code&gt; return?
: We need to do a walkthrough of the &lt;code&gt;mult&lt;/code&gt; function to find out.
; What happens next?
: The variable &lt;code&gt;a&lt;/code&gt; gets the value 3 assigned to it and the variable &lt;code&gt;b&lt;/code&gt; gets the value 2 assigned to it.
; And then?
: The line &lt;code&gt;if b == 0:&lt;/code&gt; is run.  Since &lt;code&gt;b&lt;/code&gt; has the value 2 this is false so the line &lt;code&gt;return 0&lt;/code&gt; is skipped.
; And what then?
: The line &lt;code&gt;rest = mult(a, b - 1)&lt;/code&gt; is run.  This line sets the local variable &lt;code&gt;rest&lt;/code&gt; to the value of &lt;code&gt;mult(a, b - 1)&lt;/code&gt;.  The value of &lt;code&gt; a&lt;/code&gt; is 3 and the value of &lt;code&gt; b&lt;/code&gt; is 2 so the function call is &lt;code&gt;mult(3,1)&lt;/code&gt;
; So what is the value of &lt;code&gt;mult(3, 1)&lt;/code&gt; ?
: We will need to run the function &lt;code&gt; mult&lt;/code&gt; with the parameters 3 and 1.
; So what happens next?
: The local variables in the '' new'' run of the function are set so that &lt;code&gt;a&lt;/code&gt; has the value 3 and &lt;code&gt; b&lt;/code&gt; has the value 1. Since these are local values these do not affect the previous values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.
; And then?
: Since &lt;code&gt; b&lt;/code&gt; has the value 1 the if statement is false, so the next line becomes &lt;code&gt;rest = mult(a, b - 1)&lt;/code&gt;.
; What does this line do?
: This line will assign the value of &lt;code&gt;mult(3, 0)&lt;/code&gt; to rest.
; So what is that value?
: We will have to run the function one more time to find that out. This time &lt;code&gt;a&lt;/code&gt; has the value 3 and &lt;code&gt;b&lt;/code&gt; has the value 0.
; So what happens next?
: The first line in the function to run is &lt;code&gt;if b == 0:&lt;/code&gt;. &lt;code&gt; b&lt;/code&gt; has the value 0 so the next line to run is &lt;code&gt;return 0&lt;/code&gt; 
; And what does the line &lt;code&gt;return 0&lt;/code&gt; do?
: This line returns the value 0 out of the function. 
; So?
: So now we know that &lt;code&gt;mult(3, 0)&lt;/code&gt; has the value 0.  Now we know what the line &lt;code&gt;rest = mult(a, b - 1)&lt;/code&gt; did since we have run the function &lt;code&gt;mult&lt;/code&gt; with the parameters 3 and 0.  We have finished running &lt;code&gt;mult(3, 0)&lt;/code&gt; and are now back to running &lt;code&gt; mult(3, 1)&lt;/code&gt;. The variable &lt;code&gt;rest&lt;/code&gt; gets assigned the value 0.
; What line is run next?
: The line &lt;code&gt;value = a + rest&lt;/code&gt; is run next. In this run of the function, &lt;code&gt;a = 3&lt;/code&gt; and &lt;code&gt;rest = 0&lt;/code&gt; so now &lt;code&gt;value = 3&lt;/code&gt;.  
; What happens next?
: The line &lt;code&gt;return value&lt;/code&gt; is run.  This returns 3 from the function. This also exits from the run of the function &lt;code&gt; mult(3, 1)&lt;/code&gt;.  After &lt;code&gt;return&lt;/code&gt; is called, we go back to running &lt;code&gt; mult(3, 2)&lt;/code&gt;.
; Where were we in &lt;code&gt; mult(3, 2)&lt;/code&gt;?
: We had the variables &lt;code&gt;a = 3&lt;/code&gt; and &lt;code&gt;b = 2&lt;/code&gt; and were examining the line &lt;code&gt;rest = mult(a, b - 1)&lt;/code&gt;.
; So what happens now?
: The variable &lt;code&gt;rest&lt;/code&gt; get 3 assigned to it.  The next line &lt;code&gt;value = a + rest&lt;/code&gt; sets &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;3 + 3&lt;/code&gt; or 6.  
; So now what happens?
: The next line runs, this returns 6 from the function.  We are now back to running the line &lt;code&gt;result = mult(3, 2)&lt;/code&gt; which can now assign the value 6 to the variable &lt;code&gt;result&lt;/code&gt;.
; What happens next?  
: The next line after the function, &lt;code&gt;print("3 * 2 = ", result)&lt;/code&gt; is run.
; And what does this do?
: It prints &lt;code&gt;3 * 2 = &lt;/code&gt; and the value of &lt;code&gt;result&lt;/code&gt; which is 6. The complete line printed is &lt;code&gt;3 * 2 = 6&lt;/code&gt;.
; What is happening overall?  
: Basically we used two facts to calculate the multiple of the two numbers.  The first is that any number times 0 is 0 (&lt;code&gt;x * 0 = 0&lt;/code&gt;).  The second is that a number times another number is equal to the first number plus the first number times one less than the second number (&lt;code&gt;x * y = x + x * (y - 1)&lt;/code&gt;).  So what happens is &lt;code&gt;3 * 2&lt;/code&gt; is first converted into &lt;code&gt; 3 + 3 * 1&lt;/code&gt;.  Then &lt;code&gt;3 * 1&lt;/code&gt; is converted into &lt;code&gt;3 + 3 * 0&lt;/code&gt;.  Then we know that any number times 0 is 0 so &lt;code&gt;3 * 0&lt;/code&gt; is 0.  Then we can calculate that &lt;code&gt;3 + 3 * 0&lt;/code&gt; is &lt;code&gt;3 + 0&lt;/code&gt; which is &lt;code&gt;3&lt;/code&gt;.  Now we know what &lt;code&gt;3 * 1&lt;/code&gt; is so we can calculate that &lt;code&gt;3 + 3 * 1&lt;/code&gt; is &lt;code&gt;3 + 3&lt;/code&gt; which is &lt;code&gt;6&lt;/code&gt;.

This is how the whole thing works:

 mult(3, 2)
 3 + mult(3, 1)
 3 + 3 + mult(3, 0)
 3 + 3 + 0
 3 + 3
 6

==== Recursion ====
Programming constructs solving a problem by solving a smaller version of the same problem are called ''recursive''. In the examples in this chapter, recursion is realized by defining a function calling itself. This facilitates implementing solutions to programming tasks as it may be sufficient to consider the next step of a problem instead of the whole problem at once. It is also useful as it allows to express some mathematical concepts with straightforward, easy to read code.

Any problem that can be solved with recursion could be re-implemented with loops. Using the latter usually results in better performance. However equivalent implementations using loops are usually harder to get done correctly.

Probably the most intuitive definition of ''recursion'' is:
; Recursion
: If you still don't get it, see ''recursion''.

Try walking through the factorial example if the multiplication example did not make sense.

=== Examples ===
'''factorial.py'''
&lt;source lang="python"&gt;
#defines a function that calculates the factorial

def factorial(n):
    if n == 0:
        return 1
    if n&lt;0:
        return "Error, negative numbers do not have factorial values!!"
    return n * factorial(n - 1)

print("2! =", factorial(2))
print("3! =", factorial(3))
print("4! =", factorial(4))
print("5! =", factorial(5))
print("-3! =", factorial(-3))
&lt;/source&gt;

Output:
 
 2! = 2
 3! = 6
 4! = 24
 5! = 120
 -3! = Error, negative values do not have factorial values!!

'''countdown.py'''
&lt;source lang="python"&gt;
def count_down(n):
    print(n)
    if n &gt; 0:
        return count_down(n-1)

count_down(5)
&lt;/source&gt;

Output:
 5
 4
 3
 2
 1
 0

&lt;!--Now try replacing the "if" with "while" (you are still typing these out, right?).  Now you've managed to turn your computer into a calculator which can't correctly count down from four.  In essence, "while" acts as combined "if" and "repeat."  Throwing in two recursions makes for some interesting counting.--&gt;

{{navigation |previous=Defining Functions |next=Lists}}
{{BookCat}}</text>
      <sha1>7nlbc4mryao8knlrg6lhgrd368yjqkc</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Boolean Expressions</title>
    <ns>0</ns>
    <id>182367</id>
    <revision>
      <id>3181024</id>
      <parentid>3181023</parentid>
      <timestamp>2017-02-09T13:17:38Z</timestamp>
      <contributor>
        <username>Juliancolton</username>
        <id>91322</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/212.250.19.109|212.250.19.109]] ([[User talk:212.250.19.109|talk]]) to last version by QuiteUnusual</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13447" xml:space="preserve">Here is a little example of boolean expressions (you don't have to type it in):
&lt;source lang="python"&gt;
a = 6
b = 7
c = 42
print(1, a == 6)
print(2, a == 7)
print(3, a == 6 and b == 7)
print(4, a == 7 and b == 7)
print(5, not a == 7 and b == 7)
print(6, a == 7 or b == 7)
print(7, a == 7 or b == 6)
print(8, not (a == 7 and b == 6))
print(9, not a == 7 and b == 6)
&lt;/source&gt;

With the output being:

 1 True
 2 False
 3 True
 4 False
 5 True
 6 True
 7 False
 8 True
 9 False

What is going on?  The program consists of a bunch of funny looking &lt;code&gt;print&lt;/code&gt; statements.  Each &lt;code&gt;print&lt;/code&gt; statement prints a number and an expression.  The number is to help keep track of which statement I am dealing with.  Notice how each expression ends up being either &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;.  In Python false can also be written as 0 and true as 1.  
&lt;!-- For example: --&gt;
&lt;!-- &lt;source lang="python"&gt; --&gt;
&lt;!-- &gt;&gt;&gt; if 1: --&gt;
&lt;!-- ...     print "true" --&gt;
&lt;!-- ... else: --&gt;
&lt;!-- ...     print "false" --&gt;
&lt;!-- ...  --&gt;
&lt;!-- true --&gt;
&lt;!-- &gt;&gt;&gt; if 0: --&gt;
&lt;!-- ...     print "true" --&gt;
&lt;!-- ... else: --&gt;
&lt;!-- ...     print "false" --&gt;
&lt;!-- ...  --&gt;
&lt;!-- false --&gt;
&lt;!-- &lt;/source&gt; --&gt;

The lines:

&lt;source lang="python"&gt;
print(1, a == 6)
print(2, a == 7)
&lt;/source&gt;

print out a &lt;code&gt;True&lt;/code&gt; and a &lt;code&gt;False&lt;/code&gt; respectively just as expected since the first is true and the second is false.  The third print, &lt;code&gt;print(3, a == 6 and b == 7)&lt;/code&gt;, is a little different.  The operator &lt;code&gt;and&lt;/code&gt; means if both the statement before and the statement after are true then the whole expression is true otherwise the whole expression is false.  The next line, &lt;code&gt;print(4, a == 7 and b == 7)&lt;/code&gt;, shows how if part of an &lt;code&gt;and&lt;/code&gt; expression is false, the whole thing is false.  The behavior of &lt;code&gt;and&lt;/code&gt; can be summarized as follows:

{| class="wikitable"
!expression 
!result 
|-  
|true &lt;code&gt;and&lt;/code&gt; true 
|true 
|-
|true &lt;code&gt;and&lt;/code&gt; false 
|false 
|-
|false &lt;code&gt;and&lt;/code&gt; true 
|false
|-
|false &lt;code&gt;and&lt;/code&gt; false 
|false
|}

Notice that if the first expression is false Python does not check the second expression since it knows the whole expression is false.  Try running &lt;code&gt;False and print("Hi")&lt;/code&gt; and compare this to running &lt;code&gt;True and print("Hi")&lt;/code&gt;  The technical term for this is [[w:Short-circuit evaluation|short-circuit evaluation]]  

The next line, &lt;code&gt;print(5, not a == 7 and b == 7)&lt;/code&gt;, uses the &lt;code&gt;not&lt;/code&gt; operator.  &lt;code&gt;not&lt;/code&gt; just gives the opposite of the expression. (The expression could be rewritten as &lt;code&gt; print(5, a != 7 and b == 7)&lt;/code&gt;).  Here is the table:

{| class="wikitable"
!expression 
!result
|-
|&lt;code&gt;not&lt;/code&gt; true 
|false 
|-
|&lt;code&gt;not&lt;/code&gt; false 
|true
|}

The two following lines, &lt;code&gt;print(6, a == 7 or b == 7)&lt;/code&gt; and &lt;code&gt;print(7, a == 7 or b == 6)&lt;/code&gt;, use the &lt;code&gt;or&lt;/code&gt; operator.  The &lt;code&gt;or&lt;/code&gt; operator returns true if the first expression is true, or if the second expression is true or both are true.  If neither are true it returns false.  Here's the table:

{| class="wikitable"
!expression 
!result
|-  
|true &lt;code&gt;or&lt;/code&gt; true 
| true
|-
|true &lt;code&gt;or&lt;/code&gt; false 
|true
|-
|false &lt;code&gt;or&lt;/code&gt; true 
| true  
|-
|false &lt;code&gt;or&lt;/code&gt; false 
| false 
|}

Notice that if the first expression is true Python doesn't check the second expression since it knows the whole expression is true.  This works since &lt;code&gt;or&lt;/code&gt; is true if at least one half of the expression is true.  The first part is true so the second part could be either false or true, but the whole expression is still true.

The next two lines, &lt;code&gt;print(8, not (a == 7 and b == 6))&lt;/code&gt; and &lt;code&gt;print(9, not a == 7 and b == 6)&lt;/code&gt;, show that parentheses can be used to group expressions and force one part to be evaluated first.  Notice that the parentheses changed the expression from false to true. This occurred since the parentheses forced the &lt;code&gt;not&lt;/code&gt; to apply to the whole expression instead of just the &lt;code&gt;a == 7&lt;/code&gt; portion.

Here is an example of using a boolean expression:
&lt;source lang="python"&gt;
list = ["Life", "The Universe", "Everything", "Jack", "Jill", "Life", "Jill"]

# make a copy of the list. See the More on Lists chapter to explain what [:] means.
copy = list[:]
# sort the copy
copy.sort()
prev = copy[0]
del copy[0]

count = 0

# go through the list searching for a match
while count &lt; len(copy) and copy[count] != prev:
    prev = copy[count]
    count = count + 1

# If a match was not found then count can't be &lt; len
# since the while loop continues while count is &lt; len
# and no match is found

if count &lt; len(copy):
    print("First Match:", prev)
&lt;/source&gt;

And here is the output:

 First Match: Jill

This program works by continuing to check for match &lt;code&gt;while count &lt; len(copy) and copy[count] is not equal to prev&lt;/code&gt;.  When either &lt;code&gt;count&lt;/code&gt; is greater than the last index of &lt;code&gt;copy&lt;/code&gt; or a match has been found the &lt;code&gt;and&lt;/code&gt; is no longer true so the loop exits.  The &lt;code&gt;if&lt;/code&gt; simply checks to make sure that the &lt;code&gt;while&lt;/code&gt; exited because a match was found.  

The other "trick" of &lt;code&gt;and&lt;/code&gt; is used in this example.  If you look at the table for &lt;code&gt;and&lt;/code&gt; notice that the third entry is "false and false".   If &lt;code&gt;count &gt;= len(copy)&lt;/code&gt; (in other words &lt;code&gt;count &lt; len(copy)&lt;/code&gt; is false) then &lt;code&gt;copy[count]&lt;/code&gt; is never looked at.  This is because Python knows that if the first is false then they can't both be true.  This is known as a short circuit and is useful if the second half of the &lt;code&gt;and&lt;/code&gt; will cause an error if something is wrong.  I used the first expression (&lt;code&gt;count &lt; len(copy)&lt;/code&gt;) to check and see if &lt;code&gt;count&lt;/code&gt; was a valid index for &lt;code&gt;copy&lt;/code&gt;.  (If you don't believe me remove the matches "Jill" and "Life", check that it still works and then reverse the order of &lt;code&gt;count &lt; len(copy) and copy[count] != prev&lt;/code&gt; to &lt;code&gt;copy[count] != prev and count &lt; len(copy)&lt;/code&gt;.)

Boolean expressions can be used when you need to check two or more different things at once.

=== A note on Boolean Operators ===
A common mistake for people new to programming is a misunderstanding of the way that boolean operators works, which stems from the way the python interpreter reads these expressions.  For example, after initially learning about "and " and "or" statements, one might assume that the expression &lt;code&gt;x == ('a' or 'b')&lt;/code&gt; would check to see if the variable &lt;code&gt;x&lt;/code&gt; was equivalent to one of the strings &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'b'&lt;/code&gt;.  This is not so.  To see what I'm talking about, start an interactive session with the interpreter and enter the following expressions:

 &gt;&gt;&gt; 'a' == ('a' or 'b')
 &gt;&gt;&gt; 'b' == ('a' or 'b')
 &gt;&gt;&gt; 'a' == ('a' and 'b')
 &gt;&gt;&gt; 'b' == ('a' and 'b')

And this will be the unintuitive result:

 &gt;&gt;&gt;''' 'a' == ('a' or 'b')'''
 True
 &gt;&gt;&gt;''' 'b' == ('a' or 'b')'''
 False
 &gt;&gt;&gt;''' 'a' == ('a' and 'b')'''
 False 
 &gt;&gt;&gt;''' 'b' == ('a' and 'b')'''
 True

At this point, the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators seem to be broken.  It doesn't make sense that, for the first two expressions, &lt;code&gt;'a'&lt;/code&gt; is equivalent to &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'b'&lt;/code&gt; while &lt;code&gt;'b'&lt;/code&gt; is not.  Furthermore, it doesn't make any sense that 'b' is equivalent to &lt;code&gt;'a'&lt;/code&gt; and &lt;code&gt;'b'&lt;/code&gt;.  After examining what the interpreter does with boolean operators, these results do in fact exactly what you are asking of them, it's just not the same as what you think you are asking.

When the Python interpreter looks at an &lt;code&gt;or&lt;/code&gt; expression, it takes the first statement and checks to see if it is true. If the first statement is true, then Python returns that object's value without checking the second statement.  This is because for an &lt;code&gt;or&lt;/code&gt; expression, the whole thing is true if one of the values is true; the program does not need to bother with the second statement. On the other hand, if the first value is evaluated as false Python checks the second half and returns that value. That second half determines the truth value of the whole expression since the first half was false.  This "laziness" on the part of the interpreter is called "short circuiting" and is a common way of evaluating boolean expressions in many programming languages.

Similarly, for an &lt;code&gt;and&lt;/code&gt; expression, Python uses a short circuit technique to speed truth value evaluation.  If the first statement is false then the whole thing must be false, so it returns that value.  Otherwise if the first value is true it checks the second and returns that value.

One thing to note at this point is that the boolean expression returns a value indicating &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;, but that Python considers a number of different things to have a truth value assigned to them.  To check the truth value of any given object &lt;code&gt;x&lt;/code&gt;, you can use the fuction &lt;code&gt;bool(x)&lt;/code&gt; to see its truth value.  Below is a table with examples of the truth values of various objects:

{| class="wikitable"
|-
!True !!False
|-
|True ||False
|-
|1 ||0
|-
|Numbers other than zero ||The string 'None'
|-
|Nonempty strings ||Empty strings
|-
|Nonempty lists ||Empty lists 
|-
|Nonempty dictionaries ||Empty dictionaries
|}

Now it is possible to understand the perplexing results we were getting when we tested those boolean expressions before.  Let's take a look at what the interpreter "sees" as it goes through that code:

'''First case:'''
 &gt;&gt;&gt;''' 'a' == ('a' or 'b')'''  # Look at parentheses first, so evaluate expression "('a' or 'b')"
                            # 'a' is a nonempty string, so the first value is True
                            # Return that first value: 'a'
 &gt;&gt;&gt;''' 'a' == 'a' '''          # the string 'a' is equivalent to the string 'a', so expression is True
 True

'''Second case:'''
 &gt;&gt;&gt;''' 'b' == ('a' or 'b')'''  # Look at parentheses first, so evaluate expression "('a' or 'b')"
                            # 'a' is a nonempty string, so the first value is True
                            # Return that first value: 'a'
 &gt;&gt;&gt;''' 'b' == 'a' '''          # the string 'b' is not equivalent to the string 'a', so expression is False
 False 

'''Third case:'''
 &gt;&gt;&gt;''' 'a' == ('a' and 'b')''' # Look at parentheses first, so evaluate expression "('a' and 'b')"
                            # 'a' is a nonempty string, so the first value is True, examine second value
                            # 'b' is a nonempty string, so second value is True
                            # Return that second value as result of whole expression: 'b'
 &gt;&gt;&gt;''' 'a' == 'b' '''          # the string 'a' is not equivalent to the string 'b', so expression is False
 False

'''Fourth case:'''
 &gt;&gt;&gt;''' 'b' == ('a' and 'b')''' # Look at parentheses first, so evaluate expression "('a' and 'b')"
                            # 'a' is a nonempty string, so the first value is True, examine second value
                            # 'b' is a nonempty string, so second value is True
                            # Return that second value as result of whole expression: 'b'
 &gt;&gt;&gt;''' 'b' == 'b' '''          # the string 'b' is equivalent to the string 'b', so expression is True
 True 

So Python was really doing its job when it gave those apparently bogus results.  As mentioned previously, the important thing is to recognize what value your boolean expression will return when it is evaluated, because it isn't always obvious.  

Going back to those initial expressions, this is how you would write them out so they behaved in a way that you want:

 &gt;&gt;&gt;''' 'a' == 'a' or 'a' == 'b' '''
 True
 &gt;&gt;&gt;''' 'b' == 'a' or 'b' == 'b' '''
 True
 &gt;&gt;&gt;''' 'a' == 'a' and 'a' == 'b' '''
 False
 &gt;&gt;&gt;''' 'b' == 'a' and 'b' == 'b' '''
 False

When these comparisons are evaluated they return truth values in terms of True or False, not strings, so we get the proper results.

=== Examples ===
'''password1.py'''
&lt;source lang="python"&gt;
## This program asks a user for a name and a password.
# It then checks them to make sure that the user is allowed in.

name = input("What is your name? ")
password = input("What is the password? ")
if name == "Josh" and password == "Friday":
    print("Welcome Josh")
elif name == "Fred" and password == "Rock":
    print("Welcome Fred")
else:
    print("I don't know you.")
&lt;/source&gt;

Sample runs

 What is your name? '''Josh'''
 What is the password? '''Friday'''
 Welcome Josh

 What is your name? '''Bill'''
 What is the password? '''Money'''
 I don't know you.

=== Exercises ===
Write a program that has a user guess your name, but they only get 3 chances to do so until the program quits.

{{Solution|title=Solution|text=
&lt;source lang="python"&gt;
print("Try to guess my name!")
count = 1
name = "guilherme"
guess = input("What is my name? ")
while count &lt; 3 and guess.lower() != name:    # .lower allows things like Guilherme to still match
    print("You are wrong!")
    guess = input("What is my name? ")
    count = count + 1

if guess.lower() != name:
    print("You are wrong!") # this message isn't printed in the third chance, so we print it now
    print("You ran out of chances.")
else:
    print("Yes! My name is", name + "!")
&lt;/source&gt;

}}

{{navigation |previous=For Loops |next=Dictionaries}}
{{BookCat}}</text>
      <sha1>91kxhfse6wv9efbfwgl1yu15ld91s0u</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Count to 10</title>
    <ns>0</ns>
    <id>179829</id>
    <revision>
      <id>3595777</id>
      <parentid>3474413</parentid>
      <timestamp>2019-11-12T09:25:00Z</timestamp>
      <contributor>
        <ip>180.210.128.5</ip>
      </contributor>
      <comment>/* Fibonacci sequence */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8387" xml:space="preserve">=== While loops ===
Presenting our first ''control structure''.  Ordinarily the computer starts with the first line and then goes down from there.  Control structures change the order that statements are executed or decide if a certain statement will be run.  Here's the source for a program that uses the while control structure:

&lt;source lang="python"&gt;
a = 0            # FIRST, set the initial value of the variable a to 0(zero).
while a &lt; 10:    # While the value of the variable a is less than 10 do the following:
    a = a + 1    # Increase the value of the variable a by 1, as in: a = a + 1! 
    print(a)     # Print to screen what the present value of the variable a is.
                 # REPEAT! until the value of the variable a is equal to 9!? See note. 
                 
                 # NOTE:
                 # The value of the variable a will increase by 1
                 # with each repeat, or loop of the 'while statement BLOCK'.
                 # e.g. a = 1 then a = 2 then a = 3 etc. until a = 9 then...
                 # the code will finish adding 1 to a (now a = 10), printing the 
                 # result, and then exiting the 'while statement BLOCK'. 
                 #              --
                 # While a &lt; 10: |
                 #     a = a + 1 |&lt;--[ The while statement BLOCK ]
                 #     print (a) |
                 #              --
&lt;/source&gt;

And here is the extremely exciting output: 

 1
 2
 3
 4
 5
 6
 7
 8
 9
 10

(And you thought it couldn't get any worse after turning your computer into a five-dollar calculator?)

So what does the program do?  First it sees the line &lt;code&gt;a = 0&lt;/code&gt; and sets &lt;code&gt;a&lt;/code&gt; to zero. Then it sees &lt;code&gt;while a &lt; 10:&lt;/code&gt; and so the computer checks to see if &lt;code&gt;a &lt; 10&lt;/code&gt;. The first time the computer sees this statement, &lt;code&gt;a&lt;/code&gt; is zero, so it is less than 10. In other words, as long as &lt;code&gt;a&lt;/code&gt; is less than ten, the computer will run the tabbed in statements. This eventually makes &lt;code&gt;a&lt;/code&gt; equal to ten (by adding one to &lt;code&gt;a&lt;/code&gt; again and again) and the &lt;code&gt;while a &lt; 10&lt;/code&gt; is not true any longer. Reaching that point, the program will stop running the indented lines.

Always remember to put a colon "''':'''" at the end of the &lt;code&gt;while&lt;/code&gt; statement line!

Here is another example of the use of &lt;code&gt;while&lt;/code&gt;:
&lt;source lang="python"&gt;
a = 1
s = 0
print('Enter Numbers to add to the sum.')
print('Enter 0 to quit.')
while a != 0:                           
    print('Current Sum:', s)            
    a = float(input('Number? '))        
    s = s + a                            
print('Total Sum =', s)
&lt;/source&gt;

 Enter Numbers to add to the sum.
 Enter 0 to quit.
 Current Sum: 0
 Number? '''200'''
 Current Sum: 200.0
 Number? '''-15.25'''
 Current Sum: 184.75
 Number? '''-151.85'''
 Current Sum: 32.9
 Number? '''10.00'''
 Current Sum: 42.9
 Number? '''0'''
 Total Sum = 42.9

Notice how &lt;code&gt;print('Total Sum =', s)&lt;/code&gt; is only run at the end. The &lt;code&gt;while&lt;/code&gt; statement only affects the lines that are indented with whitespace. The &lt;code&gt;!=&lt;/code&gt; means does not equal so &lt;code&gt;while a != 0:&lt;/code&gt; means as long as &lt;code&gt;a&lt;/code&gt; is not zero run the tabbed statements that follow. 

Note that &lt;code&gt;a&lt;/code&gt; is a floating point number, and not all floating point numbers can be accurately represented, so using &lt;code&gt;!=&lt;/code&gt; on them can sometimes not work.  Try typing in 1.1 in interactive mode. 

==== Infinite loops or Never Ending Loop====
Now that we have while loops, it is possible to have programs that run forever. An easy way to do this is to write a program like this:
&lt;source lang="python"&gt;
while 1 == 1:
   print("Help, I'm stuck in a loop.")
&lt;/source&gt;

The "&lt;tt&gt;==&lt;/tt&gt;" operator is used to test equality of the expressions on the two sides of the operator, just as "&lt;tt&gt;&amp;lt;&lt;/tt&gt;" was used for "less than" before (you will get a complete list of all comparison operators in the next chapter).

This program will output &lt;code&gt;Help, I'm stuck in a loop.&lt;/code&gt; until the heat death of the universe or you stop it, because 1 will forever be equal to 1.  The way to stop it is to hit the Control (or ''Ctrl'') button and ''C'' (the letter) at the same time.  This will kill the program.  (Note: sometimes you will have to hit enter after the Control-C.) On some systems, nothing will stop it, short of killing the process--so avoid!

=== Examples ===
==== Fibonacci sequence ====
'''Fibonacci-method1.py'''
&lt;source lang="python"&gt;
# This program calculates the Fibonacci sequence
a = 0
b = 1
count = 0
max_count = 20

while count &lt; max_count:
    count = count + 1
    print(a, end=" ")  # Notice the magic end=" " in the print function arguments  
                       # that keeps it from creating a new line.
    old_a = a    # we need to keep track of a since we change it.
    a = b
    b = old_a + b
print()  # gets a new (empty) line.
&lt;/source&gt;

Output:
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181

Note that the output is on a single line because of the extra argument &lt;code&gt;end=" "&lt;/code&gt; in the &lt;code&gt;print&lt;/code&gt; arguments.

'''Fibonacci-method2.py'''
&lt;source lang="python"&gt;
# Simplified and faster method to calculate the Fibonacci sequence
a = 0
b = 1
count = 0
max_count = 20

while count &lt; max_count:
    count = count + 1
    print(a, b, end=" ")  # Notice the magic end=" "
    a = a + b    
    b = a + b
print()  # gets a new (empty) line.
&lt;/source&gt;

Output:
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181

'''Fibonacci-method3.py'''
&lt;source lang="python"&gt;
a = 0
b = 1
count = 0
maxcount = 20

#once loop is started we stay in it
while count &lt; maxcount:
    count += 1
    olda = a
    a = a + b
    b = olda
    print(olda,end=" ")
print()
&lt;/source&gt;

Output:
 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181

==== Enter password ====
'''Password.py'''
&lt;source lang="python"&gt;
# Waits until a password has been entered.  Use Control-C to break out without
# the password

#Note that this must not be the password so that the 
# while loop runs at least once.
password = str()

# note that != means not equal
while password != "unicorn":
    password = input("Password: ")
print("Welcome in")
&lt;/source&gt;

Sample run:
 Password: '''auo'''
 Password: '''y22'''
 Password: '''password'''
 Password: '''open sesame'''
 Password: '''unicorn'''
 Welcome in

=== Exercises ===
Write a program that asks the user for a Login Name and password.  Then when they type "lock", they need to type in their name and password to unlock the program.
{{Solution|title=Solution|text=

Write a program that asks the user for a Login Name and password.  Then when they type "lock", they need to type in their name and password to unlock the program.
&lt;source lang="python"&gt;
name = input("What is your UserName: ")
password = input("What is your Password: ")
print("To lock your computer type lock.")
command = None
input1 = None
input2 = None
while command != "lock":
    command = input("What is your command: ")
while input1 != name:
    input1 = input("What is your username: ")
while input2 != password:
    input2 = input("What is your password: ")
print("Welcome back to your system!")
&lt;/source&gt;

If you would like the program to run continuously, just add a &lt;code&gt;while 1 == 1:&lt;/code&gt; loop around the whole thing.
You will have to indent the rest of the program when you add this at the top of the code, but don't worry, you don't have to do it manually for each line! Just highlight everything you want to indent and click on "Indent" under "Format" in the top bar of the python window.

Another way of doing this could be:

&lt;source lang="python"&gt;
name = input('Set name: ')
password = input('Set password: ')
while 1 == 1:
    nameguess=""
    passwordguess=""
    key=""
    while (nameguess != name) or (passwordguess != password):
        nameguess = input('Name? ')
        passwordguess = input('Password? ')
    print("Welcome,", name, ". Type lock to lock.")
    while key != "lock":
        key = input("")
&lt;/source&gt;

Notice the &lt;code&gt;or&lt;/code&gt; in while &lt;code&gt;(nameguess != name) or (passwordguess != password)&lt;/code&gt;, which we haven't yet introduced. You can probably figure out how it works.
}}

{{navigation |previous=Who Goes There? |next=Decisions}}
{{BookCat}}

[[ca:Python 3 per a no programadors/Comptar fins a 10]]</text>
      <sha1>rz6tzyksld2vhhw0vggm9j5480fxjau</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Dealing with the imperfect</title>
    <ns>0</ns>
    <id>190102</id>
    <revision>
      <id>3171542</id>
      <parentid>2673943</parentid>
      <timestamp>2016-12-26T07:46:39Z</timestamp>
      <contributor>
        <username>Editbility</username>
        <id>3047780</id>
      </contributor>
      <comment>Add the solution to the exercise.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="4282" xml:space="preserve">=== ...or how to handle errors ===

=== closing files with with ===

We use the "with" statement to open and close files.&lt;ref&gt;
[http://docs.python.org/3.4/reference/compound_stmts.html#the-with-statement "The 'with' statement"]
&lt;/ref&gt;&lt;ref&gt;
[http://preshing.com/20110920/the-python-with-statement-by-example/ 'The Python "with" Statement by Example']
&lt;/ref&gt;

&lt;source lang="python"&gt;
with open("in_test.txt", "rt") as in_file:
    with open("out_test.txt", "wt") as out_file:
        text = in_file.read()
        data = parse(text)
        results = encode(data)
        out_file.write(results)
    print( "All done." )
&lt;/source&gt;

If some sort of error happens anywhere in this code
(one of the files is inaccessible,
the parse() function chokes on corrupt data,
etc.)
the "with" statements guarantee that all the files will eventually be properly closed. Closing a file just means that the file is "cleaned up" and "released" by our program so that it can be used in another program.

{{todo|
Is the "closing files with with" section too much detail for a non-programmers tutorial?
If so, move it to some other Python Wikibook ([[Subject:Python programming language]])
}}

=== catching errors with try ===
So you now have the perfect program, it runs flawlessly, except for one detail, it will crash on invalid user input.  Have no fear, for Python has a special control structure for you.  It's called &lt;code&gt;try&lt;/code&gt; and it tries to do something.  Here is an example of a program with a problem:
&lt;source lang="python"&gt;
print("Type Control C or -1 to exit")
number = 1
while number != -1:
   number = int(input("Enter a number: "))
   print("You entered:", number)
&lt;/source&gt;

Notice how when you enter &lt;code&gt;@#&amp;&lt;/code&gt; it outputs something like:

 Traceback (most recent call last):
  File "try_less.py", line 4, in &lt;module&gt;
    number = int(input("Enter a number: "))
 ValueError: invalid literal for int() with base 10: '\\@#&amp;'

As you can see the &lt;code&gt;int()&lt;/code&gt; function is unhappy with the number &lt;code&gt;@#&amp;&lt;/code&gt; (as well it should be).  The last line shows what the problem is; Python found a &lt;code&gt;ValueError&lt;/code&gt;.   How can our program deal with this?  What we do is first: put the place where errors may occur in a &lt;code&gt;try&lt;/code&gt; block, and second: tell Python how we want &lt;code&gt;ValueError&lt;/code&gt;s handled.  The following program does this:
&lt;source lang="python"&gt;
print("Type Control C or -1 to exit")
number = 1
while number != -1:
    try:
        number = int(input("Enter a number: "))
        print("You entered:", number)
    except ValueError:
        print("That was not a number.")
&lt;/source&gt;

Now when we run the new program and give it &lt;code&gt;@#&amp;&lt;/code&gt; it tells us "That was not a number." and continues with what it was doing before.

When your program keeps having some error that you know how to handle, put code in a &lt;code&gt;try&lt;/code&gt; block, and put the way to handle the error in the &lt;code&gt;except&lt;/code&gt; block.

=== Exercises ===
Update at least the phone numbers program (in section [[../Dictionaries|Dictionaries]]) so it doesn't crash if a user doesn't enter any data at the menu.
{{Solution|title=Solution|text=
&lt;source lang="python"&gt;
def print_menu():
	print('1. Print Phone Numbers')
	print('2. Add a Phone Number')
	print('3. Remove a Phone Number')
	print('4. Lookup a Phone Number')
	print('5. Quit')
	print()

numbers = {}
menu_choice = 0
print_menu()
while menu_choice != 5:
	try:
		menu_choice = int(input("Type in a number (1-5): "))
		if menu_choice == 1:
			print("Telephone Numbers:")
			for x in numbers.keys():
				print("Name: ", x, "\tNumber:", numbers[x])
			print()
		elif menu_choice == 2:
			print("Add Name and Number")
			name = input("Name: ")
			phone = input("Number: ")
			numbers[name] = phone
		elif menu_choice == 3:
			print("Remove Name and Number")
			name = input("Name: ")
			if name in numbers:
				del numbers[name]
			else:
				print(name, "was not found")
		elif menu_choice == 4:
			print("Lookup Number")
			name = input("Name: ")
			if name in numbers:
				print("The number is", numbers[name])
			else:
				print(name, "was not found")
		elif menu_choice != 5:
			print_menu()
	except ValueError:
		print("That was not a number.")&lt;/source&gt;

}}
{{navigation |previous=File IO |next=Recursion}}
{{BookCat}}</text>
      <sha1>a0ve9pengst6645j7ev6meniecb411d</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Debugging</title>
    <ns>0</ns>
    <id>179901</id>
    <revision>
      <id>2544380</id>
      <parentid>2263100</parentid>
      <timestamp>2013-07-20T15:50:16Z</timestamp>
      <contributor>
        <username>Götz</username>
        <id>254632</id>
      </contributor>
      <comment>update {{navigation}}, add {{BookCat}}</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10165" xml:space="preserve">=== What is debugging? ===
:"As soon as we started programming, we found to our surprise that it wasn't as easy  to get programs right as we had thought.  Debugging had to be discovered.  I can remember the exact instant when I realized that a large part of my life from then on was going to be spent in finding mistakes in my own programs." &amp;mdash; ''Maurice Wilkes discovers debugging'', 1949

By now if you have been messing around with the programs you have probably found that sometimes the program does something you didn't want it to do.  This is fairly common.  Debugging is the process of figuring out what the computer is doing and then getting it to do what you want it to do.  This can be tricky.  I once spent nearly a week tracking down and fixing a bug that was caused by someone putting an &lt;code&gt;x&lt;/code&gt; where a &lt;code&gt;y&lt;/code&gt; should have been.  

This chapter will be more abstract than previous chapters.

=== What should the program do? ===

The first thing to do (this sounds obvious) is to figure out what the
program should be doing if it is running correctly.  Come up with some
test cases and see what happens.  For example, let's say I have a
program to compute the perimeter of a rectangle (the sum of the length
of all the edges).  I have the following test cases:

{| class="wikitable"
|-
!height !! width !!perimeter
|-
|3 ||4 ||14
|--
|2 ||3 ||10
|-
|4 ||4 ||16
|-
|2 ||2 ||8
|-
|5 ||1 ||12
|-
|}

I now run my program on all of the test cases and see if the program does what 
I expect it to do.  If it doesn't then I need to find out what the computer is
doing.

More commonly some of the test cases will work and some will not.  If that is the case you should try and figure out what the working ones have in common. 
For example here is the output for a perimeter program (you get to see the code in a minute):

 Height: '''3'''
 Width: '''4'''
 perimeter = 15

 Height: '''2'''
 Width: '''3'''
 perimeter = 11

 Height: '''4'''
 Width: '''4'''
 perimeter = 16

 Height: '''2'''
 Width: '''2'''
 perimeter = 8

 Height: '''5'''
 Width: '''1'''
 perimeter = 8

Notice that it didn't work for the first two inputs, it worked for the next
two and it didn't work on the last one.  Try and figure out what is in common 
with the working ones.  Once you have some idea what the problem is finding the
cause is easier.  With your own programs you should try more test cases if you need them.

=== What does the program do? ===

The next thing to do is to look at the source code.  One of the most important things to do while programming is reading source code.  The primary way to do this is code walkthroughs.  

A code walkthrough starts at the first line, and works its way down until the program is done.  &lt;code&gt;while&lt;/code&gt; loops and &lt;code&gt;if&lt;/code&gt; statements mean that some lines may never be run and some lines are run many times.  At each line you figure out what Python has done.

Lets start with the simple perimeter program.  Don't type it in, you are going to read it, not run it.  The source code is:

&lt;source lang="python"&gt;
height = int(input("Height: "))
width = int(input("Width: "))
print("perimeter =", width + height + width + width)
&lt;/source&gt;

; ''Question:'' What is the first line Python runs?
: ''Answer:'' The first line is always run first.  In this case it is: &lt;code&gt;height = int(input("Height: "))&lt;/code&gt;
; What does that line do?
: Prints &lt;code&gt; Height: &lt;/code&gt;, waits for the user to type a string in, and then converts the string to an integer variable height.
; What is the next line that runs?
: In general, it is the next line down which is: &lt;code&gt;width = int(input("Width: "))&lt;/code&gt;
; What does that line do?
: Prints &lt;code&gt;Width: &lt;/code&gt;, waits for the user to type a number in, and puts what the user types in the variable width.
; What is the next line that runs?
: When the next line is not indented more or less than the current line, it is the line right afterwards, so it is: &lt;code&gt;print("perimeter = ", width + height + width + width)&lt;/code&gt; (It may also run a function in the current line, but that's a future chapter.)                                                                       
; What does that line do?
: First it prints &lt;code&gt;perimeter = &lt;/code&gt;, then it prints the sum of the values contained within the variables, &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, from &lt;code&gt;width + height + width + width&lt;/code&gt;.
; Does &lt;code&gt;width + height + width + width&lt;/code&gt; calculate the perimeter properly?
: Let's see, perimeter of a rectangle is the bottom (width) plus the left side (height) plus the top (width) plus the right side (huh?). The last item should be the right side's length, or the height.
; Do you understand why some of the times the perimeter was calculated "correctly"?                                                                             
: It was calculated correctly when the width and the height were equal.

The next program we will do a code walkthrough for is a program that is supposed to print out 5 dots on the screen.  However, this is what the program is outputting:

 . . . . 

And here is the program:
&lt;source lang="python"&gt;
number = 5
while number &gt; 1:
    print(".",end=" ")
    number = number - 1
print()
&lt;/source&gt;

This program will be more complex to walkthrough since it now has indented portions (or control structures).  Let us begin.
; What is the first line to be run?
: The first line of the file: &lt;code&gt;number = 5&lt;/code&gt;
; What does it do?
: Puts the number 5 in the variable number.
; What is the next line?
: The next line is: &lt;code&gt;while number &gt; 1:&lt;/code&gt;
; What does it do?
: Well, &lt;code&gt;while&lt;/code&gt; statements in general look at their expression, and if it is true they do the next indented block of code, otherwise they skip the next indented block of code.
; So what does it do right now?
: If &lt;code&gt;number &gt; 1&lt;/code&gt; is true then the next two lines will be run.
; So is &lt;code&gt;number &gt; 1&lt;/code&gt;?
: The last value put into &lt;code&gt;number&lt;/code&gt; was &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;5 &gt; 1&lt;/code&gt; so yes.
; So what is the next line?
: Since the &lt;code&gt; while&lt;/code&gt; was true the next line is: &lt;code&gt;print(".",end=" ")&lt;/code&gt;
; What does that line do?
: Prints one dot and since the extra argument &lt;code&gt;end=" "&lt;/code&gt; exists the next printed text will not be on a different screen line.
; What is the next line?
: &lt;code&gt;number = number - 1&lt;/code&gt; since that is following line and there are no indent changes.
; What does it do?
: It calculates &lt;code&gt;number - 1&lt;/code&gt;, which is the current value of &lt;code&gt;number&lt;/code&gt; (or 5) subtracts 1 from it, and makes that the new value of number.  So basically it changes &lt;code&gt; number&lt;/code&gt;'s value from 5 to 4.
; What is the next line?
: Well, the indent level decreases so we have to look at what type of control structure it is.  It is a &lt;code&gt;while&lt;/code&gt; loop, so we have to go back to the &lt;code&gt;while&lt;/code&gt; clause which is &lt;code&gt;while number &gt; 1:&lt;/code&gt;
; What does it do?
: It looks at the value of number, which is 4, and compares it to 1 and since &lt;code&gt;4 &gt; 1&lt;/code&gt; the while loop continues.
; What is the next line?
: Since the while loop was true, the next line is: &lt;code&gt;print(".",end=" ")&lt;/code&gt;
; What does it do?
: It prints a second dot on the line, ending by a space.
; What is the next line?
: No indent change so it is: &lt;code&gt;number = number - 1&lt;/code&gt;
; And what does it do?
: It takes the current value of number (4), subtracts 1 from it, which gives it 3 and then finally makes 3 the new value of number.
; What is the next line?
: Since there is an indent change caused by the end of the while loop, the next line is: &lt;code&gt;while number &gt; 1:&lt;/code&gt;
; What does it do?
: It compares the current value of number (3) to 1. &lt;code&gt;3 &gt; 1&lt;/code&gt; so the while loop continues.
; What is the next line?
: Since the while loop condition was true the next line is: &lt;code&gt;print(".",end=" ")&lt;/code&gt;
; And it does what?
: A third dot is printed on the line.
; What is the next line?
: It is: &lt;code&gt;number = number - 1&lt;/code&gt;
; What does it do?
: It takes the current value of number (3) subtracts from it 1 and makes the 2 the new value of number.
; What is the next line?
: Back up to the start of the while loop: &lt;code&gt;while number &gt; 1:&lt;/code&gt;
; What does it do?
: It compares the current value of number (2) to 1.  Since &lt;code&gt;2 &gt; 1&lt;/code&gt; the while loop continues.
; What is the next line?
: Since the while loop is continuing: &lt;code&gt;print(".",end=" ")&lt;/code&gt;
; What does it do?
: It discovers the meaning of life, the universe and everything.  I'm joking. (I had to make sure you were awake.)  The line prints a fourth dot on the screen.
; What is the next line?
: It's: &lt;code&gt;number = number - 1&lt;/code&gt;
; What does it do?
: Takes the current value of number (2) subtracts 1 and makes 1 the new value of number.
; What is the next line?
: Back up to the while loop: &lt;code&gt;while number &gt; 1:&lt;/code&gt;
; What does the line do?
: It compares the current value of number (1) to 1. Since &lt;code&gt;1 &gt; 1&lt;/code&gt; is false (one is not greater than one), the while loop exits.
; What is the next line?
: Since the while loop condition was false the next line is the line after the while loop exits, or: &lt;code&gt;print()&lt;/code&gt;
; What does that line do?
: Makes the screen go to the next line.
; Why doesn't the program print 5 dots?
: The loop exits 1 dot too soon.
; How can we fix that?
: Make the loop exit 1 dot later.
; And how do we do that?
: There are several ways.  One way would be to change the while loop to: &lt;code&gt;while number &gt; 0:&lt;/code&gt;  Another way would be to change the conditional to: &lt;code&gt;number &gt;= 1&lt;/code&gt;  There are a couple others.

=== How do I fix my program? ===

You need to figure out what the program is doing.  You need to figure out what the program should do.  Figure out what the difference between the two is.  Debugging is a skill that has to be practiced to be learned. If you can't figure it out after an hour, take a break, talk to someone about the problem or contemplate the lint in your navel.  Come back in a while and you will probably have new ideas about the problem.  Good luck.

{{navigation |previous=Decisions |next=Defining Functions}}
{{BookCat}}</text>
      <sha1>l62c2ehmia00rh1uoq45aosfy3kn84u</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Decisions</title>
    <ns>0</ns>
    <id>179832</id>
    <revision>
      <id>3654000</id>
      <parentid>3653996</parentid>
      <timestamp>2020-01-19T18:25:01Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/2606:A000:1019:476D:183:4503:1D49:878F|2606:A000:1019:476D:183:4503:1D49:878F]] ([[User talk:2606:A000:1019:476D:183:4503:1D49:878F|talk]]) to last version by JackPotte</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="7796" xml:space="preserve">=== If statement ===
As always, I believe I should start each chapter with a warm-up typing exercise, so here is a short program to compute the absolute value of an integer:
&lt;source lang="python"&gt;
n = int(input("Number? "))
if n &lt; 0:
   print("The absolute value of", n, "is", -n)
else:
   print("The absolute value of", n, "is", n)
&lt;/source&gt;

Here is the output from the two times that I ran this program:

 Number? '''-34'''
 The absolute value of -34 is 34

 Number? '''1'''
 The absolute value of 1 is 1

So what does the computer do when it sees this piece of code?  First it prompts the user for a number with the statement "&lt;code&gt;n = int(input("Number? "))&lt;/code&gt;".  Next it reads the line "&lt;code&gt;if n &lt; 0:&lt;/code&gt;". If &lt;code&gt;n&lt;/code&gt; is less than zero Python runs the line "&lt;code&gt;print("The absolute value of", n, "is", -n)&lt;/code&gt;". Otherwise it runs the line "&lt;code&gt;print("The absolute value of", n, "is", n)&lt;/code&gt;".  

More formally Python looks at whether the ''expression'' &lt;code&gt;n &lt; 0&lt;/code&gt; is true or false.  An &lt;code&gt;if&lt;/code&gt; statement is followed by an indented ''block'' of statements that are run when the expression is true.  Optionally after the &lt;code&gt;if&lt;/code&gt; statement is an &lt;code&gt;else&lt;/code&gt; statement and another indented ''block'' of statements.  This second block of statements is run if the expression is false.  

There are a number of different tests that an expression can have.  Here is a table of all of them:

{| class="wikitable"
!operator 
!function
|-
|&lt;code&gt;&lt;&lt;/code&gt; 
|less than
|-
|&lt;code&gt;&lt;=&lt;/code&gt; 
|less than or equal to
|-
|&lt;code&gt;&gt;&lt;/code&gt; 
|greater than
|-
|&lt;code&gt;&gt;=&lt;/code&gt; 
|greater than or equal to
|-
|&lt;code&gt;==&lt;/code&gt; 
|equal
|-
|&lt;code&gt;!=&lt;/code&gt; 
|not equal
|}

Another feature of the &lt;code&gt; if&lt;/code&gt; command is the &lt;code&gt; elif &lt;/code&gt; statement.  It stands for else if and means if the original &lt;code&gt; if&lt;/code&gt; statement is false but the &lt;code&gt; elif&lt;/code&gt; part is true, then do the &lt;code&gt;elif&lt;/code&gt; part. And if neither the &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;elif&lt;/code&gt; expressions are true, then do what's in the &lt;code&gt;else&lt;/code&gt; block. Here's an example:
&lt;source lang="python"&gt;
a = 0
while a &lt; 10:
    a = a + 1
    if a &gt; 5:
        print(a, "&gt;", 5)
    elif a &lt;= 3:
        print(a, "&lt;=", 3)
    else:
        print("Neither test was true")
&lt;/source&gt;

and the output:

 1 &lt;= 3
 2 &lt;= 3
 3 &lt;= 3
 Neither test was true
 Neither test was true
 6 &gt; 5
 7 &gt; 5
 8 &gt; 5
 9 &gt; 5
 10 &gt; 5

Notice how the &lt;code&gt;elif a &lt;= 3&lt;/code&gt; is only tested when the &lt;code&gt;if&lt;/code&gt; statement fails to be true. There can be more than one &lt;code&gt;elif&lt;/code&gt; expression, allowing multiple tests to be done in a single &lt;code&gt;if&lt;/code&gt; statement.

=== Examples ===
&lt;source lang="python"&gt;
# This Program Demonstrates the use of the == operator
# using numbers
print(5 == 6)
# Using variables
x = 5
y = 8
print(x == y)
&lt;/source&gt;

And the output

 False
 False

'''high_low.py'''&lt;!--\label{firsthighlow}--&gt;
&lt;source lang="python"&gt;
# Plays the guessing game higher or lower 

# This should actually be something that is semi random like the
# last digits of the time or something else, but that will have to
# wait till a later chapter.  (Extra Credit, modify it to be random
# after the Modules chapter)
number = 7
guess = -1

print("Guess the number!")
while guess != number:
    guess = int(input("Is it... "))

    if guess == number:
        print("Hooray! You guessed it right!")
    elif guess &lt; number:
        print("It's bigger...")
    elif guess &gt; number:
        print("It's not so big.")
&lt;/source&gt;

Sample run:

 Guess the number!
 Is it... '''2'''
 It's bigger...
 Is it... '''5'''
 It's bigger...
 Is it... '''10'''
 It's not so big.
 Is it... '''7'''
 Hooray! You guessed it right!

'''even.py'''

&lt;source lang="python"&gt;
# Asks for a number.
# Prints if it is even or odd
 
number = float(input("Tell me a number: "))
if number % 2 == 0:
    print(int(number), "is even.")
elif number % 2 == 1:
    print(int(number), "is odd.")
else:
    print(number, "is very strange.")
&lt;/source&gt;

Sample runs:

 Tell me a number: '''3'''
 3 is odd.

 Tell me a number: '''2'''
 2 is even.

 Tell me a number: '''3.4895'''
 3.4895 is very strange.

'''average1.py'''
&lt;source lang="python"&gt;
# keeps asking for numbers until 0 is entered.
# Prints the average value.

count = 0
sum = 0.0
number = 1 # set to something that will not exit the while loop immediately.

print("Enter 0 to exit the loop")

while number != 0:
    number = float(input("Enter a number: "))
    if number != 0:
        count = count + 1
        sum = sum + number
    if number == 0:
        print("The average was:", sum / count)
&lt;/source&gt;
{{Solution|title=Sample runs|text=
Sample runs:

 Enter 0 to exit the loop
 Enter a number: '''3'''
 Enter a number: '''5'''
 Enter a number: '''0'''
 The average was: 4.0

 Enter 0 to exit the loop
 Enter a number: '''1'''
 Enter a number: '''4'''
 Enter a number: '''3'''
 Enter a number: '''0'''
 The average was: 2.66666666667
}}
'''average2.py'''
&lt;source lang="python"&gt;
# keeps asking for numbers until count numbers have been entered.
# Prints the average value.

#Notice that we use an integer to keep track of how many numbers, 
# but floating point numbers for the input of each number
sum = 0.0

print("This program will take several numbers then average them")
count = int(input("How many numbers would you like to average: "))
current_count = 0

while current_count &lt; count:
    current_count = current_count + 1
    print("Number", current_count)
    number = float(input("Enter a number: "))
    sum = sum + number
    
print("The average was:", sum / count)
&lt;/source&gt;

Sample runs:

 This program will take several numbers then average them
 How many numbers would you like to average: '''2'''
 Number 1
 Enter a number: '''3'''
 Number 2
 Enter a number: '''5'''
 The average was: 4.0

 This program will take several numbers then average them
 How many numbers would you like to average: '''3'''
 Number 1
 Enter a number: '''1'''
 Number 2
 Enter a number: '''4'''
 Number 3
 Enter a number: '''3'''
 The average was: 2.66666666667
&lt;!-- TODO: add another example --&gt;

=== Exercises ===
Write a program that asks the user their name, if they enter your name
say "That is a nice name", if they enter "John Cleese" or "Michael
Palin", tell them how you feel about them ;), otherwise tell them "You
have a nice name."

{{Solution|title=Solution|text=
&lt;source lang="python"&gt;
name = input('Your name: ')
if name == 'Bryn':
    print('That is a nice name.')
elif name == 'John Cleese':
    print('... some funny text.')
elif name == 'Michael Palin':
    print('... some funny text.')
else:
    print('You have a nice name.')
&lt;/source&gt;
}}

Modify the higher or lower program from this section to keep track of how many times the user has entered the wrong number.  If it is more than 3 times, print "That must have been complicated." at the end, otherwise print "Good job!"

{{Solution|title=Solution|text=
&lt;source lang="python"&gt;
number = 7
guess = -1
count = 0

print("Guess the number!")
while guess != number:
    guess = int(input("Is it... "))
    count = count + 1
    if guess == number:
        print("Hooray! You guessed it right!")
    elif guess &lt; number:
        print("It's bigger...")
    elif guess &gt; number:
        print("It's not so big.")

if count &gt; 3:
    print("That must have been complicated.")
else:
    print("Good job!")
&lt;/source&gt;
}}

Write a program that asks for two numbers.  If the sum of the numbers 
is greater than 100, print "That is a big number."

{{Solution|title=Solution|text=
&lt;source lang="python"&gt;
number1 = float(input('1st number: '))
number2 = float(input('2nd number: '))
if number1 + number2 &gt; 100:
    print('That is a big number.')
&lt;/source&gt;
}}

{{navigation |previous=Count to 10 |next=Debugging}}
{{BookCat}}</text>
      <sha1>p683u24m4bydy0m1u0mwoa4nmw6jdlp</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Defining Functions</title>
    <ns>0</ns>
    <id>180493</id>
    <revision>
      <id>3589878</id>
      <parentid>3589819</parentid>
      <timestamp>2019-10-25T05:07:49Z</timestamp>
      <contributor>
        <username>Mrjulesd</username>
        <id>1779740</id>
      </contributor>
      <comment>Rejected the last text change (by [[Special:Contributions/153.107.33.83|153.107.33.83]]) and restored revision 3554544 by JackPotte</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10794" xml:space="preserve">=== Creating Functions ===
To start off this chapter I am going to give you an example of what you could do but shouldn't (so don't type it in):
&lt;source lang=python&gt;
a = 23
b = -23

if a &lt; 0:
    a = -a
if b &lt; 0:
    b = -b
if a == b:
    print("The absolute values of", a, "and", b, "are equal.")
else:
    print("The absolute values of", a, "and", b, "are different.")
&lt;/source&gt;

with the output being:

 The absolute values of 23 and 23 are equal.

The program seems a little repetitive. Programmers hate to repeat things -- that's what computers are for, after all! (Note also that finding the absolute value changed the value of the variable, which is why it is printing out 23, and not -23 in the output.) Fortunately Python allows you to create functions to remove duplication.  Here is the rewritten example:
&lt;source lang=python&gt;
a = 23
b = -23

def absolute_value(n):
    if n &lt; 0:
        n = -n
    return n

if absolute_value(a) == absolute_value(b):
    print("The absolute values of", a, "and", b, "are equal.")
else:
    print("The absolute values of", a, "and", b, "are different.")
&lt;/source&gt;

with the output being:

 The absolute values of 23 and -23 are equal.

The key feature of this program is the &lt;code&gt;def&lt;/code&gt; statement.  &lt;code&gt;def&lt;/code&gt;
(short for define) starts a function definition.  &lt;code&gt;def&lt;/code&gt; is
followed by the name of the function &lt;code&gt;absolute_value&lt;/code&gt;.  Next comes a '(' followed by the parameter &lt;code&gt;n&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt; is passed from the program into the function when the function is called).  The statements after the ':' are executed when the function is used.  The statements continue until either the indented statements end or a &lt;code&gt;return&lt;/code&gt; is encountered.  The &lt;code&gt;return&lt;/code&gt; statement returns a value back to the place where the function was called. We already have encountered a function in our very first program, the &lt;code&gt;print&lt;/code&gt; function.  Now we can make new functions.  

Notice how the values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are not changed.
Functions can be used to repeat tasks that don't return
values.  Here are some examples:
&lt;source lang="python"&gt;
def hello():
    print("Hello")

def area(width, height):
    return width * height

def print_welcome(name):
    print("Welcome", name)

hello()
hello()

print_welcome("Fred")
w = 4
h = 5
print("width =", w, " height =", h, " area =", area(w, h))
&lt;/source&gt;

with output being:

 Hello
 Hello
 Welcome Fred
 width = 4  height = 5  area = 20

That example shows some more stuff that you can do with
functions.  Notice that you can use no arguments or two or more.
Notice also when a function doesn't need to send back a value, a
return is optional.
&lt;!-- Functions can be used to eliminate repeat code. --&gt;

=== Variables in functions ===
When eliminating repeated code, you often have variables in the repeated code.  In Python, these are dealt with in a special way.  So far all variables we have seen are global variables.  Functions have a special type of variable called local variables.  These variables only exist while the function is running.  When a local variable has the same name as another variable (such as a global variable), the local variable hides the other.  Sound confusing?  Well, these next examples (which are a bit contrived) should help clear things up.

&lt;source lang="python"&gt;
a = 4
 
def print_func():
    a = 17
    print("in print_func a =", a)

print_func()
print("a = ", a)
&lt;/source&gt;

When run, we will receive an output of:

 in print_func a = 17
 a = 4

Variable assignments inside a function do not override global variables, they exist only inside the function.  Even though &lt;code&gt;a&lt;/code&gt; was assigned a new value inside the function, this newly assigned value was only relevant to &lt;code&gt;print_func&lt;/code&gt;, when 
the function finishes running, and the &lt;code&gt;a&lt;/code&gt;'s values is printed again, we see the originally assigned values.

Here is another more complex example.

&lt;source lang="python"&gt;
a_var = 10
b_var = 15
e_var = 25

def a_func(a_var):
    print("in a_func a_var =", a_var)
    b_var = 100 + a_var
    d_var = 2 * a_var
    print("in a_func b_var =", b_var)
    print("in a_func d_var =", d_var)
    print("in a_func e_var =", e_var)
    return b_var + 10

c_var = a_func(b_var)

print("a_var =", a_var)
print("b_var =", b_var)
print("c_var =", c_var)
print("d_var =", d_var)

&lt;/source&gt;

output:

 in a_func a_var =  15
 in a_func b_var =  115
 in a_func d_var =  30
 in a_func e_var =  25
 a_var =  10
 b_var =  15
 c_var =  125
 d_var = 
 
 Traceback (most recent call last):
  File "C:\def2.py", line 19, in &lt;module&gt;
    print("d_var = ", d_var)
 NameError: name 'd_var' is not defined


In this example the variables &lt;code&gt;a_var&lt;/code&gt;, &lt;code&gt;b_var&lt;/code&gt;, and &lt;code&gt;d_var&lt;/code&gt; are all local variables when they are inside the function &lt;code&gt;a_func&lt;/code&gt;.  After the statement &lt;code&gt;return b_var + 10&lt;/code&gt; is run, they all cease to exist. The variable &lt;code&gt;a_var&lt;/code&gt; is automatically a local variable since it is a parameter name.  The variables &lt;code&gt;b_var&lt;/code&gt; and &lt;code&gt;d_var&lt;/code&gt; are local variables since they appear on the left of an equals sign in the function in the statements &lt;code&gt;b_var = 100 + a_var&lt;/code&gt; and &lt;code&gt;d_var = 2 * a_var&lt;/code&gt; .

Inside of the function &lt;code&gt;a_var&lt;/code&gt; has no value assigned to it.  When the function is called with &lt;code&gt;c_var = a_func(b_var)&lt;/code&gt;, 15 is assigned to &lt;code&gt;a_var&lt;/code&gt; since at that point in time &lt;code&gt;b_var&lt;/code&gt; is 15, making the call to the function &lt;code&gt;a_func(15)&lt;/code&gt;.  This ends up setting &lt;code&gt;a_var&lt;/code&gt; to 15 when it is inside of &lt;code&gt;a_func&lt;/code&gt;.

As you can see, once the function finishes running, the local variables
&lt;code&gt;a_var&lt;/code&gt; and &lt;code&gt;b_var&lt;/code&gt; that had hidden the global variables of the same name are gone.  Then the statement &lt;code&gt;print("a_var = ", a_var)&lt;/code&gt; prints the value &lt;code&gt;10&lt;/code&gt; rather than the value &lt;code&gt;15&lt;/code&gt; since the local variable 
that hid the global variable is gone.  

Another thing to notice is the &lt;code&gt;NameError&lt;/code&gt; that happens at the end.  This appears since the variable &lt;code&gt;d_var&lt;/code&gt; no longer exists since &lt;code&gt;a_func&lt;/code&gt; finished.  All the local variables are deleted when the function exits.  If you want to get something from a function, then you will have to use &lt;code&gt;return something&lt;/code&gt;.

One last thing to notice is that the value of &lt;code&gt;e_var&lt;/code&gt; remains unchanged inside &lt;code&gt;a_func&lt;/code&gt; since it is not a parameter and it never appears on the left of an equals sign inside of the function &lt;code&gt;a_func&lt;/code&gt;.  When a global variable is accessed inside a function it is the global variable from the outside.

Functions allow local variables that exist only inside the function and 
can hide other variables that are outside the function.

=== Examples ===
'''temperature2.py'''
&lt;source lang="python"&gt;
#! /usr/bin/python
#-*-coding: utf-8 -*-
# converts temperature to Fahrenheit or Celsius
 
def print_options():
    print("Options:")
    print(" 'p' print options")
    print(" 'c' convert from Celsius")
    print(" 'f' convert from Fahrenheit")
    print(" 'q' quit the program")
 
def celsius_to_fahrenheit(c_temp):
    return 9.0 / 5.0 * c_temp + 32
 
def fahrenheit_to_celsius(f_temp):
    return (f_temp - 32.0) * 5.0 / 9.0
 
choice = "p"
while choice != "q":
    if choice == "c":
        c_temp = float(input("Celsius temperature: "))
        print("Fahrenheit:", celsius_to_fahrenheit(c_temp))
        choice = input("option: ")
    elif choice == "f":
        f_temp = float(input("Fahrenheit temperature: "))
        print("Celsius:", fahrenheit_to_celsius(f_temp))
        choice = input("option: ")
    else:
        choice = "p"    #Alternatively choice != "q": so that print 
                        #when anything unexpected inputed
        print_options()
        choice = input("option: ")
&lt;/source&gt;

Sample Run:

 Options:
  'p' print options
  'c' convert from celsius
  'f' convert from fahrenheit
  'q' quit the program
 option: '''c'''
 Celsius temperature: '''30''' 
 Fahrenheit: 86.0
 option: '''f'''
 Fahrenheit temperature: '''60'''
 Celsius: 15.5555555556
 option: '''q'''

'''area2.py'''
&lt;source lang="python"&gt;
#! /usr/bin/python
#-*-coding: utf-8 -*-
# calculates a given rectangle area

def hello():
    print('Hello!')
 
def area(width, height):
    return width * height
 
def print_welcome(name):
    print('Welcome,', name)
 
def positive_input(prompt):
    number = float(input(prompt))
    while number &lt;= 0:
        print('Must be a positive number')
        number = float(input(prompt))
    return number
 
name = input('Your Name: ')
hello()
print_welcome(name)
print()
print('To find the area of a rectangle,')
print('enter the width and height below.')
print()
w = positive_input('Width: ')
h = positive_input('Height: ')
 
print('Width =', w, ' Height =', h, ' so Area =', area(w, h))
&lt;/source&gt;

Sample Run:

 Your Name: '''Josh'''
 Hello!
 Welcome, Josh
 
 To find the area of a rectangle,
 enter the width and height below.
 
 Width: '''-4'''
 Must be a positive number
 Width: '''4'''
 Height: '''3'''
 Width = 4  Height = 3  so Area = 12

=== Exercises ===
Rewrite the area2.py program from the Examples above to have a separate function for the area of a square, the area of a rectangle, and the area of a circle (&lt;code&gt;3.14 * radius**2&lt;/code&gt;). This program should include a menu interface.

{{Solution|title=Solution|text=

&lt;source lang="python"&gt;
def square(L):
    return L * L

def rectangle(width , height):
    return width * height

def circle(radius):
    return 3.14159 * radius ** 2

def options():
    print()
    print("Options:")
    print("s = calculate the area of a square.")
    print("c = calculate the area of a circle.")
    print("r = calculate the area of a rectangle.")
    print("q = quit")
    print()

print("This program will calculate the area of a square, circle or rectangle.")
choice = "x"
options()
while choice != "q":
    choice = input("Please enter your choice: ")
    if choice == "s":
        L = float(input("Length of square side: "))
        print("The area of this square is", square(L))
        options()
    elif choice == "c":
        radius = float(input("Radius of the circle: "))
        print("The area of the circle is", circle(radius))
        options()
    elif choice == "r":
        width = float(input("Width of the rectangle: "))
        height = float(input("Height of the rectangle: "))
        print("The area of the rectangle is", rectangle(width, height))
        options()
    elif choice == "q":
        print(" ",end="")
    else:
        print("Unrecognized option.")
        options()
&lt;/source&gt;
}}

{{navigation |previous=Debugging |next=Advanced Functions Example}}
{{BookCat}}</text>
      <sha1>rtojnxefvixpe2qx9iotlfl1es3udsg</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Dictionaries</title>
    <ns>0</ns>
    <id>182534</id>
    <revision>
      <id>3104638</id>
      <parentid>3104634</parentid>
      <timestamp>2016-08-09T04:31:19Z</timestamp>
      <contributor>
        <ip>203.59.222.158</ip>
      </contributor>
      <comment>Corrected grammar of "a easy" to "an easy".</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10897" xml:space="preserve">This chapter is about dictionaries.  Dictionaries have keys and values.  The keys are used to find the values. Here is an example of a dictionary in use:
&lt;source lang="python"&gt;
def print_menu():
    print('1. Print Phone Numbers')
    print('2. Add a Phone Number')
    print('3. Remove a Phone Number')
    print('4. Lookup a Phone Number')
    print('5. Quit')
    print()

numbers = {}
menu_choice = 0
print_menu()
while menu_choice != 5:
    menu_choice = int(input("Type in a number (1-5): "))
    if menu_choice == 1:
        print("Telephone Numbers:")
        for x in numbers.keys():
            print("Name: ", x, "\tNumber:", numbers[x])
        print()
    elif menu_choice == 2:
        print("Add Name and Number")
        name = input("Name: ")
        phone = input("Number: ")
        numbers[name] = phone
    elif menu_choice == 3:
        print("Remove Name and Number")
        name = input("Name: ")
        if name in numbers:
            del numbers[name]
        else:
            print(name, "was not found")
    elif menu_choice == 4:
        print("Lookup Number")
        name = input("Name: ")
        if name in numbers:
            print("The number is", numbers[name])
        else:
            print(name, "was not found")
    elif menu_choice != 5:
        print_menu()

&lt;/source&gt;

And here is my output:

 1. Print Phone Numbers
 2. Add a Phone Number
 3. Remove a Phone Number
 4. Lookup a Phone Number
 5. Quit
 
 Type in a number (1-5): '''2'''
 Add Name and Number
 Name: '''Joe'''
 Number: '''545-4464'''
 Type in a number (1-5): '''2'''
 Add Name and Number
 Name: '''Jill'''
 Number: '''979-4654'''
 Type in a number (1-5): '''2'''
 Add Name and Number
 Name: '''Fred'''
 Number: '''132-9874'''
 Type in a number (1-5): '''1'''
 Telephone Numbers:
 Name: Jill     Number: 979-4654
 Name: Joe      Number: 545-4464
 Name: Fred     Number: 132-9874
 
 Type in a number (1-5): '''4'''
 Lookup Number
 Name: '''Joe'''
 The number is 545-4464
 Type in a number (1-5): '''3'''
 Remove Name and Number
 Name: '''Fred'''
 Type in a number (1-5): '''1'''
 Telephone Numbers:
 Name: Jill     Number: 979-4654
 Name: Joe      Number: 545-4464
 
 Type in a number (1-5): '''5'''

This program is similar to the name list earlier in the chapter on lists.  Here's how the program works.  First the function &lt;code&gt;print_menu&lt;/code&gt; is defined.  &lt;code&gt;print_menu&lt;/code&gt; just prints a menu that is later used twice in the program.  Next comes the funny looking line &lt;code&gt;numbers = {}&lt;/code&gt;.  All that this line does is to tell Python that &lt;code&gt;numbers&lt;/code&gt; is a dictionary.  The next few lines just make the menu work.  The lines
&lt;source lang="python"&gt;
for x in numbers.keys():
    print("Name:", x, "\tNumber:", numbers[x])
&lt;/source&gt;
go through the dictionary and print all the information.  The function &lt;code&gt; numbers.keys()&lt;/code&gt; returns a list that is then used by the &lt;code&gt;for&lt;/code&gt; loop.  The list returned by &lt;code&gt;keys()&lt;/code&gt; is not in any particular order so if you want it in alphabetic order it must be sorted.  Similar to lists the statement &lt;code&gt;numbers[x]&lt;/code&gt; is used to access a specific member of the dictionary.  Of course in this case &lt;code&gt;x&lt;/code&gt; is a string.  Next the line &lt;code&gt;numbers[name] = phone&lt;/code&gt; adds a name and phone number to the dictionary.  If &lt;code&gt;name&lt;/code&gt; had already been in the dictionary &lt;code&gt;phone&lt;/code&gt; would replace whatever was there before.  Next the lines
&lt;source lang="python"&gt;
if name in numbers:
    del numbers[name]
&lt;/source&gt;
see if a name is in the dictionary and remove it if it is.  The operator &lt;code&gt;name in numbers&lt;/code&gt; returns true if &lt;code&gt;name&lt;/code&gt; is in &lt;code&gt;numbers&lt;/code&gt; but otherwise returns false.  The line &lt;code&gt;del numbers[name]&lt;/code&gt; removes the key &lt;code&gt;name&lt;/code&gt; and the value associated with that key.  The lines
&lt;source lang="python"&gt;
if name in numbers:
    print("The number is", numbers[name])
&lt;/source&gt;
check to see if the dictionary has a certain key and if it does prints out the number associated with it.  Lastly if the menu choice is invalid it reprints the menu for your viewing pleasure.

&lt;!-- \label{firstgrades}--&gt;
A recap: Dictionaries have keys and values.  Keys can be strings or
numbers.  Keys point to values.  Values can be any type of variable
(including lists or even dictionaries (those dictionaries or lists of
course can contain dictionaries or lists themselves (scary right? :-)
))).  Here is an example of using a list in a dictionary:

&lt;source lang="python"&gt;
max_points = [25, 25, 50, 25, 100]
assignments = ['hw ch 1', 'hw ch 2', 'quiz   ', 'hw ch 3', 'test']
students = {'#Max': max_points}

def print_menu():
    print("1. Add student")
    print("2. Remove student")
    print("3. Print grades")
    print("4. Record grade")
    print("5. Print Menu")
    print("6. Exit")

def print_all_grades():
    print('\t', end=' ')
    for i in range(len(assignments)):
        print(assignments[i], '\t', end=' ')
    print()
    keys = list(students.keys())
    keys.sort()
    for x in keys:
        print(x, '\t', end=' ')
        grades = students[x]
        print_grades(grades)

def print_grades(grades):
    for i in range(len(grades)):
        print(grades[i], '\t', end=' ')
    print()

print_menu()
menu_choice = 0
while menu_choice != 6:
    print()
    menu_choice = int(input("Menu Choice (1-6): "))
    if menu_choice == 1:
        name = input("Student to add: ")
        students[name] = [0] * len(max_points)
    elif menu_choice == 2:
        name = input("Student to remove: ")
        if name in students:
            del students[name]
        else:
            print("Student:", name, "not found")
    elif menu_choice == 3:
        print_all_grades()
    elif menu_choice == 4:
        print("Record Grade")
        name = input("Student: ")
        if name in students:
            grades = students[name]
            print("Type in the number of the grade to record")
            print("Type a 0 (zero) to exit")
            for i in range(len(assignments)):
                print(i + 1, assignments[i], '\t', end=' ')
            print()
            print_grades(grades)
            which = 1234
            while which != -1:
                which = int(input("Change which Grade: "))
                which -= 1    #same as which = which - 1
                if 0 &lt;= which &lt; len(grades):
                    grade = int(input("Grade: "))
                    grades[which] = grade
                elif which != -1:
                    print("Invalid Grade Number")
        else:
            print("Student not found")
    elif menu_choice != 6:
        print_menu()
&lt;/source&gt;

and here is a sample output:

 1. Add student
 2. Remove student
 3. Print grades
 4. Record grade
 5. Print Menu
 6. Exit
 
 Menu Choice (1-6): '''3'''
        hw ch 1         hw ch 2         quiz            hw ch 3         test 
 #Max    25              25              50              25              100 
 
 Menu Choice (1-6): '''5'''
 1. Add student
 2. Remove student
 3. Print grades
 4. Record grade
 5. Print Menu
 6. Exit
 
 Menu Choice (1-6): '''1'''
 Student to add: '''Bill'''
 
 Menu Choice (1-6): '''4'''
 Record Grade
 Student: '''Bill'''
 Type in the number of the grade to record
 Type a 0 (zero) to exit
 1   hw ch 1     2   hw ch 2     3   quiz        4   hw ch 3     5   test 
 0               0               0               0               0 
 Change which Grade: '''1'''
 Grade: '''25'''
 Change which Grade: '''2'''
 Grade: '''24'''
 Change which Grade: '''3'''
 Grade: '''45'''
 Change which Grade: '''4'''
 Grade: '''23'''
 Change which Grade: '''5'''
 Grade: '''95'''
 Change which Grade: '''0'''
 
 Menu Choice (1-6): '''3'''
        hw ch 1         hw ch 2         quiz            hw ch 3         test 
 #Max    25              25              50              25              100
 Bill    25              24              45              23              95 
 
 Menu Choice (1-6): '''6'''

Heres how the program works.  Basically the variable &lt;code&gt;students&lt;/code&gt; is a dictionary with the keys being the name of the students and the values being their grades.  The first two lines just create two lists.
The next line &lt;code&gt;students = {'#Max': max_points}&lt;/code&gt; creates a new
dictionary with the key {&lt;code&gt;#Max&lt;/code&gt;} and the value is set to be &lt;code&gt;[25, 25, 50, 25, 100]&lt;/code&gt; (since thats what &lt;code&gt;max_points&lt;/code&gt; was when the assignment is made) (I use the key &lt;code&gt;#Max&lt;/code&gt; since &lt;code&gt;#&lt;/code&gt; is sorted ahead of any alphabetic characters).  Next &lt;code&gt;print_menu&lt;/code&gt; is defined.  Next the &lt;code&gt;print_all_grades&lt;/code&gt; function is defined in the
lines:
&lt;source lang="python"&gt;
def print_all_grades():
    print('\t',end=" ")
    for i in range(len(assignments)):
        print(assignments[i], '\t',end=" ")
    print()
    keys = list(students.keys())
    keys.sort()
    for x in keys:
        print(x, '\t',end=' ')
        grades = students[x]
        print_grades(grades)
&lt;/source&gt;

Notice how first the keys are gotten out of the &lt;code&gt;students&lt;/code&gt; dictionary with the &lt;code&gt;keys&lt;/code&gt; function in the line &lt;code&gt;keys = list(students.keys())&lt;/code&gt;.  &lt;code&gt;keys&lt;/code&gt; is an iterable, and it is converted to list so all the functions for lists can be used on it.  Next the keys are sorted in the line &lt;code&gt;keys.sort()&lt;/code&gt;.  &lt;code&gt;for&lt;/code&gt; is used to go through all the keys. The grades are stored as a list inside the dictionary so the assignment &lt;code&gt;grades = students[x]&lt;/code&gt; gives &lt;code&gt;grades&lt;/code&gt; the list that is stored at the key &lt;code&gt;x&lt;/code&gt;.  The function &lt;code&gt;print_grades&lt;/code&gt; just prints a list and is defined a few lines later.

The later lines of the program implement the various options of the menu.  The line &lt;code&gt;students[name] = [0] * len(max_points)&lt;/code&gt; adds a student to the key of their name.  The notation &lt;code&gt;[0] * len(max_points)&lt;/code&gt; just creates a list of 0's that is the same length as the &lt;code&gt;max_points&lt;/code&gt; list.  

The remove student entry just deletes a student similar to the telephone book example.  The record grades choice is a little more complex.  The grades are retrieved in the line &lt;code&gt;grades = students[name]&lt;/code&gt; gets a reference to the grades of the student &lt;code&gt;name&lt;/code&gt;.  A grade is then recorded in the line &lt;code&gt;grades[which] = grade&lt;/code&gt;.  You may notice that &lt;code&gt;grades&lt;/code&gt; is never put back into the students dictionary (as in no &lt;code&gt;students[name] = grades&lt;/code&gt;).  The reason for the missing statement is that &lt;code&gt;grades&lt;/code&gt; is actually another name for &lt;code&gt;students[name]&lt;/code&gt; and so changing &lt;code&gt;grades&lt;/code&gt; changes &lt;code&gt;student[name]&lt;/code&gt;.  

Dictionaries provide an easy way to link keys to values.  This can be used to easily keep track of data that is attached to various keys.

{{navigation |previous=Boolean Expressions |next=Using Modules}}
{{BookCat}}</text>
      <sha1>qvu4ml85nerzhq7zavyooikafnz3879</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/FAQ</title>
    <ns>0</ns>
    <id>190105</id>
    <revision>
      <id>3476347</id>
      <parentid>3037606</parentid>
      <timestamp>2018-10-12T03:16:30Z</timestamp>
      <contributor>
        <username>Jrincayc</username>
        <id>87</id>
      </contributor>
      <comment>Where the webpage moved to.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1836" xml:space="preserve">; How do I make a GUI in Python? : You can use one of these library: [https://docs.python.org/3.5/library/tkinter.html TKinter], [https://riverbankcomputing.com/software/pyqt/intro PyQt], [https://wiki.gnome.org/Projects/PyGObject PyGobject]. For really simple graphics, you can use the turtle graphics mode &lt;code&gt;import turtle&lt;/code&gt;
; How do I make a game in Python? : The best method is probably to use PyGame at http://pygame.org/
; How do I make an executable from a Python program? : Short answer: Python is an interepreted language so that is impossible. Long answer is that something similar to an executable can be created by taking the Python interpreter and the file and joining them together and distributing that.  For more on that problem see http://www.python.org/doc/faq/programming/#how-can-i-create-a-stand-alone-binary-from-a-python-script
; (IFAQ) Why do you use first person in this tutorial? : Once upon a time in a different millenia, (1999 to be exact), an earlier version was written entirely by Josh Cogliati, and it was up on his webpage http://www.honors.montana.edu/~jjc/easytut and it was good.  Then the server rupert, like all good things than have a beginning came to an end, and Josh moved it to Wikibooks, but the first person writing stuck.  If someone really wants to change it, I will not revert it, but I don't see much point.   (The webpage has since moved to http://jjc.freeshell.org/easytut/ and http://jjc.freeshell.org/easytut3/ )
; My question is not answered. : Ask on the discussion page or add it to this FAQ, or email one of the [[../Authors|Authors]].  

For other FAQs, you may want to see the Python 2.6 version of this page [[Non-Programmer's Tutorial for Python 2.6/FAQ]], or the [https://docs.python.org/3.5/faq/ Python FAQ].

{{navigation |previous=The End |next=END}}
{{BookCat}}</text>
      <sha1>36bgkeo3fksxyacguh02u6i5ptlh0m0</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/File IO</title>
    <ns>0</ns>
    <id>190100</id>
    <revision>
      <id>3294791</id>
      <parentid>3294789</parentid>
      <timestamp>2017-09-16T19:47:21Z</timestamp>
      <contributor>
        <username>Dai.book</username>
        <id>3100501</id>
      </contributor>
      <comment>Undid revision 3294789 by [[Special:Contributions/Dai.book|Dai.book]] ([[User talk:Dai.book|discuss]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="12349" xml:space="preserve">=== File I/O ===

Here is a simple example of file I/O (input/output):
&lt;source lang="python"&gt;
# Write a file
with open("test.txt", "wt") as out_file:
    out_file.write("This Text is going to out file\nLook at it and see!")

# Read a file
with open("test.txt", "rt") as in_file:
    text = in_file.read()

print(text)
&lt;/source&gt;

The output and the contents of the file &lt;code&gt;test.txt&lt;/code&gt; are:

 This Text is going to out file
 Look at it and see!

Notice that it wrote a file called &lt;code&gt;test.txt&lt;/code&gt; in the directory that you ran the program from.  The &lt;code&gt;\n&lt;/code&gt; in the string tells Python to put a ''n''ewline where it is.  

An overview of file I/O is:
* Get a file object with the &lt;code&gt;open&lt;/code&gt; function
* Read or write to the file object (depending on how it was opened)
* If you did not use &lt;code&gt;with&lt;/code&gt; to open the file, you'd have to close it manually

The first step is to get a file object.  The way to do this is to use the &lt;code&gt;open&lt;/code&gt; function.  The format is &lt;code&gt;file_object = open(filename, mode)&lt;/code&gt;  where &lt;code&gt;file_object&lt;/code&gt; is the variable to put the file object, &lt;code&gt;filename&lt;/code&gt; is a string with the filename, and &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;"rt"&lt;/code&gt; to ''r''ead a file as ''t''ext or &lt;code&gt;"wt"&lt;/code&gt; to ''w''rite a file as ''t''ext (and a few others we will skip here).  Next the file objects functions can be called.  The two most common functions are &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;.  The &lt;code&gt;write&lt;/code&gt; function adds a string to the end of the file.  The &lt;code&gt;read&lt;/code&gt; function reads the next thing in the file and returns it as a string.  If no argument is given it will return the whole file (as done in the example).  

Now here is a new version of the phone numbers program that we made earlier:

&lt;source lang="python"&gt;
def print_numbers(numbers):
    print("Telephone Numbers:")
    for k, v in numbers.items():
        print("Name:", k, "\tNumber:", v)
    print()

def add_number(numbers, name, number):
    numbers[name] = number

def lookup_number(numbers, name):
    if name in numbers:
        return "The number is " + numbers[name]
    else:
        return name + " was not found"

def remove_number(numbers, name):
    if name in numbers:
        del numbers[name]
    else:
        print(name," was not found")

def load_numbers(numbers, filename):
    in_file = open(filename, "rt")
    while True:
        in_line = in_file.readline()
        if not in_line:
            break
        in_line = in_line[:-1]
        name, number = in_line.split(",")
        numbers[name] = number
    in_file.close()

def save_numbers(numbers, filename):
    out_file = open(filename, "wt")
    for k, v in numbers.items():
        out_file.write(k + "," + v + "\n")
    out_file.close()

def print_menu():
    print('1. Print Phone Numbers')
    print('2. Add a Phone Number')
    print('3. Remove a Phone Number')
    print('4. Lookup a Phone Number')
    print('5. Load numbers')
    print('6. Save numbers')
    print('7. Quit')
    print()

phone_list = {}
menu_choice = 0
print_menu()
while True:
    menu_choice = int(input("Type in a number (1-7): "))
    if menu_choice == 1:
        print_numbers(phone_list)
    elif menu_choice == 2:
        print("Add Name and Number")
        name = input("Name: ")
        phone = input("Number: ")
        add_number(phone_list, name, phone)
    elif menu_choice == 3:
        print("Remove Name and Number")
        name = input("Name: ")
        remove_number(phone_list, name)
    elif menu_choice == 4:
        print("Lookup Number")
        name = input("Name: ")
        print(lookup_number(phone_list, name))
    elif menu_choice == 5:
        filename = input("Filename to load: ")
        load_numbers(phone_list, filename)
    elif menu_choice == 6:
        filename = input("Filename to save: ")
        save_numbers(phone_list, filename)
    elif menu_choice == 7:
        break
    else:
        print_menu()

print("Goodbye")  
&lt;/source&gt;

Notice that it now includes saving and loading files.  Here is some output of my running it twice:

 1. Print Phone Numbers
 2. Add a Phone Number
 3. Remove a Phone Number
 4. Lookup a Phone Number
 5. Load numbers
 6. Save numbers
 7. Quit
 
 Type in a number (1-7): '''2'''
 Add Name and Number
 Name: '''Jill'''
 Number: '''1234'''
 Type in a number (1-7): '''2'''
 Add Name and Number
 Name: '''Fred'''
 Number: '''4321'''
 Type in a number (1-7): '''1'''
 Telephone Numbers:
 Name: Jill     Number: 1234
 Name: Fred     Number: 4321
 
 Type in a number (1-7): '''6'''
 Filename to save: '''numbers.txt'''
 Type in a number (1-7): '''7'''
 Goodbye

 1. Print Phone Numbers
 2. Add a Phone Number
 3. Remove a Phone Number
 4. Lookup a Phone Number
 5. Load numbers
 6. Save numbers
 7. Quit
 
 Type in a number (1-7): '''5'''
 Filename to load: '''numbers.txt'''
 Type in a number (1-7): '''1'''
 Telephone Numbers:
 Name: Jill     Number: 1234
 Name: Fred     Number: 4321
 
 Type in a number (1-7): '''7'''
 Goodbye

The new portions of this program are:
&lt;source lang="python"&gt;
def load_numbers(numbers, filename):
    in_file = open(filename, "rt")
    while True:
        in_line = in_file.readline()
        if not in_line:
            break
        in_line = in_line[:-1]
        name, number = in_line.split(",")
        numbers[name] = number
    in_file.close()

def save_numbers(numbers, filename):
    out_file = open(filename, "wt")
    for k, v in numbers.items():
        out_file.write(k + "," + v + "\n")
    out_file.close()
&lt;/source&gt;

First we will look at the save portion of the program.  First it creates a file object with the command &lt;code&gt;open(filename, "wt")&lt;/code&gt;.  Next it goes through and creates a line for each of the phone numbers with the command &lt;code&gt;out_file.write(k + "," + v + "\n")&lt;/code&gt;.  This writes out a line that contains the name, a comma, the number and follows it by a newline.

The loading portion is a little more complicated.  It starts by getting a file object.  Then it uses a &lt;code&gt;while True:&lt;/code&gt; loop to keep looping until a &lt;code&gt;break&lt;/code&gt; statement is encountered.  Next it gets a line with the line &lt;code&gt;in_line = in_file.readline()&lt;/code&gt;.  The &lt;code&gt;readline&lt;/code&gt; function will return an empty string when the end of the file is reached. The &lt;code&gt;if&lt;/code&gt; statement checks for this and &lt;code&gt;break&lt;/code&gt;s out of the &lt;code&gt;while&lt;/code&gt; loop when that happens.  Of course if the &lt;code&gt;readline&lt;/code&gt; function did not return the newline at the end of the line there would be no way to tell if an empty string was an empty line or the end of the file so the newline is left in what &lt;code&gt;readline&lt;/code&gt; returns.  Hence we have to get rid of the newline.  The line &lt;code&gt;in_line = in_line[:-1]&lt;/code&gt; does this for us by dropping the last character.  Next the line &lt;code&gt;name, number = in_line.split(",")&lt;/code&gt; splits the line at the comma into a name and a number.  This is then added to the &lt;code&gt;numbers&lt;/code&gt; dictionary.

=== Advanced use of .txt files ===

You might be saying to yourself, "Well I know how to read and write to a textfile, but what if I want to print the file without opening out another program?"

There are a few different ways to accomplish this. The easiest way does open another program, but everything is taken care of in the Python code, and doesn't require the user to specify a file to be printed. This method involves invoking the subprocess of another program. 

Remember the file we wrote output to in the above program? Let's use that file. 
Keep in mind, in order to prevent some errors, this program uses concepts from the Next chapter. Please feel free to revisit this example after the next chapter.

&lt;source lang="Python"&gt;
import subprocess
def main():
    try:
        print("This small program invokes the print function in the Notepad application")
        #Lets print the file we created in the program above
        subprocess.call(['notepad','/p','numbers.txt'])
    except WindowsError:
        print("The called subprocess does not exist, or cannot be called.")

main()
&lt;/source&gt;

The &lt;code&gt;subprocess.call&lt;/code&gt; takes three arguments. The first argument in the context of this example, should be the name of the program which you would like to invoke the printing subprocess from. The second argument should be the specific subprocess within that program. For simplicity, just understand that in this program, &lt;code&gt;'/p'&lt;/code&gt; is the subprocess used to access your printer through the specified application. The last argument should be the name of the file you want to send to the printing subprocess. In this case, it is the same file used earlier in this chapter.

=== Exercises ===
Now modify the grades program from section [[../Dictionaries|Dictionaries]] so that is uses file I/O to keep a record of the students.

{{Solution|title=Solution|text=
Now modify the grades program from section [[../Dictionaries|Dictionaries]] so that is uses file I/O to keep a record of the students.

&lt;source lang="python"&gt;
assignments = ['hw ch 1', 'hw ch 2', 'quiz   ', 'hw ch 3', 'test']
students = { }

def load_grades(gradesfile):
    inputfile = open(gradesfile, "r")
    grades = [ ]
    while True:
        student_and_grade = inputfile.readline()
        student_and_grade = student_and_grade[:-1]
        if not student_and_grade:
            break
        else:
            studentname, studentgrades = student_and_grade.split(",")
            studentgrades = studentgrades.split(" ")
            students[studentname] = studentgrades
    inputfile.close()
    print("Grades loaded.")

def save_grades(gradesfile):
    outputfile = open(gradesfile, "w")
    for k, v in students.items():
        outputfile.write(k + ",")
        for x in v:
            outputfile.write(str(x) + " ")
        outputfile.write("\n")
    outputfile.close()
    print("Grades saved.")

def print_menu():
    print("1. Add student")
    print("2. Remove student")
    print("3. Load grades")
    print("4. Record grade")
    print("5. Print grades")
    print("6. Save grades")
    print("7. Print Menu")
    print("9. Quit")

def print_all_grades():
    if students:
        keys = sorted(students.keys())
        print('\t', end=' ')
        for x in assignments:
            print(x, '\t', end=' ')
        print()
        for x in keys:
            print(x, '\t', end=' ')
            grades = students[x]
            print_grades(grades)
    else:
        print("There are no grades to print.")

def print_grades(grades):
    for x in grades:
        print(x, '\t', end=' ')
    print()

print_menu()
menu_choice = 0
while menu_choice != 9:
    print()
    menu_choice = int(input("Menu Choice: "))
    if menu_choice == 1:
        name = input("Student to add: ")
        students[name] = [0] * len(assignments)
    elif menu_choice == 2:
        name = input("Student to remove: ")
        if name in students:
            del students[name]
        else:
            print("Student:", name, "not found")
    elif menu_choice == 3:
        gradesfile = input("Load grades from which file? ")
        load_grades(gradesfile)
    elif menu_choice == 4:
        print("Record Grade")
        name = input("Student: ")
        if name in students:
            grades = students[name]
            print("Type in the number of the grade to record")
            print("Type a 0 (zero) to exit")
            for i,x in enumerate(assignments):
                print(i + 1, x, '\t', end=' ')
            print()
            print_grades(grades)
            which = 1234
            while which != -1:
                which = int(input("Change which Grade: "))
                which -= 1
                if 0 &lt;= which &lt; len(grades):
                    grade = input("Grade: ") # Change from float(input()) to input() to avoid an error when saving
                    grades[which] = grade
                elif which != -1:
                    print("Invalid Grade Number")
        else:
            print("Student not found")
    elif menu_choice == 5:
        print_all_grades()
    elif menu_choice == 6:
        gradesfile = input("Save grades to which file? ")
        save_grades(gradesfile)
    elif menu_choice != 9:
        print_menu()

&lt;/source&gt;

}}

{{navigation |previous=Revenge of the Strings |next=Dealing with the imperfect}}
{{BookCat}}</text>
      <sha1>d4apjgnuv5bt4yiug93ux3vk2480aw8</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/For Loops</title>
    <ns>0</ns>
    <id>181619</id>
    <revision>
      <id>2959497</id>
      <parentid>2614430</parentid>
      <timestamp>2015-05-18T09:11:52Z</timestamp>
      <contributor>
        <ip>5.150.97.204</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6349" xml:space="preserve">And here is the new typing exercise for this chapter:
&lt;source lang="python"&gt;
onetoten = range(1, 11)
for count in onetoten:
    print(count)
&lt;/source&gt;

and the ever-present output:

 1
 2
 3
 4
 5
 6
 7
 8
 9
 10

The output looks awfully familiar but the program code looks different.  The first line uses the &lt;code&gt;range&lt;/code&gt; function.  The &lt;code&gt;range&lt;/code&gt; function uses two arguments like this &lt;code&gt;range(start, finish)&lt;/code&gt;.  &lt;code&gt;start&lt;/code&gt; is the first number that is produced.  &lt;code&gt;finish&lt;/code&gt; is one larger than the last number.  Note that this program could have been done in a shorter way:
&lt;source lang="python"&gt;
for count in range(1, 11):
    print(count)
&lt;/source&gt;

The range function returns an iterable.  This can be converted into a list with the &lt;code&gt;list&lt;/code&gt; function. which will then be the dominant number.  
Here are some examples to show what happens with the &lt;code&gt;range&lt;/code&gt; command:

 &gt;&gt;&gt; '''range(1, 10)'''
 range(1, 10)
 &gt;&gt;&gt; '''list(range(1, 10))'''
 [1, 2, 3, 4, 5, 6, 7, 8, 9]
 &gt;&gt;&gt; '''list(range(-32, -20))'''
 [-32, -31, -30, -29, -28, -27, -26, -25, -24, -23, -22, -21]
 &gt;&gt;&gt; '''list(range(5,21))'''
 [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
 &gt;&gt;&gt; '''list(range(5))'''
 [0, 1, 2, 3, 4]
 &gt;&gt;&gt; '''list(range(21, 5))'''
 []

The next line &lt;code&gt;for count in onetoten:&lt;/code&gt; uses the &lt;code&gt;for&lt;/code&gt; control structure.  A &lt;code&gt;for&lt;/code&gt; control structure looks like &lt;code&gt;for variable in list:&lt;/code&gt;.  &lt;code&gt;list&lt;/code&gt; is gone through starting with the first element of the list and going to the last.  As &lt;code&gt;for&lt;/code&gt; goes through each element in a list it puts each into &lt;code&gt;variable&lt;/code&gt;.  That allows &lt;code&gt;variable&lt;/code&gt; to be used in each successive time the &lt;code&gt;for&lt;/code&gt; loop is run through.  Here is another example (you don't have to type this) to demonstrate:
&lt;source lang="python"&gt;
demolist = ['life', 42, 'the universe', 6, 'and', 7, 'everything']
for item in demolist:
    print("The current item is:",item)
&lt;/source&gt;

The output is:

 The current item is: life
 The current item is: 42
 The current item is: the universe
 The current item is: 6
 The current item is: and
 The current item is: 7
 The current item is: everything

Notice how the &lt;code&gt;for&lt;/code&gt; loop goes through and sets item to each element in the list. So, what is &lt;code&gt;for&lt;/code&gt; good for?  The first use is to go through all the elements of a list and do something with each of them.  Here's a quick way to add up all the elements:

&lt;source lang="python"&gt;
list = [2, 4, 6, 8]
sum = 0
for num in list:
    sum = sum + num

print("The sum is:", sum)
&lt;/source&gt;

with the output simply being:

The sum is: 20

Or you could write a program to find out if there are any duplicates in a list like this program does:

&lt;source lang="python"&gt;
list = [4, 5, 7, 8, 9, 1, 0, 7, 10]
list.sort()
prev = None
for item in list:
    if prev == item:
        print("Duplicate of", prev, "found")
    prev = item
&lt;/source&gt;

and for good measure:

 Duplicate of 7 found

Okay, so how does it work?  Here is a special debugging version to help you understand (you don't need to type this in):

&lt;source lang="python"&gt;
l = [4, 5, 7, 8, 9, 1, 0, 7, 10]
print("l = [4, 5, 7, 8, 9, 1, 0, 7, 10]", "\t\tl:", l)
l.sort()
print("l.sort()", "\t\tl:", l)
prev = l[0]
print("prev = l[0]", "\t\tprev:", prev)
del l[0]
print("del l[0]", "\t\tl:", l)
for item in l:
    if prev == item:
        print("Duplicate of", prev, "found")
    print("if prev == item:", "\t\tprev:", prev, "\titem:", item)
    prev = item
    print("prev = item", "\t\tprev:", prev, "\titem:", item)
&lt;/source&gt;

with the output being:

 l = [4, 5, 7, 8, 9, 1, 0, 7, 10]        l: [4, 5, 7, 8, 9, 1, 0, 7, 10]
 l.sort()                l: [0, 1, 4, 5, 7, 7, 8, 9, 10]
 prev = l[0]             prev: 0
 del l[0]                l: [1, 4, 5, 7, 7, 8, 9, 10]
 if prev == item:        prev: 0         item: 1
 prev = item             prev: 1         item: 1
 if prev == item:        prev: 1         item: 4
 prev = item             prev: 4         item: 4
 if prev == item:        prev: 4         item: 5
 prev = item             prev: 5         item: 5
 if prev == item:        prev: 5         item: 7
 prev = item             prev: 7         item: 7
 Duplicate of 7 found
 if prev == item:        prev: 7         item: 7
 prev = item             prev: 7         item: 7
 if prev == item:        prev: 7         item: 8
 prev = item             prev: 8         item: 8
 if prev == item:        prev: 8         item: 9
 prev = item             prev: 9         item: 9
 if prev == item:        prev: 9         item: 10
 prev = item             prev: 10        item: 10

The reason I put so many &lt;code&gt;print&lt;/code&gt; statements in the code was so that you can see what is happening in each line.  (By the way, if you can't figure out why a program is not working, try putting in lots of print statements in places where you want to know what is happening.)  First the program starts with a boring old list.  Next the program sorts the list.  This is so that any duplicates get put next to each other.  The program then initializes a &lt;code&gt;prev&lt;/code&gt;(ious) variable.  Next the first element of the list is deleted so that the first item is not incorrectly thought to be a duplicate.  Next a &lt;code&gt;for&lt;/code&gt; loop is gone into.  Each item of the list is checked to see if it is the same as the previous.  If it is a duplicate was found.  The value of &lt;code&gt;prev&lt;/code&gt; is then changed so that the next time the &lt;code&gt;for&lt;/code&gt; loop is run through &lt;code&gt;prev&lt;/code&gt; is the previous item to the current.  Sure enough, the 7 is found to be a duplicate.  (Notice how &lt;code&gt;\t&lt;/code&gt; is used to print a tab.)  

The other way to use &lt;code&gt;for&lt;/code&gt; loops is to do something a certain number of times.  Here is some code to print out the first 9 numbers of the Fibonacci series:
&lt;source lang="python"&gt;
a = 1
b = 1
for c in range(1, 10):
    print(a, end=" ")
    n = a + b
    a = b
    b = n
&lt;/source&gt;

with the surprising output:

 1 1 2 3 5 8 13 21 34

Everything that can be done with &lt;code&gt;for&lt;/code&gt; loops can also be done with &lt;code&gt;while&lt;/code&gt; loops but &lt;code&gt;for&lt;/code&gt; loops give an easy way to go through all the elements in a list or to do something a certain number of times.

{{navigation |previous=Lists |next=Boolean Expressions}}
{{BookCat}}</text>
      <sha1>21cgnh6215w7xoktt49o9jlw5mkcbuh</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Front matter</title>
    <ns>0</ns>
    <id>179699</id>
    <revision>
      <id>3037607</id>
      <parentid>2973264</parentid>
      <timestamp>2016-01-14T06:17:00Z</timestamp>
      <contributor>
        <username>Baijum81</username>
        <id>2184</id>
      </contributor>
      <comment>update links</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2157" xml:space="preserve">All example Python source code in this tutorial is granted to the public domain.  Therefore you may modify it and relicense it under any license you please. Since you are expected to learn programming, the Creative Commons Attribution-ShareAlike license would require you to keep all programs that are derived from the source code in this tutorial under that license. Since the Python source code is granted to the public domain, that requirement is waived.

This tutorial is more or less a conversion of [[Non-Programmer's Tutorial for Python 2.6]].  Older versions and some versions in Korean, Spanish, Italian and Greek are available from [http://jjc.freeshell.org/easytut/ http://jjc.freeshell.org/easytut/]

The ''Non-Programmers' Tutorial For Python 3'' is a tutorial designed to be an introduction to the Python programming language.  This guide is for someone with no programming experience.

If you have programmed in other languages I recommend using [https://docs.python.org/3/tutorial/index.html Python Tutorial for Programmers] written by Guido van Rossum.  

If you have any questions or comments please use the discussion pages or see [[Non-Programmer's Tutorial for Python 3/Authors|Authors]] page for author contact information.  I welcome questions and comments about this tutorial.  I will try to answer any questions you have as best I can.  

Thanks go to James A. Brown for writing most of the Windows install info.  Thanks also to Elizabeth Cogliati for complaining enough :) about the original tutorial (that is almost unusable for a non-programmer), for proofreading, and for many ideas and comments on it.  Thanks to Joe Oppegaard for writing almost all the exercises.  Thanks to everyone I have missed.

=== Other resources ===

* [http://www.python.org Python Home Page]
* [https://docs.python.org/3/ Python 3 Documentation]
* [http://www.swaroopch.com/notes/python A Byte of Python by Swaroop C H]
* [http://python3porting.com/ Porting to Python 3: An in-depth guide]

{{navigation |previous=Authors |next=Intro}}
{{BookCat}}

[[ca:Python 3 per a no programadors/Prefaci]]
[[id:Panduan Python 3 untuk Non-Pemrogram/Pendahuluan]]</text>
      <sha1>4qyc7l6jb8z7e9dufjwihhxmc0k6enz</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Hello, World</title>
    <ns>0</ns>
    <id>179730</id>
    <revision>
      <id>3553661</id>
      <parentid>3553611</parentid>
      <timestamp>2019-06-23T07:20:52Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/111.206.186.19|111.206.186.19]] ([[User talk:111.206.186.19|talk]]) to last version by Leaderboard</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="8876" xml:space="preserve">&lt;!-- Now for our first lesson, what is a computer program?  A computer program is a set of very detailed instructions that tell a computer what to do.   --&gt;
=== What you should know ===
Once you've read and mastered this chapter, you should know how to edit programs in a text editor or IDLE,  save them to the hard disk, and run them once they have been saved.

=== Printing ===

Programming tutorials since the beginning of time have started with a little program called "Hello, World!"&lt;ref&gt;[[Computer Programming/Hello world|Here]] is a great list of the famous "Hello, world!" program in many programming languages. Just so you know how simple Python can be...&lt;/ref&gt;  So here it is:

&lt;source lang="python"&gt;
print("Hello, World!")
&lt;/source&gt;

If you are using the command line to run programs then type it in with a text editor, save it as &lt;code&gt;hello.py&lt;/code&gt; and run it with &lt;code&gt;python3 hello.py&lt;/code&gt;

Otherwise go into IDLE, create a new window, and create the program as
in section [[Non-Programmer's Tutorial for Python 3/Intro#Creating_and_Running_Programs|Creating and Running Programs]].

When this program is run here's what it prints:

 Hello, World!

Now I'm not going to tell you this every time, but when I show you a
program I recommend that you type it in and run it.  I learn better
when I type it in and you probably do too.

Now here is a more complicated program:

&lt;source lang="python"&gt;
print("Jack and Jill went up a hill")
print("to fetch a pail of water;")
print("Jack fell down, and broke his crown,")
print("and Jill came tumbling after.")
&lt;/source&gt;

When you run this program it prints out:

 Jack and Jill went up a hill
 to fetch a pail of water;
 Jack fell down, and broke his crown,
 and Jill came tumbling after.

When the computer runs this program it first sees the line:

&lt;source lang="python"&gt;
print("Jack and Jill went up a hill")
&lt;/source&gt;

so the computer prints:

 Jack and Jill went up a hill

Then the computer goes down to the next line and sees:

&lt;source lang="python"&gt;
print("to fetch a pail of water;")
&lt;/source&gt;

So the computer prints to the screen:

 to fetch a pail of water;

The computer keeps looking at each line, follows the command and then goes on to the next line.  The computer keeps running commands until it reaches the end of the program.

==== Terminology ====
Now is probably a good time to give you a bit of an explanation of what is happening - and a little bit of programming terminology.

What we were doing above was using a ''function'' called &lt;code&gt;print&lt;/code&gt;.  The function's name - &lt;code&gt;print&lt;/code&gt; - is followed by parentheses containing zero or more ''arguments''.  So in this example

&lt;source lang="python"&gt;
print("Hello, World!")
&lt;/source&gt;

there is one ''argument'', which is &lt;code&gt;"Hello, World!"&lt;/code&gt;.  Note that this argument is a group of characters enclosed in double quotes ("").  This is commonly referred to as a ''string of characters'', or ''string'', for short.  Another example of a string is &lt;code&gt;"Jack and Jill went up a hill"&lt;/code&gt;.  The combination of a function and parentheses with the arguments is a ''function call''.

A function and its arguments are one type of ''statement'' that python has, so

&lt;source lang="python"&gt;
print("Hello, World!")
&lt;/source&gt;

is an example of a statement.  Basically, you can think of a statement as a single line in a program.  

That's probably more than enough terminology for now.

=== Expressions ===
Here is another program:

&lt;source lang="python"&gt;
print("2 + 2 is", 2 + 2)
print("3 * 4 is", 3 * 4)
print("100 - 1 is", 100 - 1)
print("(33 + 2) / 5 + 11.5 is", (33 + 2) / 5 + 11.5)
&lt;/source&gt;

And here is the ''output'' when the program is run:

 2 + 2 is 4
 3 * 4 is 12
 100 - 1 is 99
 (33 + 2) / 5 + 11.5 is 18.5

As you can see, Python can turn your thousand-dollar computer into a five-dollar calculator.

==== Arithmetic expressions ====

In this example, the print function is followed by two arguments, with each of the arguments separated by a comma.  So with the first line of the program

&lt;source lang="python"&gt;
print("2 + 2 is", 2 + 2)
&lt;/source&gt;

The first argument is the string &lt;code&gt;"2 + 2 is"&lt;/code&gt; and the second argument is the ''arithmetic expression'' &lt;code&gt;2 + 2&lt;/code&gt;, which is one kind of ''expression''.

What is important to note is that a string is printed as is (without the enclosing double quotes), but an ''expression'' is ''evaluated'', or converted to its actual value.

Python has seven basic operations for numbers: 

{| class="wikitable"
! Operation 
! Symbol 
! Example
|-
|Power (exponentiation)
| &lt;code&gt;**&lt;/code&gt; 
| &lt;code&gt;5 ** 2 == 25&lt;/code&gt;
|-
|Multiplication 
| &lt;code&gt;*&lt;/code&gt; 
|&lt;code&gt;2 * 3 == 6&lt;/code&gt;
|-
|Division 
| &lt;code&gt;/&lt;/code&gt; 
| &lt;code&gt;14 / 3 == 4.666666666666667&lt;/code&gt; 
|-
|Integer Division
| &lt;code&gt;//&lt;/code&gt;
| &lt;code&gt;14 // 3 == 4&lt;/code&gt;
|-
|Remainder (modulo)
| &lt;code&gt;%&lt;/code&gt; 
| &lt;code&gt;14 % 3 == 2&lt;/code&gt; 
|-
|Addition 
| &lt;code&gt;+&lt;/code&gt; 
| &lt;code&gt;1 + 2 == 3&lt;/code&gt; 
|-
|Subtraction 
| &lt;code&gt;-&lt;/code&gt; 
| &lt;code&gt;4 - 3 == 1&lt;/code&gt;
|}

Notice that there are two ways to do division, one that returns the repeating decimal, and the other that can get the remainder and the whole number.  
The order of operations is the same as in math:
* parentheses &lt;code&gt;()&lt;/code&gt;
* exponents &lt;code&gt;**&lt;/code&gt;
* multiplication &lt;code&gt;*&lt;/code&gt;, division &lt;code&gt;/&lt;/code&gt;, integer division &lt;code&gt;//&lt;/code&gt;, and remainder &lt;code&gt;%&lt;/code&gt; 
* addition &lt;code&gt;+&lt;/code&gt; and subtraction &lt;code&gt;-&lt;/code&gt;
So use parentheses to structure your formulas when needed.

=== Talking to humans (and other intelligent beings) ===

Often in programming you are doing something complicated and may not in the future remember what you did.  When this happens the program should probably be commented.  A ''comment'' is a note to you and other programmers explaining what is happening.  For example:

&lt;source lang="python"&gt;
# Not quite PI, but a credible simulation
print(22 / 7)
&lt;/source&gt;

Which outputs

 3.14285714286

Notice that the comment starts with a hash: &lt;code&gt;#&lt;/code&gt;. Comments are used to communicate with others who read the program and your future self to make clear what is complicated.

Note that any text can follow a comment, and that when the program is run, the text after the &lt;code&gt;#&lt;/code&gt; through to the end of that line is ignored. The &lt;code&gt;#&lt;/code&gt; does not have to be at the beginning of a new line:

&lt;source lang="python"&gt;
# Output PI on the screen
print(22 / 7) # Well, just a good approximation
&lt;/source&gt;

=== Examples ===
Each chapter (eventually) will contain examples of the programming features introduced in the chapter.  You should at least look over them and see if you understand them.  If you don't, you may want to type them in and see what happens.  Mess around with them, change them and see what happens.  

'''Denmark.py'''

&lt;source lang="python"&gt;
print("Something's rotten in the state of Denmark.")
print("                -- Shakespeare")
&lt;/source&gt;

Output:

 Something's rotten in the state of Denmark.
                 -- Shakespeare

'''School.py'''

&lt;source lang="python"&gt;
# This is not quite true outside of USA
# and is based on my dim memories of my younger years
print("Firstish Grade")
print("1 + 1 =", 1 + 1)
print("2 + 4 =", 2 + 4)
print("5 - 2 =", 5 - 2)
print()
print("Thirdish Grade")
print("243 - 23 =", 243 - 23)
print("12 * 4 =", 12 * 4)
print("12 / 3 =", 12 / 3)
print("13 / 3 =", 13 // 3, "R", 13 % 3)
print()
print("Junior High")
print("123.56 - 62.12 =", 123.56 - 62.12)
print("(4 + 3) * 2 =", (4 + 3) * 2)
print("4 + 3 * 2 =", 4 + 3 * 2)
print("3 ** 2 =", 3 ** 2)
&lt;/source&gt;

Output:

 Firstish Grade
 1 + 1 = 2
 2 + 4 = 6
 5 - 2 = 3
 
 Thirdish Grade
 243 - 23 = 220
 12 * 4 = 48
 12 / 3 = 4
 13 / 3 = 4 R 1
 
 Junior High
 123.56 - 62.12 = 61.44
 (4 + 3) * 2 = 14
 4 + 3 * 2 = 10
 3 ** 2 = 9

=== Exercises ===

# Write a program that prints your full name and your birthday as separate strings.
# Write a program that shows the use of all 7 [[#Arithmetic_expressions|arithmetic operations]].

{{Solution|title=Solution|text=

1. Write a program that prints your full name and your birthday as separate strings.
&lt;source lang="python"&gt;
print("Ada Lovelace", "born on", "November 27, 1852")
&lt;/source&gt;  

&lt;source lang="python"&gt;
print("Albert Einstein", "born on", "14 March 1879")
&lt;/source&gt;

&lt;source lang="python"&gt;
print(("John Smith"), ("born on"), ("14 March 1879"))
&lt;/source&gt;
}}

{{Solution|title=Solution|text=
2. Write a program that shows the use of all 7 [[#Arithmetic_expressions|arithmetic operations]].
&lt;source lang="python"&gt;
print("5**5 = ", 5**5)
print("6*7 = ", 6*7)
print("56/8 = ", 56/8)
print("14//6 = ", 14//6)
print("14%6 = ", 14%6)
print("5+6 = ", 5+6)
print("9-0 = ", 9-0)
&lt;/source&gt;
}}

----
==== Footnotes ====
&lt;references/&gt;

{{navigation |previous=Intro |next=Who Goes There?}}
{{BookCat}}

[[ca:Python 3 per a no programadors/Hola, món]]</text>
      <sha1>279qfb5c4oz26ia7inm48b3wh140vhd</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Intro</title>
    <ns>0</ns>
    <id>179701</id>
    <revision>
      <id>3589714</id>
      <parentid>3589705</parentid>
      <timestamp>2019-10-24T19:13:03Z</timestamp>
      <contributor>
        <username>ErwinJunge</username>
        <id>3255208</id>
      </contributor>
      <comment>A reference to Vim in a non-programmer, beginner level tutorial is out of place and confusing. We should let them stick to IDLE, they can pick up editor preferences later.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="15153" xml:space="preserve">=== First things first ===
So, you've never programmed before. As we go through this tutorial, I
will attempt to teach you how to program. There really is only one
way to learn to program. '''You''' must read ''code'' and write ''code'' (as computer programs are often called).
I'm going to show you lots of code. You should type in code that I
show you to see what happens. Play around with it and make changes.
The worst that can happen is that it won't work. When I type in code
it will be formatted like this:

&lt;source lang="python"&gt;
# Python is easy to learn
print("Hello, World!")
&lt;/source&gt;

That's so it is easy to distinguish from the other text. If you're reading this on the Web, you'll notice the code is in color -- that's just to make it stand out, and to make the different parts of the code stand out from each other. The code you enter will probably not be colored, or the colors may be different, but it won't affect the code as long as you enter it the same way as it's printed here.

If the computer prints something out it will be formatted like this:

 Hello, World!

(Note that printed text goes to your screen, and does not involve paper. Before computers had screens, the output of computer programs would be printed on paper.)

Note that this is a Python 3 tutorial, which means that most of the examples will not work in Python 2.7 and before. As well, all but a small number of the extra Python 2.7 libraries (third-party libraries) have been converted to Python 3. Most likely you will want to learn Python 3, but if you are learning Python for a specific package or set of modules that are only written in Python 2.7, you may want to consider learning from the [[Non-Programmer's Tutorial for Python 2.6]]. However, the differences between Python 2 and 3 are not particularly large, so if you learn one, you should be able to read programs written for the other without much difficulty. 

There will often be a mixture of the text you type (which is shown in '''bold''') and the text the program prints to the screen, which would look like this:

 Halt!
 Who Goes there? '''Josh'''
 You may pass, Josh

(Some of the tutorial has not been converted to this format. Since this is a wiki, you can convert it when you find it.)

I will also introduce you to the terminology of programming - for example, that programming is often referred to as ''coding'' or ''hacking''. This will not only help you understand what programmers are talking about, but also help the learning process.

Now, on to more important things. In order to program in Python you need the Python 3 software. If you don't already have the Python software go to [http://www.python.org/download/ www.python.org/download] and get the proper version for your platform. Download it, read the instructions and get it installed.

=== Installing Python ===
For Python programming you need a working Python installation and a text editor. Python comes with its own editor, ''IDLE'', which is quite nice and totally sufficient for the beginning. As you get more into programming, you will probably switch to some other editor like &lt;tt&gt;nano&lt;/tt&gt;, &lt;tt&gt;emacs&lt;/tt&gt;, &lt;tt&gt;vi&lt;/tt&gt; or another.

The Python download page is http://www.python.org/download. The most recent version is Python 3.7.3 (as of July 2019); '''Python 2.7 and older versions will not work with this tutorial.''' There are various different installation files for different computer platforms available on the download site. Here are some specific instructions for the most common operating systems:

==== Linux, BSD, and Unix users ====
You are probably lucky and Python is already installed on your machine. To test it type &lt;code&gt;python3&lt;/code&gt; on a command line. If you see something like what is shown [[#Interactive Mode|in the following section]], you are set.

IDLE may need to be installed separately, from its own package such as &lt;tt&gt;idle3&lt;/tt&gt; or as part of &lt;tt&gt;python-tools&lt;/tt&gt;. 

If you have to install Python, first try to use the operating system's package manager or go to the repository where your packages are available and get Python 3. Python 3.0 was released in December 2008; all distributions should have Python 3 available, so you may not need to compile it from scratch. Ubuntu and Fedora do have Python 3 binary packages available, but they are not yet the default, so they need to be installed specially.&lt;!-- Is this realistic for people who don't know how to program???  --&gt;

Roughly, here are the steps to compile Python from source code in Unix (If these totally don't make sense, you may want to read another introduction to *nix, such as [http://tldp.org/LDP/intro-linux/html/index.html Introduction to Linux]):
* Download the .tgz file (use your Web browser to get the gzipped tar file from https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tgz)
* Uncompress the tar file (put in the correct path to where you downloaded it):
 $ tar -xvzf ~/Download/Python-3.7.4.tgz
 ''... list of files as they are uncompressed ''
* Change to the directory and tell the computer to compile and install the program
 $ cd Python-3.7/
 $ ./configure --prefix=$HOME/python3_install
 '' ... lots of output.  Watch for error messages here ... ''
 $ make
 '' ... even more output.  Hopefully no error messages ... ''
 $ make install
* Add Python 3 to your path. You can test it first by specifying the full path. You should add $HOME/python3_install/bin to your PATH bash variable.
 $ ~/python3_install/bin/python3
 Python 3.7.4 (... size and date information ...)
 [GCC 9.1.0] on linux
 Type "help", "copyright", "credits" or "license" for more information.
 &gt;&gt;&gt;''

The above commands will install Python 3 to your home directory, which is probably what you want, but if you skip the &lt;tt&gt;--prefix=$HOME/python3_install&lt;/tt&gt;, it will install it to &lt;tt&gt;/usr/local&lt;/tt&gt;. If you want to use the IDLE graphical code editor, you need to make sure that the &lt;tt&gt;tk&lt;/tt&gt; and &lt;tt&gt;tcl&lt;/tt&gt; libraries, together with their development files, are installed on the system.  You will get a warning during the &lt;tt&gt;make&lt;/tt&gt; phase if these are not available.

==== Mac users ====
Starting from Mac OS X Tiger (10.4), versions of Python 2 shipped with the operating system by default, but you will need to also install Python 3 unless Mac OS starts including Python 3 (check the version by starting &lt;code&gt;python3&lt;/code&gt; in a command line terminal). Also IDLE (the Python editor) might be missing in the standard installation. If you want to (re-)install Python, get the Mac OS installer from the [https://www.python.org/downloads/release/python-380/ Python download site].

==== Windows users ====
Download the appropriate Windows installer (the [https://www.python.org/ftp/python/3.4.3/python-3.4.3.msi x86 MSI installer], if you do not have a 64-bit AMD or Intel chip).  Start the installer by double-clicking it and follow the prompts.

See https://docs.python.org/3/using/windows.html#installing-python for more information.

===== Configuring your PATH environment variable =====

The PATH environment variable is a list of folders, separated by semicolons, in which Windows will look for a program whenever you try to execute one by typing its name at a Command Prompt. You can see the current value of your PATH by typing this command at a Command Prompt:

 echo %PATH%

The easiest way to permanently change environment variables is to bring up the built-in environment variable editor in Windows.  How you get to this editor is slightly different on different versions of Windows.

'''On Windows 8''' or '''Windows 10''': Press the Windows key and type ''Control Panel'' to locate the Windows Control Panel.  Once you've opened the Control Panel, select View by: Large Icons, then click on ''System''.  In the window that pops up, click the ''Advanced System Settings'' link, then click the ''Environment Variables...'' button.

'''On Windows 7''' or '''Vista''': Click the Start button in the lower-left corner of the screen, move your mouse over ''Computer'', right-click, and select ''Properties'' from the pop-up menu. Click the ''Advanced System Settings'' link, then click the ''Environment Variables...'' button.

Once you've brought up the environment variable editor, you'll do the same thing regardless of which version of Windows you're running. Under ''System Variables'' in the bottom half of the editor, find a variable called &lt;tt&gt;PATH&lt;/tt&gt;. If there is is one, select it and click ''Edit...''. Assuming your Python root is &lt;tt&gt;C:\Python34&lt;/tt&gt;, add these two folders to your path (and make sure you get the semicolons right; there should be a semicolon between each folder in the list):

 C:\Python37
 C:\Python37\Scripts

Note:
If you want to double-click and start your Python programs from a Windows folder and not have the console window disappear, you can add the following code to the bottom of each script:

&lt;source lang="python"&gt;
#stops console from exiting
end_prog = ""
while end_prog != "q":
        end_prog = input("type q to quit")
&lt;/source&gt;

=== Interactive Mode ===
Go into IDLE (also called the Python GUI). You should see a window that has some text like this:
&lt;pre&gt;
Python 3.0 (r30:67503, Dec 29 2008, 21:31:07) 
[GCC 4.3.2 20081105 (Red Hat 4.3.2-7)] on linux2
Type "copyright", "credits" or "license()" for more information.

    ****************************************************************
    Personal firewall software may warn about the connection IDLE
    makes to its subprocess using this computer's internal loopback
    interface.  This connection is not visible on any external
    interface and no data is sent to or received from the Internet.
    ****************************************************************
    
IDLE 3.0      
&gt;&gt;&gt; 
&lt;/pre&gt;
The &lt;code&gt;&gt;&gt;&gt;&lt;/code&gt; is Python's way of telling you that you are in
interactive mode. In interactive mode what you type is immediately
run. Try typing &lt;code&gt;1+1&lt;/code&gt; in. Python will respond with &lt;code&gt;2&lt;/code&gt;.
Interactive mode allows you to test out and see what Python will do.
If you ever feel you need to play with new Python statements, go into
interactive mode and try them out.

=== Creating and Running Programs ===

Go into IDLE if you are not already. In the menu at the top, select ''File'' then ''New File''. In the new window that appears, type the following:

&lt;source lang="python"&gt;
print("Hello, World!")
&lt;/source&gt;

Now save the program: select ''File'' from the menu, then ''Save''. Save it as "&lt;code&gt;hello.py&lt;/code&gt;" (you can save it in any folder you want). Now that it is saved it can be run. 

Next run the program by going to ''Run'' then ''Run Module'' (or if you have an older version of IDLE use ''Edit'' then ''Run script''). This will output &lt;code&gt;Hello, World!&lt;/code&gt; on the ''*Python Shell*'' window. 

For a more in-depth introduction to IDLE, a longer tutorial with screenshots can be found at http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html.

==== Program file names ====
It is very useful to stick to some rules regarding the file names of Python programs. Otherwise some things ''might'' go wrong unexpectedly. These don't matter as much for programs, but you can have weird problems if you don't follow them for module names (modules will be discussed later).
# Always save the program with the extension &lt;tt&gt;.py&lt;/tt&gt;. Do not put another dot anywhere else in the file name.
# Only use standard characters for file names: letters, numbers, dash (&lt;tt&gt;-&lt;/tt&gt;) and underscore (&lt;tt&gt;_&lt;/tt&gt;).
# White space ("&lt;tt&gt; &lt;/tt&gt;") should not be used at all (use underscores instead).
# Do not use anything other than a letter (particularly no numbers!) at the beginning of a file name.
# Do not use "non-English" characters (such as &lt;tt&gt;å&lt;/tt&gt;, &lt;tt&gt;ɓ&lt;/tt&gt;, &lt;tt&gt;ç&lt;/tt&gt;, &lt;tt&gt;ð&lt;/tt&gt;, &lt;tt&gt;é&lt;/tt&gt;, &lt;tt&gt;õ&lt;/tt&gt;, &lt;tt&gt;ü&lt;/tt&gt;) in your file names—or, even better, do not use them at all when programming.
# Do not use module names for file names (such as &lt;tt&gt;print.py&lt;/tt&gt;, &lt;tt&gt;math.py&lt;/tt&gt;, &lt;tt&gt;list.py&lt;/tt&gt;)

=== Using Python from the command line ===
If you don't want to use Python from the command line, you don't have to, just use IDLE. To get into interactive mode just type &lt;code&gt;python3&lt;/code&gt; without any arguments. To run a program, create it with a text editor (Emacs has a good Python mode) and then run it with &lt;code&gt;python3 ''program_name''&lt;/code&gt;.

==== Running Python Programs in *nix ====

If you are using Unix (such as Linux, Mac OS, or BSD), if you make the program executable with [[w:chmod|chmod]], and have as the first line:
&lt;source lang="python"&gt;
#!/usr/bin/env python3
&lt;/source&gt;
you can run the python program with &lt;code&gt;./hello.py&lt;/code&gt; like any other command.

=== Where to get help ===
At some point in your Python career you will probably get stuck and have no clue about how to solve the problem you are supposed to work on. This tutorial only covers the basics of Python programming, but there is a lot of further information available.

==== Python documentation ====
First of all, Python is very well documented. There might even be copies of these documents on your computer that came with your Python installation:
* The official [http://docs.python.org/3/tutorial/ Python 3 Tutorial] by Guido van Rossum is often a good starting point for general questions.
* For questions about standard modules (you will learn what these are later), the [http://docs.python.org/3/library/ Python 3 Library Reference] is the place to look.
* If you really want to get to know something about the details of the language, the [http://docs.python.org/3/reference/ Python 3 Reference Manual] is comprehensive but quite complex for beginners.

==== Python user community ====
There are a lot of other Python users out there, and usually they are nice and willing to help you. This very active user community is organised mostly through mailing lists and a newsgroup:
* The [http://mail.python.org/mailman/listinfo/tutor tutor mailing list] is for folks who want to ask questions regarding how to learn computer programming with the Python language.
* The [http://www.python.org/community/lists/#python-help python-help mailing list] is python.org's help desk. You can ask a group of knowledgeable volunteers questions about all your Python problems.
* The Python newsgroup [news:comp.lang.python comp.lang.python] ([http://groups.google.com/group/comp.lang.python/ Google groups archive]) is the place for general Python discussions, questions and the central meeting point of the community.
* Python wiki has a [http://wiki.python.org/moin/LocalUserGroups list of local user groups], you can join the group mailing list and ask questions. You can also participate in the user group meetings.
* [https://www.reddit.com/r/learnpython LearnPython] subreddit is another location where beginner level questions can be asked.

In order not to reinvent the wheel and discuss the same questions again and again, people will appreciate very much if you ''do a web search for a solution to your problem before contacting these lists!''

{{navigation |previous=Front matter |next=Hello, World}}
{{BookCat}}

[[ca:Python 3 per a no programadors/Introducció]]</text>
      <sha1>q1wxrpqe9jwoqda9golw2ymu7ehaonz</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Lists</title>
    <ns>0</ns>
    <id>181462</id>
    <revision>
      <id>3580023</id>
      <parentid>3580022</parentid>
      <timestamp>2019-09-26T13:19:42Z</timestamp>
      <contributor>
        <username>Hasley</username>
        <id>3159157</id>
      </contributor>
      <minor/>
      <comment>Reverted 1 edit by [[Special:Contributions/159.146.18.244|159.146.18.244]] ([[User talk:159.146.18.244|talk]]) to last revision by 203.59.222.158. ([[WP:TW|TW]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="17166" xml:space="preserve">=== Variables with more than one value ===
You have already seen ordinary variables that store a single value.  However other variable types can hold more than one value.  These are called containers because they can contain more than one object.  The simplest type is called a list.  Here is an example of a list being used:
&lt;source lang="python"&gt;
which_one = int(input("What month (1-12)? "))
months = ['January', 'February', 'March', 'April', 'May', 'June', 'July',
          'August', 'September', 'October', 'November', 'December']

if 1 &lt;= which_one &lt;= 12:
    print("The month is", months[which_one - 1])
&lt;/source&gt;

and an output example:

 What month (1-12)? '''3'''
 The month is March

In this example the &lt;code&gt;months&lt;/code&gt; is a list.  &lt;code&gt;months&lt;/code&gt; is defined with the lines &lt;code&gt; months = ['January', 'February', 'March', 'April', 'May', 'June', 'July',&lt;/code&gt; and &lt;code&gt;'August', 'September', 'October', 'November', 'December']&lt;/code&gt; (note that a &lt;code&gt;\&lt;/code&gt; could also be used to split a long line, but that is not necessary in this case because Python is intelligent enough to recognize that everything within brackets belongs together).  The &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; start and end the list with commas (&lt;code&gt;,&lt;/code&gt;) separating the list items.  The list is used in &lt;code&gt;months[which_one - 1]&lt;/code&gt;.  A list consists of items that are numbered starting at 0.  In other words if you wanted January you would use &lt;code&gt;months[0]&lt;/code&gt;.  Give a list a number and it will return the value that is stored at that location.

The statement &lt;code&gt; if 1 &lt;= which_one &lt;= 12:&lt;/code&gt; will only be true if &lt;code&gt; which_one&lt;/code&gt; is between one and twelve inclusive (in other words it is what you would expect if you have seen that in algebra).

Lists can be thought of as a series of boxes. Each box has a different value. For example, the boxes created by  &lt;code&gt;demolist = ['life', 42, 'the universe', 6, 'and', 9]&lt;/code&gt; would look like this:

{| class="wikitable" 
!box number 
!0 
!1  
!2 
!3 
!4 
!5 
|-
|demolist 
|"life" 
|42 
|"the universe" 
|6 
|"and"
|9
|}

Each box is referenced by its number so the statement &lt;code&gt;demolist[0]&lt;/code&gt; would get &lt;code&gt;'life'&lt;/code&gt;, &lt;code&gt;demolist[1]&lt;/code&gt; would get &lt;code&gt;42&lt;/code&gt; and so on up to &lt;code&gt;demolist[5]&lt;/code&gt; getting &lt;code&gt;9&lt;/code&gt;.

=== More features of lists ===
The next example is just to show a lot of other stuff lists can do (for once I don't expect you to type it in, but you should probably play around with lists in interactive mode until you are comfortable with them.).  Here goes:
&lt;source lang="python"&gt;
demolist = ["life", 42, "the universe", 6, "and", 9]
print("demolist = ",demolist)
demolist.append("everything")
print("after 'everything' was appended demolist is now:")
print(demolist)
print("len(demolist) =", len(demolist))
print("demolist.index(42) =", demolist.index(42))
print("demolist[1] =", demolist[1])

# Next we will loop through the list
for c in range(len(demolist)):
    print("demolist[", c, "] =", demolist[c])

del demolist[2]
print("After 'the universe' was removed demolist is now:")
print(demolist)
if "life" in demolist:
    print("'life' was found in demolist")
else:
    print("'life' was not found in demolist")

if "amoeba" in demolist:
    print("'amoeba' was found in demolist")

if "amoeba" not in demolist:
    print("'amoeba' was not found in demolist")

another_list = [42,7,0,123]
another_list.sort()
print("The sorted another_list is", another_list)
&lt;/source&gt;

The output is:

 demolist =  ['life', 42, 'the universe', 6, 'and', 9]
 after 'everything' was appended demolist is now:
 ['life', 42, 'the universe', 6, 'and', 9, 'everything']
 len(demolist) = 7
 demolist.index(42) = 1
 demolist[1] = 42
 demolist[ 0 ] = life
 demolist[ 1 ] = 42
 demolist[ 2 ] = the universe
 demolist[ 3 ] = 6
 demolist[ 4 ] = and
 demolist[ 5 ] = 9
 demolist[ 6 ] = everything
 After 'the universe' was removed demolist is now:
 ['life', 42, 6, 'and', 9, 'everything']
 'life' was found in demolist
 'amoeba' was not found in demolist
 The sorted another_list is [0, 7, 42, 123]

This example uses a whole bunch of new functions.  Notice that you can
just &lt;code&gt;print&lt;/code&gt; a whole list.  Next the &lt;code&gt;append&lt;/code&gt; function is used
to add a new item to the end of the list.  &lt;code&gt;len&lt;/code&gt; returns how many
items are in a list.  The valid indexes (as in numbers that can be
used inside of the &lt;code&gt;[]&lt;/code&gt;) of a list range from 0 to &lt;code&gt;len - 1&lt;/code&gt;. The
&lt;code&gt;index&lt;/code&gt; function tells where the first location of an item is
located in a list.  Notice how &lt;code&gt;demolist.index(42)&lt;/code&gt; returns 1, and
when &lt;code&gt;demolist[1]&lt;/code&gt; is run it returns 42.  To get help on all the functions a list provides for you, type &lt;code&gt;help(list)&lt;/code&gt; in the interactive Python interpreter.

The line &lt;code&gt;# Next we will loop through the list&lt;/code&gt; is a just a reminder to the programmer (also called a ''comment'').  Python ignores everything that is written after a &lt;code&gt;#&lt;/code&gt; on the current line.  Next the lines:
&lt;source lang="python"&gt;
for c in range(len(demolist)):
    print('demolist[', c, '] =', demolist[c])
&lt;/source&gt;

create a variable &lt;code&gt;c&lt;/code&gt;, which starts at 0 and is incremented until it reaches the last index of the list.  Meanwhile the &lt;code&gt;print&lt;/code&gt; statement prints out each element of the list.

A much better way to do the above is:
&lt;source lang="python"&gt;
for c, x in enumerate(demolist):
    print("demolist[", c, "] =", x)
&lt;/source&gt;

The &lt;code&gt;del&lt;/code&gt; command can be used to remove a given element in a list.  The next few lines use the &lt;code&gt;in&lt;/code&gt; operator to test if an element is in or is not in a list. The &lt;code&gt;sort&lt;/code&gt; function sorts the list. This is useful if you need a
list in order from smallest number to largest or alphabetical.  Note
that this rearranges the list. In summary, for a list, the following operations occur:

{| class="wikitable"
!example 
!explanation
|-
|&lt;code&gt;demolist[2]&lt;/code&gt; 
|accesses the element at index 2
|-
|&lt;code&gt;demolist[2] = 3&lt;/code&gt; 
|sets the element at index 2 to be 3
|-
|&lt;code&gt;del demolist[2]&lt;/code&gt; 
|removes the element at index 2
|-
|&lt;code&gt;len(demolist)&lt;/code&gt; 
|returns the length of &lt;code&gt;demolist&lt;/code&gt;
|-
|&lt;code&gt;"value" in demolist&lt;/code&gt; 
|is ''True'' if &lt;tt&gt;"value"&lt;/tt&gt; is an element in &lt;code&gt;demolist&lt;/code&gt;
|-
|&lt;code&gt;"value" not in demolist&lt;/code&gt; 
|is ''True'' if &lt;code&gt;"value"&lt;/code&gt; is not an element in &lt;code&gt;demolist&lt;/code&gt;
|-
|&lt;code&gt;another_list.sort()&lt;/code&gt; 
|sorts &lt;code&gt;another_list&lt;/code&gt;.  Note that the list must be all numbers or all strings to be sorted.
|-
|&lt;code&gt;demolist.index("value")&lt;/code&gt; 
|returns the index of the first place that &lt;code&gt;"value"&lt;/code&gt; occurs
|-
|&lt;code&gt;demolist.append("value")&lt;/code&gt; 
|adds an element &lt;code&gt;"value"&lt;/code&gt; at the end of the list
|-
|&lt;code&gt;demolist.remove("value")&lt;/code&gt;
|removes the first occurrence of value from &lt;code&gt;demolist&lt;/code&gt; (same as &lt;code&gt;del demolist[demolist.index("value")]&lt;/code&gt;)
|}

This next example uses these features in a more useful way:
&lt;source lang="python"&gt;
menu_item = 0
namelist = []
while menu_item != 9:
    print("--------------------")
    print("1. Print the list")
    print("2. Add a name to the list")
    print("3. Remove a name from the list")
    print("4. Change an item in the list")
    print("9. Quit")
    menu_item = int(input("Pick an item from the menu: "))
    if menu_item == 1:
        current = 0
        if len(namelist) &gt; 0:
            while current &lt; len(namelist):
                print(current, ".", namelist[current])
                current = current + 1
        else:
            print("List is empty")
    elif menu_item == 2:
        name = input("Type in a name to add: ")
        namelist.append(name)
    elif menu_item == 3:
        del_name = input("What name would you like to remove: ")
        if del_name in namelist:
            # namelist.remove(del_name) would work just as fine
            item_number = namelist.index(del_name)
            del namelist[item_number]
            # The code above only removes the first occurrence of
            # the name.  The code below from Gerald removes all.
            # while del_name in namelist:
            #       item_number = namelist.index(del_name)
            #       del namelist[item_number]
        else:
            print(del_name, "was not found")
    elif menu_item == 4:
        old_name = input("What name would you like to change: ")
        if old_name in namelist:
            item_number = namelist.index(old_name)
            new_name = input("What is the new name: ")
            namelist[item_number] = new_name
        else:
            print(old_name, "was not found")

print("Goodbye")
&lt;/source&gt;

And here is part of the output:

 --------------------
 1. Print the list
 2. Add a name to the list
 3. Remove a name from the list
 4. Change an item in the list
 9. Quit
 
 Pick an item from the menu: '''2'''
 Type in a name to add: '''Jack'''
 
 Pick an item from the menu: '''2'''
 Type in a name to add: '''Jill'''
 
 Pick an item from the menu: '''1'''
 0 . Jack
 1 . Jill
 
 Pick an item from the menu: '''3'''
 What name would you like to remove: '''Jack'''
 
 Pick an item from the menu: '''4'''
 What name would you like to change: '''Jill'''
 What is the new name: '''Jill Peters'''
 
 Pick an item from the menu: '''1'''
 0 . Jill Peters
 
 Pick an item from the menu: '''9'''
 Goodbye

That was a long program.  Let's take a look at the source code. The line &lt;code&gt;namelist = []&lt;/code&gt; makes the variable &lt;code&gt;namelist&lt;/code&gt; a list with no items (or elements).  The next important line is &lt;code&gt;while menu_item != 9:&lt;/code&gt;.  This line starts a loop that allows the menu system for this program.  The next few lines display a menu and decide which part of the program to run.

The section
&lt;source lang="python"&gt;
current = 0
if len(namelist) &gt; 0:
    while current &lt; len(namelist):
        print(current, ".", namelist[current])
        current = current + 1
else:
    print("List is empty")
&lt;/source&gt;
goes through the list and prints each name.  &lt;code&gt;len(namelist)&lt;/code&gt; tells how many items are in the list.  If &lt;code&gt;len&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;, then the list is empty.

Then, a few lines later, the statement &lt;code&gt;namelist.append(name)&lt;/code&gt; appears.  It uses the &lt;code&gt;append&lt;/code&gt; function to add an item to the end of the list.  Jump down another two lines, and notice this section of code:
&lt;source lang="python"&gt;
item_number = namelist.index(del_name)
del namelist[item_number]
&lt;/source&gt;
Here the &lt;code&gt;index&lt;/code&gt; function is used to find the index value that will be used later to remove the item.  &lt;code&gt;del namelist[item_number]&lt;/code&gt; is used to remove an element of the list.   

The next section
&lt;source lang="python"&gt;
old_name = input("What name would you like to change: ")
if old_name in namelist:
    item_number = namelist.index(old_name)
    new_name = input("What is the new name: ")
    namelist[item_number] = new_name
else:
   print(old_name, "was not found")
&lt;/source&gt;
uses &lt;code&gt;index&lt;/code&gt; to find the &lt;code&gt;item_number&lt;/code&gt; and then puts &lt;code&gt;new_name&lt;/code&gt; where the &lt;code&gt;old_name&lt;/code&gt; was.

Congratulations, with lists under your belt, you now know enough of the language
that you could do any computations that a computer can do (this is technically known as [[Wikipedia:Turing_completeness|Turing-Completeness]]).  Of course, there are still many features that
are used to make your life easier.

=== Examples ===
'''test.py'''
&lt;syntaxhighlight lang="python"&gt;
## This program runs a test of knowledge

# First get the test questions
# Later this will be modified to use file io.
def get_questions():
    # notice how the data is stored as a list of lists
    return [["What color is the daytime sky on a clear day? ", "blue"],
            ["What is the answer to life, the universe and everything? ", "42"],
            ["What is a three letter word for mouse trap? ", "cat"]]

# This will test a single question
# it takes a single question in
# it returns True if the user typed the correct answer, otherwise False

def check_question(question_and_answer):
    # extract the question and the answer from the list
    # This function takes a list with two elements, a question and an answer.  
    question = question_and_answer[0]   
    answer = question_and_answer[1]
    # give the question to the user
    given_answer = input(question)
    # compare the user's answer to the tester's answer
    if answer == given_answer:
        print("Correct")
        return True
    else:
        print("Incorrect, correct was:", answer)
        return False

# This will run through all the questions
def run_test(questions):
    if len(questions) == 0:
        print("No questions were given.")
        # the return exits the function
        return
    index = 0
    right = 0
    while index &lt; len(questions):
        # Check the question
        #Note that this is extracting a question and answer list from the list of lists.
        if check_question(questions[index]): 
            right = right + 1
        # go to the next question
        index = index + 1
    # notice the order of the computation, first multiply, then divide
    print("You got", right * 100 / len(questions),\
           "% right out of", len(questions))

# now let's get the questions from the get_questions function, and
# send the returned list of lists as an argument to the run_test function.

run_test(get_questions())


&lt;/syntaxhighlight&gt;

The values &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; point to 1 and 0, respectively. They are often used in sanity checks, loop conditions etc. You will learn more about this a little bit later (chapter [[../Boolean Expressions|Boolean Expressions]]).
Please note that get_questions() is essentially a list because even though it's technically a function, returning a list of lists is the only thing it does. 

Sample Output:

 What color is the daytime sky on a clear day? '''green'''
 Incorrect, correct was: blue
 What is the answer to life, the universe and everything? '''42'''
 Correct
 What is a three letter word for mouse trap? '''cat'''
 Correct
 You got 66 % right out of 3

=== Exercises ===
Expand the test.py program so it has a menu giving the option of taking
the test, viewing the list of questions and answers, and an option to
quit.  Also, add a new question to ask, "What noise does a truly
advanced machine make?" with the answer of "ping".

{{Solution|title=Solution|text=

Expand the test.py program so it has menu giving the option of taking
the test, viewing the list of questions and answers, and an option to
quit.  Also, add a new question to ask, "What noise does a truly
advanced machine make?" with the answer of "ping".

&lt;source lang="python"&gt;
## This program runs a test of knowledge

questions = [["What color is the daytime sky on a clear day? ", "blue"],
             ["What is the answer to life, the universe and everything? ", "42"],
             ["What is a three letter word for mouse trap? ", "cat"],
             ["What noise does a truly advanced machine make?", "ping"]]

# This will test a single question
# it takes a single question in
# it returns True if the user typed the correct answer, otherwise False

def check_question(question_and_answer):
    # extract the question and the answer from the list
    question = question_and_answer[0]
    answer = question_and_answer[1]
    # give the question to the user
    given_answer = input(question)
    # compare the user's answer to the testers answer
    if answer == given_answer:
        print("Correct")
        return True
    else:
        print("Incorrect, correct was:", answer)
        return False

# This will run through all the questions

def run_test(questions):

    if len(questions) == 0:
        print("No questions were given.")
        # the return exits the function
        return
    index = 0
    right = 0
    while index &lt; len(questions):
        # Check the question
        if check_question(questions[index]):
            right = right + 1
        # go to the next question
        index = index + 1
    # notice the order of the computation, first multiply, then divide
    print("You got", right * 100 / len(questions),
           "% right out of", len(questions))

#showing a list of questions and answers
def showquestions():
    q = 0
    while q &lt; len(questions):
        a = 0
        print("Q:" , questions[q][a])
        a = 1
        print("A:" , questions[q][a])
        q = q + 1

# now let's define the menu function
def menu():
    print("-----------------")
    print("Menu:")
    print("1 - Take the test")
    print("2 - View a list of questions and answers")
    print("3 - View the menu")
    print("5 - Quit")
    print("-----------------")

choice = "3"
while choice != "5":
    if choice == "1":
        run_test(questions)
    elif choice == "2":
        showquestions()
    elif choice == "3":
        menu()
    print()
    choice = input("Choose your option from the menu above: ") 

&lt;/source&gt;
}}

{{navigation |previous=Advanced Functions Example |next=For Loops}}
{{BookCat}}</text>
      <sha1>p7uaaec2jis05hgq1b2kl4vmwnc7jea</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/More on Lists</title>
    <ns>0</ns>
    <id>189840</id>
    <revision>
      <id>2544388</id>
      <parentid>2244009</parentid>
      <timestamp>2013-07-20T16:06:54Z</timestamp>
      <contributor>
        <username>Götz</username>
        <id>254632</id>
      </contributor>
      <comment>update {{navigation}}, add {{BookCat}}</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="10538" xml:space="preserve">We have already seen lists and how they can be used.   Now that you have some more background I will go into more detail about lists.  First we will look at more ways to get at the elements in a list and then we will talk about copying them.  

Here are some examples of using indexing to access a single element of a list:

 &gt;&gt;&gt; '''some_numbers = ['zero', 'one', 'two', 'three', 'four', 'five']'''
 &gt;&gt;&gt; '''some_numbers[0]'''
 'zero'
 &gt;&gt;&gt; '''some_numbers[4]'''
 'four'
 &gt;&gt;&gt; '''some_numbers[5]'''
 'five'

All those examples should look familiar to you.  If you want the first item in the list just look at index 0.  The second item is index 1 and so on through the list.  However what if you want the last item in the list?  One way could be to use the &lt;code&gt;len()&lt;/code&gt; function like &lt;code&gt;some_numbers[len(some_numbers) - 1]&lt;/code&gt;.  This way works since the &lt;code&gt;len()&lt;/code&gt; function always returns the last index plus one.  The second from the last would then be &lt;code&gt;some_numbers[len(some_numbers) - 2]&lt;/code&gt;.  There is an easier way to do this.  In Python the last item is always index -1.  The second to the last is index -2 and so on.  Here are some more examples:

 &gt;&gt;&gt; '''some_numbers[len(some_numbers) - 1]'''
 'five'
 &gt;&gt;&gt; '''some_numbers[len(some_numbers) - 2]'''
 'four'
 &gt;&gt;&gt; '''some_numbers[-1]'''
 'five'
 &gt;&gt;&gt; '''some_numbers[-2]'''
 'four'
 &gt;&gt;&gt; '''some_numbers[-6]'''
 'zero'

Thus any item in the list can be indexed in two ways: from the front and from the back.

Another useful way to get into parts of lists is using slicing.  Here is another example to give you an idea what they can be used for:

 &gt;&gt;&gt; '''things = [0, 'Fred', 2, 'S.P.A.M.', 'Stocking', 42, "Jack", "Jill"]'''
 &gt;&gt;&gt; '''things[0]'''
 0
 &gt;&gt;&gt; '''things[7]'''
 'Jill'
 &gt;&gt;&gt; '''things[0:8]'''
 [0, 'Fred', 2, 'S.P.A.M.', 'Stocking', 42, 'Jack', 'Jill']
 &gt;&gt;&gt; '''things[2:4]'''
 [2, 'S.P.A.M.']
 &gt;&gt;&gt; '''things[4:7]'''
 ['Stocking', 42, 'Jack']
 &gt;&gt;&gt; '''things[1:5]'''
 ['Fred', 2, 'S.P.A.M.', 'Stocking']

Slicing is used to return part of a list.  The slicing operator is in the form &lt;code&gt;things[first_index:last_index]&lt;/code&gt;.  Slicing cuts the list before the &lt;code&gt;first_index&lt;/code&gt; and before the &lt;code&gt;last_index&lt;/code&gt; and returns the parts in between.  You can use both types of indexing:

 &gt;&gt;&gt; '''things[-4:-2]'''
 ['Stocking', 42]
 &gt;&gt;&gt; '''things[-4]'''
 'Stocking'
 &gt;&gt;&gt; '''things[-4:6]'''
 ['Stocking', 42]

Another trick with slicing is the unspecified index.  If the first index is not specified the beginning of the list is assumed.  If the last index is not specified the whole rest of the list is assumed.  Here are some examples:

 &gt;&gt;&gt; '''things[:2]'''
 [0, 'Fred']
 &gt;&gt;&gt; '''things[-2:]'''
 ['Jack', 'Jill']
 &gt;&gt;&gt; '''things[:3]'''
 [0, 'Fred', 2]
 &gt;&gt;&gt; '''things[:-5]'''
 [0, 'Fred', 2]

Here is a (HTML inspired) program example (copy and paste in the poem definition if you want):
&lt;source lang="python"&gt;
poem = ["&lt;B&gt;", "Jack", "and", "Jill", "&lt;/B&gt;", "went", "up", "the",
        "hill", "to", "&lt;B&gt;", "fetch", "a", "pail", "of", "&lt;/B&gt;",
        "water.", "Jack", "fell", "&lt;B&gt;", "down", "and", "broke",
        "&lt;/B&gt;", "his", "crown", "and", "&lt;B&gt;", "Jill", "came",
        "&lt;/B&gt;", "tumbling", "after"]

def get_bolds(text):
    true = 1
    false = 0
    ## is_bold tells whether or not we are currently looking at 
    ## a bold section of text.
    is_bold = false
    ## start_block is the index of the start of either an unbolded 
    ## segment of text or a bolded segment.
    start_block = 0
    for index in range(len(text)):
        ## Handle a starting of bold text
        if text[index] == "&lt;B&gt;":
            if is_bold:
                print("Error: Extra Bold")
            ## print "Not Bold:", text[start_block:index]
            is_bold = true
            start_block = index + 1
        ## Handle end of bold text
        ## Remember that the last number in a slice is the index 
        ## after the last index used.
        if text[index] == "&lt;/B&gt;":
            if not is_bold:
                print("Error: Extra Close Bold")
            print("Bold [", start_block, ":", index, "]", text[start_block:index])
            is_bold = false
            start_block = index + 1

get_bolds(poem)
&lt;/source&gt;

with the output being:

 Bold [ 1 : 4 ] ['Jack', 'and', 'Jill']
 Bold [ 11 : 15 ] ['fetch', 'a', 'pail', 'of']
 Bold [ 20 : 23 ] ['down', 'and', 'broke']
 Bold [ 28 : 30 ] ['Jill', 'came']

The &lt;code&gt;get_bold()&lt;/code&gt; function takes in a list that is broken into words and tokens.  The tokens that it looks for are &lt;code&gt;&amp;lt;B&amp;gt;&lt;/code&gt; which starts the bold text and &lt;code&gt;&amp;lt;/B&amp;gt;&lt;/code&gt; which ends bold text. The function &lt;code&gt;get_bold()&lt;/code&gt; goes through and searches for the start and end tokens.

The next feature of lists is copying them.  If you try something simple like:

 &gt;&gt;&gt; '''a = [1, 2, 3]'''
 &gt;&gt;&gt; '''b = a'''
 &gt;&gt;&gt; '''print(b)'''
 [1, 2, 3]
 &gt;&gt;&gt; '''b[1] = 10'''
 &gt;&gt;&gt; '''print(b)'''
 [1, 10, 3]
 &gt;&gt;&gt; '''print(a)'''
 [1, 10, 3]

This probably looks surprising since a modification to &lt;code&gt;b&lt;/code&gt;
resulted in &lt;code&gt;a&lt;/code&gt; being changed as well.  What happened is that the
statement &lt;code&gt;b = a&lt;/code&gt; makes &lt;code&gt;b&lt;/code&gt; a ''reference'' to &lt;code&gt;a&lt;/code&gt;.
This means that &lt;code&gt;b&lt;/code&gt; can be thought of as another name for &lt;code&gt;a&lt;/code&gt;.
Hence any modification to &lt;code&gt;b&lt;/code&gt; changes &lt;code&gt;a&lt;/code&gt; as well.  However
some assignments don't create two names for one list:

 &gt;&gt;&gt; '''a = [1, 2, 3]'''
 &gt;&gt;&gt; '''b = a * 2'''
 &gt;&gt;&gt; '''print(a)'''
 [1, 2, 3]
 &gt;&gt;&gt; '''print(b)'''
 [1, 2, 3, 1, 2, 3]
 &gt;&gt;&gt; '''a[1] = 10'''
 &gt;&gt;&gt; '''print(a)'''
 [1, 10, 3]
 &gt;&gt;&gt; '''print(b)'''
 [1, 2, 3, 1, 2, 3]

In this case &lt;code&gt;b&lt;/code&gt; is not a reference to &lt;code&gt;a&lt;/code&gt; since the expression &lt;code&gt;a * 2&lt;/code&gt; creates a new list. Then the statement
&lt;code&gt;b = a * 2&lt;/code&gt; gives &lt;code&gt;b&lt;/code&gt; a reference to &lt;code&gt;a * 2&lt;/code&gt; rather than a reference to &lt;code&gt;a&lt;/code&gt;.  All assignment operations create a reference.
When you pass a list as an argument to a function you create a
reference as well.  Most of the time you don't have to worry about
creating references rather than copies.  However when you need to make
modifications to one list without changing another name of the list
you have to make sure that you have actually created a copy.

There are several ways to make a copy of a list.  The simplest that
works most of the time is the slice operator since it always makes a
new list even if it is a slice of a whole list:

 &gt;&gt;&gt; '''a = [1, 2, 3]'''
 &gt;&gt;&gt; '''b = a[:]'''
 &gt;&gt;&gt; '''b[1] = 10'''
 &gt;&gt;&gt; '''print(a)'''
 [1, 2, 3]
 &gt;&gt;&gt; '''print(b)'''
 [1, 10, 3]

Taking the slice &lt;code&gt;[:]&lt;/code&gt; creates a new copy of the list. However it only copies the outer list.  Any sublist inside is still a references to the sublist in the original list.  Therefore, when the list contains lists, the inner lists have to be copied as well.  You could do that manually but Python already contains a module to do it.  You use the &lt;code&gt;deepcopy&lt;/code&gt; function of the &lt;code&gt;copy&lt;/code&gt; module:

 &gt;&gt;&gt; '''import copy'''
 &gt;&gt;&gt; '''a = [[1, 2, 3], [4, 5, 6]]'''
 &gt;&gt;&gt; '''b = a[:]'''
 &gt;&gt;&gt; '''c = copy.deepcopy(a)'''
 &gt;&gt;&gt; '''b[0][1] = 10'''
 &gt;&gt;&gt; '''c[1][1] = 12'''
 &gt;&gt;&gt; '''print(a)'''
 [[1, 10, 3], [4, 5, 6]]
 &gt;&gt;&gt; '''print(b)'''
 [[1, 10, 3], [4, 5, 6]]
 &gt;&gt;&gt; '''print(c)'''
 [[1, 2, 3], [4, 12, 6]]

First of all notice that &lt;code&gt;a&lt;/code&gt; is a list of lists.  Then notice
that when &lt;code&gt;b[0][1] = 10&lt;/code&gt; is run both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are changed, but &lt;code&gt;c&lt;/code&gt; is not.  This happens because the inner arrays are still references when the slice operator is used.  However with &lt;code&gt;deepcopy&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; was fully copied.

So, should I worry about references every time I use a function or
&lt;code&gt;=&lt;/code&gt;?  The good news is that you only have to worry about
references when using dictionaries and lists.  Numbers and strings
create references when assigned but every operation on numbers and
strings that modifies them creates a new copy so you can never modify
them unexpectedly.  You do have to think about references when you are
modifying a list or a dictionary.

By now you are probably wondering why are references used at all?  The
basic reason is speed.  It is much faster to make a reference to a
thousand element list than to copy all the elements.  The other reason
is that it allows you to have a function to modify the inputed list
or dictionary.  Just remember about references if you ever have some
weird problem with data being changed when it shouldn't be.

&lt;!--  On Sun, Sep 09, 2001 at 02:46:06PM +0100, Hamish Lawson wrote: --&gt;
&lt;!--  Hello Josh --&gt;
&lt;!--   --&gt;
&lt;!--  I think it's great that you have undertaken to write a non-programmer's --&gt;
&lt;!--  tutorial on Python. However may I suggest that a different approach to --&gt;
&lt;!--  the discussion of variables and references may make things easier for --&gt;
&lt;!--  both you and the reader, and lead to less potential confusion for the --&gt;
&lt;!--  novice when they explore Python further? --&gt;
&lt;!--   --&gt;
&lt;!--  Programming introductions that use a language like C or Pascal as the --&gt;
&lt;!--  medium often discuss variables in terms of boxes that store data. But --&gt;
&lt;!--  for a language like Python, I think this approach ends up making the --&gt;
&lt;!--  whole subject of variables and references more complicated than it need --&gt;
&lt;!--  be and means that the reader has a lot to unlearn later. --&gt;
&lt;!--  --&gt;
&lt;!--  Saying that "a = []" stores an empty list in 'a' and that "b = a" makes --&gt;
&lt;!--  'b' a reference to 'a' makes it appear that assignment is --&gt;
&lt;!--  context-dependent when it isn't really. Things get even trickier when --&gt;
&lt;!--  you have statements like "b = f()". Instead a more coherent approach --&gt;
&lt;!--  might be to say that assignment to a variable stores a reference to --&gt;
&lt;!--  some object. The difference between "a = []" and "b = a" then lies in --&gt;
&lt;!--  whether it is a newly created object that you are storing a reference --&gt;
&lt;!--  to (as produced by '[]') or an existing object (as produced by 'a'), --&gt;
&lt;!--  *not* in whether or not a reference gets stored in the variable - it --&gt;
&lt;!--  always does. I believe this approach leads to much less confusion --&gt;
&lt;!--  overall and less need for special explanations. --&gt;
&lt;!--   --&gt;
&lt;!--  Fredrik Lundh has a good explanation of objects and references in --&gt;
&lt;!--  Python at http://www.effbot.org/guides/python-objects.htm. --&gt;
&lt;!--   --&gt;
&lt;!--  I hope you have found this useful. --&gt;

{{navigation |previous=Using Modules|next=Revenge of the Strings}}
{{BookCat}}</text>
      <sha1>438d8i9urfivwrxjbenedouil5vkwbl</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Revenge of the Strings</title>
    <ns>0</ns>
    <id>189882</id>
    <revision>
      <id>3313880</id>
      <parentid>3313798</parentid>
      <timestamp>2017-10-14T23:34:00Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/Ryan543|Ryan543]] ([[User talk:Ryan543|talk]]) to last version by JackPotte</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="13626" xml:space="preserve">&lt;!-- things to talk about: chr ord float int len repr s+b s[i] s[i:j] s*n find rfind replace strip --&gt;
&lt;!-- Start with indexing, user chr and ord to show how to do manual int&lt;-&gt;string --&gt;
&lt;!-- Repeate the &lt;B&gt; with slices and do actual html --&gt;
&lt;!-- Do some more phrasing --&gt;
&lt;!----&gt;
&lt;!-- Okay here is todays typing exercise: --&gt;
&lt;!-- &lt;source lang="python"&gt; --&gt;
&lt;!-- def to_string(in_int): --&gt;
&lt;!--     "Converts an integer to a string" --&gt;
&lt;!--     out_str = "" --&gt;
&lt;!--     prefix = "" --&gt;
&lt;!--     if in_int &lt; 0: --&gt;
&lt;!--         prefix = "-" --&gt;
&lt;!--         in_int = -in_int         --&gt;
&lt;!--     while in_int / 10 != 0: --&gt;
&lt;!--         out_str = chr(ord('0')+in_int % 10) + out_str --&gt;
&lt;!--         in_int = in_int / 10 --&gt;
&lt;!--     out_str = chr(ord('0')+in_int % 10) + out_str --&gt;
&lt;!--     return prefix + out_str --&gt;
&lt;!--  --&gt;
&lt;!-- def to_int(in_str): --&gt;
&lt;!--     "Converts a string to an integer" --&gt;
&lt;!--     out_num = 0 --&gt;
&lt;!--     if in_str[0] == "-": --&gt;
&lt;!--         multiplier = -1 --&gt;
&lt;!--         in_str = in_str[1:] --&gt;
&lt;!--     else: --&gt;
&lt;!--         multiplier = 1 --&gt;
&lt;!--     for x in range(0,len(in_str)): --&gt;
&lt;!--         out_num = out_num * 10 + ord(in_str[x]) - ord('0') --&gt;
&lt;!--     return out_num * multiplier --&gt;
&lt;!--  --&gt;
&lt;!-- print to_string(2) --&gt;
&lt;!-- print to_string(23445) --&gt;
&lt;!-- print to_string(-23445) --&gt;
&lt;!-- print to_int("14234") --&gt;
&lt;!-- print to_int("12345") --&gt;
&lt;!-- print to_int("-3512") --&gt;
&lt;!-- &lt;/source&gt; --&gt;
&lt;!-- The output is: --&gt;
&lt;!-- &lt;source lang="python"&gt; --&gt;
&lt;!-- 2 --&gt;
&lt;!-- 23445 --&gt;
&lt;!-- -23445 --&gt;
&lt;!-- 14234 --&gt;
&lt;!-- 12345 --&gt;
&lt;!-- -3512 --&gt;
&lt;!-- &lt;/source&gt; --&gt;
&lt;!--  --&gt;
&lt;!-- So how does it work?  The first detail to notice is that it defines two different functions, one that converts a string to a number and one that converts a number to a string.  Notice that this function does string manipulation similar to how lists can be manipulated.  For example the line &lt;code&gt;if in_str[0] == "-"&lt;/code&gt; uses indexing to look at the first letter in the string.  Another thing that strings can do that lists can is using slices.  The line &lt;code&gt;in_str = in_str[1:]&lt;/code&gt; uses slices to get all but the first character of in_str (or drops the first letter).  However you cannot use slices or indexing to assign to a letter or location in a string. --&gt;
&lt;!--  --&gt;
&lt;!-- Two new things to introduced are the functions &lt;code&gt;ord&lt;/code&gt; and &lt;code&gt;chr&lt;/code&gt;.  The  --&gt;
&lt;!-- &lt;code&gt;ord&lt;/code&gt; function takes a character (a string of length one) and returns the ASCII value of the character.  The function &lt;code&gt;chr&lt;/code&gt; is its inverse and takes a ASCII value and returns a character.  The expression &lt;code&gt;ord(in_str[x]) - ord('0')&lt;/code&gt; uses the &lt;code&gt;ord&lt;/code&gt; function to find the value of a string.  This works since '0' through '9' have ASCII values that are all in a row.  The ASCII value of '0' is 48 and the ASCII value of '9' is 57 so when we subtract 57-48 we get 9 and this works similarly with other numbers.  The expression &lt;code&gt;chr(ord('0')+in_int % 10)&lt;/code&gt; works in a similar manor but in reverse.
--&gt;
And now presenting a cool trick that can be done with strings:
&lt;source lang="python"&gt;
def shout(string):
    for character in string:
        print("Gimme a " + character)
        print("'" + character + "'")

shout("Lose")

def middle(string):
    print("The middle character is:", string[len(string) // 2])

middle("abcdefg")
middle("The Python Programming Language")
middle("Atlanta")
&lt;/source&gt;

And the output is:

 Gimme a L
 'L'
 Gimme a o
 'o'
 Gimme a s
 's'
 Gimme a e
 'e'
 The middle character is: d
 The middle character is: r
 The middle character is: a

What these programs demonstrate is that strings are similar to lists in several ways.  The &lt;code&gt;shout()&lt;/code&gt; function shows that &lt;code&gt;for&lt;/code&gt; loops can be used with strings just as they can be used with lists.  The &lt;code&gt;middle&lt;/code&gt; procedure shows that that strings can also use the &lt;code&gt;len()&lt;/code&gt; function and array indexes and slices.  Most list features work on strings as well.

The next feature demonstrates some string specific features:
&lt;source lang="python"&gt;
def to_upper(string):
    ## Converts a string to upper case
    upper_case = ""
    for character in string:
        if 'a' &lt;= character &lt;= 'z':
            location = ord(character) - ord('a')
            new_ascii = location + ord('A')
            character = chr(new_ascii)
        upper_case = upper_case + character
    return upper_case

print(to_upper("This is Text"))
&lt;/source&gt;

with the output being:

 THIS IS TEXT

This works because the computer represents the characters of a string as numbers from 0 to 1,114,111.  For example 'A' is 65, 'B' is 66 and א is 1488. The values are the [[w:en:unicode|unicode]] value.  Python has a function called &lt;code&gt;ord()&lt;/code&gt; (short for ordinal) that returns a character as a number.  There is also a corresponding function called &lt;code&gt;chr()&lt;/code&gt; that converts a number into a character.  With this in mind the program should start to be clear.  The first detail is the line: &lt;code&gt;if 'a' &lt;= character &lt;= 'z':&lt;/code&gt; which checks to see if a letter is lower case.  If it is then the next lines are used.  First it is converted into a location so that a&amp;nbsp;=&amp;nbsp;0, b&amp;nbsp;=&amp;nbsp;1, c&amp;nbsp;=&amp;nbsp;2 and so on with the line: &lt;code&gt;location = ord(character) - ord('a')&lt;/code&gt;.  Next the new value is found with &lt;code&gt;new_ascii = location + ord('A')&lt;/code&gt;.  This value is converted back to a character that is now upper case.  Note that if you really need the upper case of a letter, you should use &lt;code&gt;u=var.upper()&lt;/code&gt; which will work with other languages as well.  

Now for some interactive typing exercise:

 &gt;&gt;&gt; '''# Integer to String'''
 &gt;&gt;&gt; '''2'''
 2
 &gt;&gt;&gt; '''repr(2)'''
 '2'
 &gt;&gt;&gt; '''-123'''
 -123
 &gt;&gt;&gt; '''repr(-123)'''
 '-123'
 &gt;&gt;&gt; '''# String to Integer'''
 &gt;&gt;&gt; '''"23"'''
 '23'
 &gt;&gt;&gt; '''int("23")'''
 23
 &gt;&gt;&gt; '''"23" * 2'''
 '2323'
 &gt;&gt;&gt; '''int("23") * 2'''
 46
 &gt;&gt;&gt; '''# Float to String'''
 &gt;&gt;&gt; '''1.23'''
 1.23
 &gt;&gt;&gt; '''repr(1.23)'''
 '1.23'
 &gt;&gt;&gt; '''# Float to Integer'''
 &gt;&gt;&gt; '''1.23'''
 1.23
 &gt;&gt;&gt; '''int(1.23)'''
 1
 &gt;&gt;&gt; '''int(-1.23)'''
 -1
 &gt;&gt;&gt; '''# String to Float'''
 &gt;&gt;&gt; '''float("1.23")'''
 1.23
 &gt;&gt;&gt; '''"1.23"''' 
 '1.23'
 &gt;&gt;&gt; '''float("123")'''
 123.0

If you haven't guessed already the function &lt;code&gt;repr()&lt;/code&gt; can convert an integer to a string and the function &lt;code&gt;int()&lt;/code&gt; can convert a string to an integer. The function &lt;code&gt;float()&lt;/code&gt; can convert a string to a float.  The &lt;code&gt;repr()&lt;/code&gt; function returns a printable representation of something. Here are some examples of this:

 &gt;&gt;&gt; '''repr(1)'''
 '1'
 &gt;&gt;&gt; '''repr(234.14)'''
 '234.14'
 &gt;&gt;&gt; '''repr([4, 42, 10])'''
 '[4, 42, 10]'

The &lt;code&gt;int()&lt;/code&gt; function tries to convert a string (or a float) into an integer.  There is also a similar function called &lt;code&gt;float()&lt;/code&gt; that will convert an integer or a string into a float.  Another function that Python has is the &lt;code&gt;eval()&lt;/code&gt; function.  The &lt;code&gt;eval()&lt;/code&gt; function takes a string and returns data of the type that python thinks it found.  For example:

 &gt;&gt;&gt; '''v = eval('123')'''
 &gt;&gt;&gt; '''print(v, type(v))'''
 123 &lt;type 'int'&gt;
 &gt;&gt;&gt; '''v = eval('645.123')'''
 &gt;&gt;&gt; '''print(v, type(v))'''
 645.123 &lt;type 'float'&gt;
 &gt;&gt;&gt; '''v = eval('[1, 2, 3]')'''
 &gt;&gt;&gt; '''print(v, type(v))'''
 [1, 2, 3] &lt;type 'list'&gt;

If you use the &lt;code&gt;eval()&lt;/code&gt; function you should check that it returns the type that you expect.

One useful string function is the &lt;code&gt;split()&lt;/code&gt; method. Here's an example:

 &gt;&gt;&gt; '''"This is a bunch of words".split()'''
 ['This', 'is', 'a', 'bunch', 'of', 'words']
 &gt;&gt;&gt; '''text = "First batch, second batch, third, fourth"'''
 &gt;&gt;&gt; '''text.split(",")'''
 ['First batch', ' second batch', ' third', ' fourth']

Notice how &lt;code&gt;split()&lt;/code&gt; converts a string into a list of strings.  The string is split by whitespace by default or by the optional argument (in this case a comma).
You can also add another argument that tells &lt;code&gt;split()&lt;/code&gt; how many times the separator will be used to split the text. For example:

 &gt;&gt;&gt; '''list = text.split(",")'''
 &gt;&gt;&gt; '''len(list)'''
 4
 &gt;&gt;&gt; '''list[-1]'''
 ' fourth'
 &gt;&gt;&gt; '''list = text.split(",", 2)'''
 &gt;&gt;&gt; '''len(list)'''
 3
 &gt;&gt;&gt; '''list[-1]'''
 ' third, fourth'

&lt;!-- TODO add more on strings --&gt;
=== Slicing strings (and lists) ===

Strings can be cut into pieces &amp;mdash; in the same way as it was shown for lists in the previous chapter &amp;mdash; by using the ''slicing'' "operator" &lt;tt&gt;[]&lt;/tt&gt;. The slicing operator works in the same way as before: text[first_index:last_index] (in very rare cases there can be another colon and a third argument, as in the example shown below).

In order not to get confused by the index numbers, it is easiest to see them as ''clipping places'', possibilities to cut a string into parts. Here is an example, which shows the clipping places (in yellow) and their index numbers (red and blue) for a simple text string:

&lt;tt&gt;
{| style="text-align:center" cellspacing="0px"
|
| style="width:2ex" |
| style="width:2ex;color:red" |0
| style="width:2ex" |
| style="width:2ex;color:red" |1
| style="width:2ex" |
| style="width:2ex;color:red" |2
| style="width:2ex" |
| style="width:2ex" | ...
| style="width:2ex" |
| style="width:2ex;color:blue" | -2
| style="width:2ex" |
| style="width:2ex;color:blue" | -1
| style="width:2ex" |
| style="width:2ex" |
| style="width:2ex" |
|-
|
|
| style="background:#FFFF88" |&amp;darr;
|
| style="background:#FFFF88" |&amp;darr;
|
| style="background:#FFFF88" |&amp;darr;
|
| style="background:#FFFF88" |&amp;darr;
|
| style="background:#FFFF88" |&amp;darr;
|
| style="background:#FFFF88" |&amp;darr;
|
| style="background:#FFFF88" |&amp;darr;
|
|-
| text = 
|"
| style="background:#FFFF88" |
!S 
| style="background:#FFFF88" |
!T
| style="background:#FFFF88" |
!R
| style="background:#FFFF88" |
!I
| style="background:#FFFF88" |
!N
| style="background:#FFFF88" |
!G
| style="background:#FFFF88" |
|"
|-
|
|
| style="background:#FFFF88" |&amp;uarr;
|
| style="background:#FFFF88" |
|
| style="background:#FFFF88" |
|
| style="background:#FFFF88" |
|
| style="background:#FFFF88" |
|
| style="background:#FFFF88" |
|
| style="background:#FFFF88" |&amp;uarr;
|
|-
|
|
|[:
|
|
|
|
|
|
|
|
|
|
|
|:]
|
|}
&lt;/tt&gt;

Note that the red indexes are counted from the beginning of the string and the blue ones from the end of the string backwards. (Note that there is no blue -0, which could seem to be logical at the end of the string. Because &lt;tt&gt;-0 == 0&lt;/tt&gt;, -0 means "beginning of the string" as well.)  Now we are ready to use the indexes for slicing operations:

&lt;tt&gt;
{|
|-
|text[1:4] || style="width:3em;text-align:center" | &amp;rarr; || "TRI"
|-
|text[:5] || style="width:3em;text-align:center" | &amp;rarr; || "STRIN"
|-
|text[:-1] || style="width:3em;text-align:center" | &amp;rarr; || "STRIN"
|-
|text[-4:] || style="width:3em;text-align:center" | &amp;rarr; || "RING"
|-
|text[2] || style="width:3em;text-align:center" | &amp;rarr; || "R"
|-
|text[:] || style="width:3em;text-align:center" | &amp;rarr; || "STRING"
|-
|text[::-1] || style="width:3em;text-align:center" | &amp;rarr; || "GNIRTS"
|}
&lt;/tt&gt;

&lt;tt&gt;text[1:4]&lt;/tt&gt; gives us all of the &lt;tt&gt;text&lt;/tt&gt; string between clipping places 1 and 4, "&lt;tt&gt;TRI&lt;/tt&gt;". If you omit one of the [first_index:last_index] arguments, you get the beginning or end of the string as default: &lt;tt&gt;text[:5]&lt;/tt&gt; gives "&lt;tt&gt;STRIN&lt;/tt&gt;". For both &lt;tt&gt;first_index&lt;/tt&gt; and &lt;tt&gt;last_index&lt;/tt&gt; we can use both the red and the blue numbering schema: &lt;tt&gt;text[:-1]&lt;/tt&gt; gives the same as &lt;tt&gt;text[:5]&lt;/tt&gt;, because the index -1 is at the same place as 5 in this case. If we do not use an argument containing a colon, the number is treated in a different way: &lt;tt&gt;text[2]&lt;/tt&gt; gives us one character following the second clipping point, "&lt;tt&gt;R&lt;/tt&gt;". The special slicing operation &lt;tt&gt;text[:]&lt;/tt&gt; means "from the beginning to the end" and produces a copy of the entire string (or list, as shown in the previous chapter).

Last but not least, the slicing operation can have a second colon and a third argument, which is interpreted as the "step size": &lt;tt&gt;text[::-1]&lt;/tt&gt; is &lt;tt&gt;text&lt;/tt&gt; from beginning to the end, with a step size of -1. -1 means "every character, but in the other direction". "&lt;tt&gt;STRING&lt;/tt&gt;" backwards is "&lt;tt&gt;GNIRTS&lt;/tt&gt;" (test a step length of 2, if you have not got the point here).

All these slicing operations work with lists as well. In that sense strings are just a special case of lists, where the list elements are single characters. Just remember the concept of ''clipping places'', and the indexes for slicing things will get a lot less confusing.

=== Examples ===
&lt;source lang="python"&gt;
# This program requires an excellent understanding of decimal numbers.
def to_string(in_int):
    """Converts an integer to a string"""
    out_str = ""
    prefix = ""
    if in_int &lt; 0:
        prefix = "-"
        in_int = -in_int
    while in_int // 10 != 0:
        out_str = str(in_int % 10) + out_str
        in_int = in_int // 10
    out_str = str(in_int % 10) + out_str
    return prefix + out_str

def to_int(in_str):
    """Converts a string to an integer"""
    out_num = 0
    if in_str[0] == "-":
        multiplier = -1
        in_str = in_str[1:]
    else:
        multiplier = 1
    for c in in_str:
        out_num = out_num * 10 + int(c)
    return out_num * multiplier

print(to_string(2))
print(to_string(23445))
print(to_string(-23445))
print(to_int("14234"))
print(to_int("12345"))
print(to_int("-3512"))
&lt;/source&gt;

The output is:

 2
 23445
 -23445
 14234
 12345
 -3512

{{navigation |previous=More on Lists|next=File IO}}
{{BookCat}}</text>
      <sha1>k8nyvpddp835orva7khzi32dnm6u3zc</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/The End</title>
    <ns>0</ns>
    <id>190103</id>
    <revision>
      <id>3120074</id>
      <parentid>2676494</parentid>
      <timestamp>2016-09-14T18:52:08Z</timestamp>
      <contributor>
        <ip>24.61.47.85</ip>
      </contributor>
      <comment>Added an additional free resource (alphabetical order)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1305" xml:space="preserve">So here we are at the end, or maybe the beginning.  This tutorial is on Wikibooks, so feel free to make improvements to it. If you want to learn more about Python, [http://docs.python.org/3/tutorial/index.html The Python Tutorial] by [http://www.python.org/~guido/ Guido van Rossum] has more topics that you can learn about.   If you have been following this tutorial, you should be able to understand a fair amount of it.  The [[Python Programming]] wikibook can be worth looking at, too.  Here are few other books which cover Python 3:

* [http://www.swaroopch.com/notes/Python A Byte of Python by Swaroop C H]
* [https://www.datacamp.com/courses/intro-to-python-for-data-science DataCamp Interactive Python 3 Tutorial - Online]
* [http://anh.cs.luc.edu/python/hands-on/3.1/handsonHtml/index.html Hands-on Python Tutorial by Dr. Andrew N. Harrington] 
* [[Subject:Python programming language]] lists other Wikibooks related to Python.

Hopefully this book covers everything you have needed to get started programming.  Thanks to everyone who has sent me emails about it.  I enjoyed reading them, even when I have not always been the best replier.  

Happy programming, may it change your life and the world.

{{navigation |previous=Intro to Imported Libraries and other Functions |next=FAQ}}
{{BookCat}}</text>
      <sha1>6wofgc73j9awxlwz3joo8c9fvr8t6g6</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Using Modules</title>
    <ns>0</ns>
    <id>189839</id>
    <revision>
      <id>3656246</id>
      <parentid>3656232</parentid>
      <timestamp>2020-01-30T12:18:54Z</timestamp>
      <contributor>
        <username>Mrjulesd</username>
        <id>1779740</id>
      </contributor>
      <comment>Rejected the last 2 text changes (by [[Special:Contributions/219.78.129.217|219.78.129.217]]) and restored revision 3515023 by 75.180.22.94</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="6967" xml:space="preserve">Here's this chapter's typing exercise (name it cal.py (&lt;code&gt;import&lt;/code&gt; actually looks for a file named calendar.py and reads it in.  If the file is named calendar.py and it sees a "import calendar" it tries to read in itself which works poorly at best.)):

&lt;source lang="python"&gt;
import calendar
year = int(input("Type in the year number: "))
calendar.prcal(year)
&lt;/source&gt;

And here is part of the output I got:

 Type in the year number: 2001
 
                                  2001                                  
 
        January                  February                    March      
 
 Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7                1  2  3  4                1  2  3  4     
 8  9 10 11 12 13 14       5  6  7  8  9 10 11       5  6  7  8  9 10 11
 15 16 17 18 19 20 21      12 13 14 15 16 17 18      12 13 14 15 16 17 18     
 22 23 24 25 26 27 28      19 20 21 22 23 24 25      19 20 21 22 23 24 25     
 29 30 31                  26 27 28                  26 27 28 29 30 31        

(I skipped some of the output, but I think you get the idea.) So what does the program do?  The first line &lt;code&gt;import calendar&lt;/code&gt; uses a new command &lt;code&gt;import&lt;/code&gt;.  The command &lt;code&gt;import&lt;/code&gt; loads a module (in this case the &lt;code&gt;calendar&lt;/code&gt; module).  To see the commands available in the standard modules either look in the library reference for python (if you downloaded it) or go to http://docs.python.org/3/library/.  If you look at the documentation for the calendar module, it lists a function called &lt;code&gt;prcal&lt;/code&gt; that prints a calendar for a year.  The line &lt;code&gt;calendar.prcal(year)&lt;/code&gt; uses this function.  In summary to use a module &lt;code&gt;import&lt;/code&gt; it and then use &lt;code&gt;module_name.function&lt;/code&gt; for functions in the module.  Another way to write the program is:

&lt;source lang="python"&gt;
from calendar import prcal

year = int(input("Type in the year number: "))
prcal(year)
&lt;/source&gt; 

This version imports a specific function from a module.  Here is another program that uses the Python Library (name it something like clock.py) (press Ctrl and the 'c' key at the same time to terminate the program):

&lt;source lang="python"&gt;
from time import time, ctime

prev_time = ""
while True:
    the_time = ctime(time())
    if prev_time != the_time:
        print("The time is:", ctime(time()))
        prev_time = the_time
&lt;/source&gt;

With some output being:

 The time is: Sun Aug 20 13:40:04 2000
 The time is: Sun Aug 20 13:40:05 2000
 The time is: Sun Aug 20 13:40:06 2000
 The time is: Sun Aug 20 13:40:07 2000
 
 Traceback (innermost last):
  File "clock.py", line 5, in ?
     the_time = ctime(time())
 
 KeyboardInterrupt

The output is infinite of course so I cancelled it (or the output at least continues until Ctrl+C is pressed).  The program just does an infinite loop (&lt;code&gt;True&lt;/code&gt; is always true, so &lt;code&gt;while True:&lt;/code&gt; goes forever) and each time checks to see if the time has changed and prints it if it has.  Notice how multiple names after the import statement are used in the line &lt;code&gt;from time import time, ctime&lt;/code&gt;.  

The Python Library contains many useful functions.  These functions give your programs more abilities and many of them can simplify programming in Python.

=== Exercises ===
Rewrite the &lt;code&gt;high_low.py&lt;/code&gt; program from section [[../Decisions#Examples|Decisions]] to use an random integer between 0 and 99 instead of the hard-coded 7. Use the Python documentation to find an appropriate module and function to do this.

{{Solution|title=Solution|text=

Rewrite &lt;code&gt;the high_low.py&lt;/code&gt; program from section [[../Decisions#Examples|Decisions]] to use an random integer between 0 and 99 instead of the hard-coded 7. Use the Python documentation to find an appropriate module and function to do this.

&lt;source lang="python"&gt;
from random import randint
number = randint(0, 99)
guess = -1
while guess != number: 
    guess = int(input ("Guess a number: "))
    if guess &gt; number:
        print("Too high")
    elif guess &lt; number:
            print("Too low")
print("Just right")

&lt;/source&gt;
}}

==Other modules==
Sometimes you want to use a python module that does not come with the Python installation. You can also import those, but you have to have them installed on your computer.

===Creating your own module===
When python reads the import command, it first checks files in your directory, then site-packages or pre installed modules. To make your own module, just create a .py file in the current directory and use the command:
&lt;syntaxhighlight lang="python3"&gt;
import module
&lt;/syntaxhighlight&gt;

This will try to import the file module.py from your current directory and if not found, from site-packages and prepackaged modules. Changing module to the name of the .py file you created will import that file. 

However, when it imports the module, it will basically start the file as a program, so any code on there will be run. You want to group all code into functions.
====The __name__ == __main__ trick====
In python, the variable &lt;code&gt;__name__&lt;/code&gt; will give you the current name of the program. If a module you import prints the &lt;code&gt;__name__&lt;/code&gt; variable, then it will print the name of the module. If the current file prints the &lt;code&gt;__name__&lt;/code&gt; variable, it will print &lt;code&gt;__main__&lt;/code&gt;, to show it is the main program.

If an if statement checks the name variable and runs code if the program is main, it can bypass the unintentional run problem created when a module is imported. Say for example you have a file, which runs some code. It also has a function you want to use in another program. However, you only want the function, not to run the code. By setting up the code below, it will only run the code if it is the file that was clicked on or started, not if it was imported.
&lt;syntaxhighlight lang="python3"&gt;
if __name__ == '__main__':
    pass
&lt;/syntaxhighlight&gt;
In this instance, if the file is run but not imported, it will run the pass command. You can replace the pass command with the code you want to be run when not imported. Just remember to indent the code. 
===The pip module===
The pip module is a module that comes with the python installation and acts as a module downloader/manager. You can download other modules from the internet with pip.

The pip module is not used in the python interpreter, but is run through the command line. To use it, open up your command line interpreter (for Windows it is Command Prompt, for Mac/Linux it is Terminal) and type in the following code:
&lt;syntaxhighlight lang="bash"&gt;
py3 -m pip install module
&lt;/syntaxhighlight&gt;

or the alternate code

&lt;syntaxhighlight lang="bash"&gt;
pip install module
&lt;/syntaxhighlight&gt;

This will try to download and install module from the user-submitted python modules database. Module can be changed to the name of the module. 

{{navigation |previous=Dictionaries|next=More on Lists}}</text>
      <sha1>dw53ilwqwv1qc5ija1svw63cgvc6pl4</sha1>
    </revision>
  </page>
  <page>
    <title>Non-Programmer's Tutorial for Python 3/Who Goes There?</title>
    <ns>0</ns>
    <id>179828</id>
    <revision>
      <id>3515849</id>
      <parentid>3515848</parentid>
      <timestamp>2019-02-11T15:56:27Z</timestamp>
      <contributor>
        <ip>152.26.182.25</ip>
      </contributor>
      <comment>/* Input and Variables */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="9313" xml:space="preserve">=== Input and Variables ===
Now I feel it is time for a really complicated program.  Here it is:
&lt;source lang="python"&gt;
print("Halt!")
user_input = input("Who goes there? ")
print("You may pass,",  user_input)
&lt;/source&gt;

When '''I''' ran it, here is what '''my''' screen showed:

 Halt!
 Who goes there? '''Josh'''
 You may pass, Josh

''Note: After running the code by pressing F5, the python shell will only give output:''

 Halt!
 Who goes there?

''You need to enter your name in the python shell, and then press enter for the rest of the output.''

Of course when you run the program your screen will look different
because of the &lt;code&gt;input()&lt;/code&gt; statement. When you ran the program
you probably noticed (you did run the program, right?) how you had to
type in your name and then press Enter. Then the program printed out
some more text and also your name. This is an example of ''input''.  The
program reaches a certain point and then waits for the user to input
some data that the program can use later.

Of course, getting information from the user would be useless if we didn't have anywhere to put that information and this is where variables come in.  In the previous program &lt;code&gt;user_input&lt;/code&gt; is a ''variable''.  Variables are like a box that can store some piece of data.  Here is a program to show examples of variables:
&lt;source lang="python"&gt;
a = 123.4
b23 = 'Spam'
first_name = "Bill"
b = 432
c = a + b
print("a + b is",c)
print("first_name is",first_name)
print("Sorted Parts, After Midnight or",b23)
&lt;/source&gt;

And here is the output:

 a + b is 555.4
 first_name is Bill
 Sorted Parts, After Midnight or Spam

Variables store data.  The variables in the above program are &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b23&lt;/code&gt;, &lt;code&gt;first_name&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;. The two basic types are ''strings'' and ''numbers''.  Strings are a sequence of letters, numbers and other characters. In this example &lt;code&gt;b23&lt;/code&gt; and &lt;code&gt;first_name&lt;/code&gt; are variables that are storing strings. &lt;code&gt;Spam&lt;/code&gt;, &lt;code&gt;Bill&lt;/code&gt;, &lt;code&gt;a + b is&lt;/code&gt;, &lt;code&gt;first_name is&lt;/code&gt;, and &lt;code&gt;Sorted Parts, After Midnight or&lt;/code&gt; are the strings in this program.  The characters are surrounded by &lt;code&gt;"&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;.  The other type of variables are numbers. Remember that variables are used to store a value, they do not use quotation marks (" and '). If you want to use an actual ''value'', you ''must'' use quotation marks.

&lt;source lang="python"&gt;
value1 == Pim
value2 == "Pim"
&lt;/source&gt;

Both look the same, but in the first one Python checks if the value stored in the variable &lt;code&gt;value1&lt;/code&gt; is the same as the value stored in the ''variable'' &lt;code&gt;Pim&lt;/code&gt;. In the second one, Python checks if the string (the actual letters &lt;code&gt;P&lt;/code&gt;,&lt;code&gt;i&lt;/code&gt;, and &lt;code&gt;m&lt;/code&gt;) are the same as in &lt;code&gt;value2&lt;/code&gt; (continue this tutorial for more explanation about strings and about the &lt;code&gt;==&lt;/code&gt;).

=== Assignment ===

Okay, so we have these boxes called variables and also data that can go into the variable.  The computer will see a line like &lt;code&gt;first_name = "Bill"&lt;/code&gt; and it reads it as "Put the string &lt;code&gt;Bill&lt;/code&gt; into the box (or variable) &lt;code&gt;first_name&lt;/code&gt;". Later on it sees the statement &lt;code&gt;c = a + b&lt;/code&gt; and it reads it as "put the sum of &lt;code&gt;a + b&lt;/code&gt; or &lt;code&gt;123.4 + 432&lt;/code&gt; which equals &lt;code&gt;555.4&lt;/code&gt; into &lt;code&gt;c&lt;/code&gt;". The right hand side of the statement (&lt;code&gt;a + b&lt;/code&gt;) is ''evaluated'' and the result is stored in the variable on the left hand side (&lt;code&gt;c&lt;/code&gt;). This is called ''assignment'', and you should not confuse the assignment equal sign (&lt;code&gt;=&lt;/code&gt;) with "equality" in a mathematical sense here (that's what &lt;code&gt;==&lt;/code&gt; will be used for later).

Here is another example of variable usage:
&lt;source lang="python"&gt;
a = 1
print(a)
a = a + 1
print(a)
a = a * 2
print(a)
&lt;/source&gt;

And of course here is the output:

 1
 2
 4

Even if the same variable appears on both sides of the equals sign (e.g., spam = spam), the computer still reads it as, "First find out the data to store and then find out where the data goes."

One more program before I end this chapter:
&lt;source lang="python"&gt;
number = float(input("Type in a number: "))
integer = int(input("Type in an integer: "))
text = input("Type in a string: ")
print("number =", number)
print("number is a", type(number))
print("number * 2 =", number * 2)
print("integer =", integer)
print("integer is a", type(integer))
print("integer * 2 =", integer * 2)
print("text =", text)
print("text is a", type(text))
print("text * 2 =", text * 2)




&lt;/source&gt;

The output I got was:

 Type in a number: '''12.34'''
 Type in an integer: '''-3'''
 Type in a string: '''Hello'''
 number = 12.34
 number is a &lt;class 'float'&gt;
 number * 2 = 24.68
 integer = -3
 integer is a &lt;class 'int'&gt;
 integer * 2 = -6
 text = Hello
 text is a &lt;class 'str'&gt;
 text * 2 = HelloHello

Notice that &lt;code&gt;number&lt;/code&gt; was created with &lt;code&gt;float(input())&lt;/code&gt; ,&lt;code&gt;int(input())&lt;/code&gt; returns an integer, a number with no decimal point, 
while  &lt;code&gt;text&lt;/code&gt; created with &lt;code&gt;input()&lt;/code&gt; returns a string(can be writen as &lt;code&gt;str(input())&lt;/code&gt;, too). When you want the user to type in a decimal use &lt;code&gt;float(input())&lt;/code&gt;, if you want the user to type in an integer use &lt;code&gt;int(input())&lt;/code&gt;, but if you want the user to type in a string use &lt;code&gt;input()&lt;/code&gt;.

The second half of the program uses the &lt;code&gt;type()&lt;/code&gt; function which tells what kind a
variable is. Numbers are of type &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;, which are
short for ''integer'' and ''floating point'' (mostly used for decimal numbers), respectively. Text strings are of type &lt;code&gt;str&lt;/code&gt;, short for ''string''. Integers and floats can be worked on by mathematical functions, strings cannot. Notice how when python
multiplies a number by an integer the expected thing happens. However
when a string is multiplied by an integer the result is that multiple
copies of the string are produced (i.e., &lt;code&gt;text * 2 = HelloHello&lt;/code&gt;).

Operations with strings do different things than 
operations with numbers. As well, some operations only work with numbers (both integers and floating point numbers) and will give an error if a string is used. Here are some interactive mode examples
to show that some more.

&lt;pre&gt;
&gt;&gt;&gt; print("This" + " " + "is" + " joined.")
This is joined.
&gt;&gt;&gt; print("Ha, " * 5)
Ha, Ha, Ha, Ha, Ha, 
&gt;&gt;&gt; print("Ha, " * 5 + "ha!")
Ha, Ha, Ha, Ha, Ha, ha!
&gt;&gt;&gt; print(3 - 1)
2
&gt;&gt;&gt; print("3" - "1")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for -: 'str' and 'str'
&gt;&gt;&gt; 
&lt;/pre&gt;

Here is the list of some string operations:

{| class="wikitable"
!Operation 
!Symbol 
!Example
|-
|Repetition 
|&lt;code&gt;*&lt;/code&gt; 
|&lt;code&gt;"i" * 5 == "iiiii"&lt;/code&gt;
|-
|Concatenation 
|&lt;code&gt;+&lt;/code&gt; 
|&lt;code&gt;"Hello, " + "World!" == "Hello, World!"&lt;/code&gt;
|}

=== Examples ===

'''Rate_times.py'''
&lt;source lang="python"&gt;
# This program calculates rate and distance problems
print("Input a rate and a distance")
rate = float(input("Rate: "))
distance = float(input("Distance: "))
time=(distance/ rate)
print("Time:", time)

&lt;/source&gt;

Sample runs:

 Input a rate and a distance
 Rate: '''5'''
 Distance: '''10'''
 Time: 2.0

 Input a rate and a distance
 Rate: '''3.52'''
 Distance: '''45.6'''
 Time: 12.9545454545

'''Area.py'''
&lt;source lang="python"&gt;
# This program calculates the perimeter and area of a rectangle
print("Calculate information about a rectangle")
length = float(input("Length: "))
width = float(input("Width: "))
Perimeter=(2 * length + 2 * width) 
print("Area:", length * width)
print("Perimeter:",Perimeter)
&lt;/source&gt;

Sample runs:

 Calculate information about a rectangle
 Length: '''4'''
 Width: '''3'''
 Area: 12.0
 Perimeter: 14.0

 Calculate information about a rectangle
 Length: '''2.53'''
 Width: '''5.2'''
 Area: 13.156
 Perimeter: 15.46

'''Temperature.py'''
&lt;source lang="python"&gt;
# This program converts Fahrenheit to Celsius
fahr_temp = float(input("Fahrenheit temperature: "))
celc_temp = (fahr_temp - 32.0) *( 5.0 / 9.0)
print("Celsius temperature:", celc_temp)
&lt;/source&gt;

Sample runs:

 Fahrenheit temperature: '''32'''
 Celsius temperature: 0.0

 Fahrenheit temperature: '''-40'''
 Celsius temperature: -40.0

 Fahrenheit temperature: '''212'''
 Celsius temperature: 100.0

 Fahrenheit temperature: '''98.6'''
 Celsius temperature: 37.0

=== Exercises ===
Write a program that gets 2 string variables and 2 number variables
from the user, concatenates (joins them together with no spaces) and
displays the strings, then multiplies the two numbers on a new line.

{{Solution|title=Solution|text=

Write a program that gets 2 string variables and 2 number variables
from the user, concatenates (joins them together with no spaces) and
displays the strings, then multiplies the two numbers on a new line.

&lt;source lang="python"&gt;  
string1 = input('String 1: ')
string2 = input('String 2: ')
float1 = float(input('Number 1: '))
float2 = float(input('Number 2: '))
print(string1 + string2)
print(float1 * float2)
&lt;/source&gt;
}}

{{navigation |previous=Hello, World |next=Count to 10}}
{{BookCat}}

[[ca:Python 3 per a no programadors/Qui hi ha?]]</text>
      <sha1>15vkne9y1aos0sofm7vjacds0cvlnil</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ambox</title>
    <ns>10</ns>
    <id>384875</id>
    <redirect title="Template:Bmbox" />
    <revision>
      <id>3228920</id>
      <timestamp>2017-06-12T23:26:41Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>JackPotte moved page [[Template:Ambox]] to [[Template:Bmbox]] over redirect: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="28" xml:space="preserve">#REDIRECT [[Template:Bmbox]]</text>
      <sha1>dxps9o5us57jnv4ru2ijugfl7l7m3fr</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ambox/core</title>
    <ns>10</ns>
    <id>384876</id>
    <redirect title="Template:Bmbox/core" />
    <revision>
      <id>3228922</id>
      <timestamp>2017-06-12T23:26:42Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>JackPotte moved page [[Template:Ambox/core]] to [[Template:Bmbox/core]]: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="33" xml:space="preserve">#REDIRECT [[Template:Bmbox/core]]</text>
      <sha1>h9ijn3lsvc1xiywalc32i94xf9ujsdf</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKCATEGORY</title>
    <ns>10</ns>
    <id>378612</id>
    <revision>
      <id>3365859</id>
      <parentid>3318591</parentid>
      <timestamp>2018-01-24T02:52:43Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>BOOKNAME (new-style)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="131" xml:space="preserve">&lt;includeonly&gt;Category:Book:{{{book|{{BOOKNAME|{{{1|{{FULLPAGENAME}}}}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>lloy4fm1jzvf8hvj4tiuynvt6q10c3o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKNAME</title>
    <ns>10</ns>
    <id>200630</id>
    <revision>
      <id>3365699</id>
      <parentid>3365668</parentid>
      <timestamp>2018-01-23T20:13:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>moved</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="185" xml:space="preserve">&lt;includeonly&gt;{{BOOKNAME/core|namespace={{ARTICLESPACE:{{{1|{{FULLPAGENAME}}}}}}}|pagename={{PAGENAME:{{{1|{{FULLPAGENAME}}}}}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>2zoc5zvlxanv2krulr6gt7b6cby47sa</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKNAME/core</title>
    <ns>10</ns>
    <id>377904</id>
    <revision>
      <id>3365708</id>
      <parentid>3365674</parentid>
      <timestamp>2018-01-23T20:25:43Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>moved</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="236" xml:space="preserve">{{#switch:{{{namespace}}}
|Template={{#invoke:TScope|override|BOOKNAME/refactor}}
|Category={{#invoke:TScope|override|BOOKNAME/category}}
|#default={{#invoke:TScope|override|BOOKNAME/inbook}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>qi6t884khyp7aou5pr0g0bdratkpv3e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BOOKNAME/inbook</title>
    <ns>10</ns>
    <id>379921</id>
    <revision>
      <id>3415335</id>
      <parentid>3365706</parentid>
      <timestamp>2018-04-22T21:58:27Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>department, shelf</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="523" xml:space="preserve">{{#switch:{{{namespace}}}
|={{#if:{{evalx|
          (let (x (get-arg 2))
            (if (equal? (get-substring x 1 11) "Department:")
                "x"
                (if (equal? (get-substring x 1 6) "Shelf:")
                    "x"
                    "")))
          |{{ucfirst:{{{pagename}}}}}}}
    |Wikibooks Stacks
    |{{#titleparts:{{{pagename}}}|1}}}}
|User    ={{#invoke:TScope|override|BOOKNAME/user}}
|#default={{{namespace}}}:{{#titleparts:{{{pagename}}}|1}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gkue6tkj35d5gklu0t2d6o38tkpp9w6</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Bmbox</title>
    <ns>10</ns>
    <id>151630</id>
    <revision>
      <id>3228919</id>
      <parentid>1764517</parentid>
      <timestamp>2017-06-12T23:26:41Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>JackPotte moved page [[Template:Ambox]] to [[Template:Bmbox]] over redirect: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="944" xml:space="preserve">&lt;!--{{Ambox}} begin--&gt;{{#switch:{{{small|}}}
| left = 
  {{Ambox/core
  | small      = left
  | type       = {{{type|}}}
  | image      = {{#if:{{{smallimage|}}}
                 | {{{smallimage}}}
                 | {{{image|}}}
                 }}
  | imageright = {{#if:{{{smallimageright|}}}
                 | {{{smallimageright}}}
                 | {{{imageright|}}}
                 }}
  | style      = {{{style|}}}
  | textstyle  = {{{textstyle|}}}
  | text       = {{#if:{{{smalltext|}}}
                 | {{{smalltext}}} 
                 | {{{text}}} 
                 }}
  }}
| #default = 
  {{Ambox/core
  | type       = {{{type|}}}
  | image      = {{{image|}}}
  | imageright = {{{imageright|}}}
  | style      = {{{style|}}}
  | textstyle  = {{{textstyle|}}}
  | text       = {{{text}}}
  }}
}}&lt;!--{{Ambox}} end--&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>71dedvqsi5zx5gybeme7bvom2cuhqki</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Bmbox/core</title>
    <ns>10</ns>
    <id>224716</id>
    <revision>
      <id>3228921</id>
      <parentid>2054530</parentid>
      <timestamp>2017-06-12T23:26:42Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>JackPotte moved page [[Template:Ambox/core]] to [[Template:Bmbox/core]]: per discussion</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2195" xml:space="preserve">&lt;table class="metadata plainlinks ambox {{#switch:{{{small|}}}
| left = mbox-small-left
}} {{#switch:{{{type|}}}
| speedy     = ambox-speedy
| delete     = ambox-delete
| content    = ambox-content
| style      = ambox-style
| move       = ambox-move
| protection = ambox-protection
| notice     &lt;!-- notice = default --&gt;
| #default   = ambox-notice
}}" style="{{{style|}}}"&gt;
&lt;tr&gt;
{{#switch:{{{image|}}}
| blank    &lt;!-- Fall back to "none", since deprecated. --&gt;
| none = &lt;td class="mbox-empty-cell"&gt;&lt;/td&gt;   &lt;!-- No image. Cell with some width or padding necessary for text cell to have 100% width. --&gt;
| #default = 
  &lt;td class="mbox-image"&gt;{{
  #switch:{{{small|}}}
  | left = &lt;!-- Don't use the DIV --&gt; 
  | #default = &lt;div style="width: 52px;"&gt; 
  }}
  {{#if:{{{image|}}}
  | {{{image}}}
  | [[File:{{#switch:{{{type|}}}
    | speedy     = Ambox warning pn.svg
    | delete     = Ambox warning pn.svg
    | content    = Book important2.svg
    | style      = Edit-clear.svg
    | move       = Merge-split-transwiki default.svg
    | protection = Padlock-silver-medium.svg
    | notice          &lt;!-- notice = default --&gt;
    | #default   = Information icon4.svg
    }} | {{#switch:{{{small|}}} 
      | left = 20x20px 
      | #default = 40x40px 
      }} |link=|alt=]]
  }}{{#switch:{{{small|}}}
  | left = &lt;!-- Don't use the /DIV --&gt;
  | #default = &lt;/div&gt; 
  }}&lt;/td&gt;
}}
&lt;td class="mbox-text" style="{{{textstyle|}}}"&gt; {{{text}}} &lt;/td&gt;
{{#if:{{{imageright|}}}
| {{#ifeq:{{{imageright|}}}|none
  | &lt;!-- No image. --&gt;
  | &lt;td class="mbox-imageright"&gt;{{#switch:{{{small|}}}
    | left = {{{imageright}}}
    | #default = &lt;div style="width: 52px;"&gt; {{{imageright}}} &lt;/div&gt;
    }}&lt;/td&gt;
  }}
}}
&lt;/tr&gt;
&lt;/table&gt;&lt;!-- 
Detect and report usage with faulty "type" parameter:
--&gt;{{#switch:{{{type|}}}
|   &lt;!-- No type fed, is also valid input --&gt;
| speedy
| delete
| content
| style
| move
| protection
| notice     = &lt;!-- Do nothing, valid "type" --&gt;
| #default   = &lt;div style="text-align: center;"&gt;This message box is using an invalid "type={{{type|}}}" parameter and needs fixing.&lt;/div&gt;
}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories and interwikis to the /doc subpage, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>tb1vy56jqr2f8rxcta3c3zxkitwyn88</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BookCat</title>
    <ns>10</ns>
    <id>133076</id>
    <revision>
      <id>3369509</id>
      <parentid>3369369</parentid>
      <timestamp>2018-01-30T00:44:35Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>fix</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="511" xml:space="preserve">&lt;includeonly&gt;{{#invoke:TScope|shiftLeft|BookCat/core|1
|namespace   ={{#if:{{{1|}}}|{{NAMESPACE:{{{1}}}}}|{{NAMESPACE}}}}
|pagename    ={{#if:{{{1|}}}|{{PAGENAME:{{{1}}}}}|{{PAGENAME}}}}
|fullpagename={{#if:{{{1|}}}|{{{1}}}|{{FULLPAGENAME}}}}
|sortkey     ={{{sort|{{{sortkey|}}}}}}
}}{{#if:{{{1|}}}                  |[[Category:Pages passing page name to BookCat]]}}&lt;!--
--&gt;{{#if:{{{sort|{{{sortkey|}}}}}}|[[Category:Pages passing sort key to BookCat]]}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>nw1barqxaok3ax2jtswg2fq40n07xkm</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BookCat/core</title>
    <ns>10</ns>
    <id>395128</id>
    <revision>
      <id>3415301</id>
      <parentid>3369280</parentid>
      <timestamp>2018-04-22T20:06:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>department, shelf</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="550" xml:space="preserve">&lt;includeonly&gt;{{#invoke:TScope|override|BookCat/{{#switch:{{{namespace}}}
|{{TALKSPACE:{{{namespace}}}:{{{pagename}}}}}=talk
|Category =category
|Subject  =subject
|Template =template
|User     =user
|Wikibooks=category
|={{evalx|
    (let (x (get-arg 2))
      (if (equal? (get-substring x 1 11) "Department:")
          "department"
          (if (equal? (get-substring x 1 6) "Shelf:")
              "shelf"
              "default")))
    |{{ucfirst:{{{pagename}}}}}}}
|#default =default
}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>8tn25ac4mqo1m1z6kwtwsnkadjnnq8d</sha1>
    </revision>
  </page>
  <page>
    <title>Template:BookCat/default</title>
    <ns>10</ns>
    <id>377931</id>
    <revision>
      <id>3369433</id>
      <parentid>3364961</parentid>
      <timestamp>2018-01-29T21:02:08Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="563" xml:space="preserve">&lt;includeonly&gt;{{#ifeq: {{{filing|}}} | deep
|[[{{BOOKCATEGORY|{{{fullpagename}}}|book={{#if:{{#titleparts:{{{fullpagename}}}||2}}|{{#titleparts:{{{fullpagename}}}|-1}}|{{{fullpagename}}}}}}}|{{#if:{{{sortkey|}}}|{{{sortkey}}}|{{#if:{{#titleparts:{{{fullpagename}}}||2}}|{{#titleparts:{{{pagename}}}||-1}}}}}} ]][[Category:Pages with deep filing]]
|[[{{BOOKCATEGORY|{{{fullpagename}}}|book={{NAIVEBOOKNAME|{{{fullpagename}}}}}}}|{{#if:{{{sortkey|}}}|{{{sortkey}}}|{{#titleparts:{{{fullpagename}}}||2}}}} ]]
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>19zdiuubcgqk688r91b773tk23n2n05</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Clear</title>
    <ns>10</ns>
    <id>66016</id>
    <revision>
      <id>1869650</id>
      <parentid>1869626</parentid>
      <timestamp>2010-06-30T17:52:24Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>22 revisions from [[:w:Template:Clear]]: History merge.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="71" xml:space="preserve">&lt;div style="clear: both"&gt;&lt;/div&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>jaabf7wcm14wgw815ggkx670v69i77e</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Evalx</title>
    <ns>10</ns>
    <id>377857</id>
    <revision>
      <id>3149922</id>
      <parentid>3140393</parentid>
      <timestamp>2016-11-18T23:55:55Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Evalx]]": high-impact page ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="116" xml:space="preserve">{{#invoke:{{#if:{{{test-eval|}}}|{{{test-eval}}}|Wikilisp}}|trep|{{{1|}}}}}&lt;noinclude&gt;
{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>gi5tdyhnger0muaubi6cl480g1rg8rt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Existlist</title>
    <ns>10</ns>
    <id>122484</id>
    <revision>
      <id>1618516</id>
      <parentid>988019</parentid>
      <timestamp>2009-08-29T03:34:35Z</timestamp>
      <contributor>
        <username>Adrignola</username>
        <id>169232</id>
      </contributor>
      <minor/>
      <comment>+category</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1663" xml:space="preserve">&lt;includeonly&gt;&lt;!--
--&gt;{{#ifeq:{{{1|}}}|{{{1|+}}}|{{#ifexist:{{#rel2abs:{{{1}}}}}|{{#rel2abs:{{{1}}}}}|&lt;!--
--&gt;{{#ifeq:{{{2|}}}|{{{2|+}}}|{{#ifexist:{{#rel2abs:{{{2}}}}}|{{#rel2abs:{{{2}}}}}|&lt;!--
--&gt;{{#ifeq:{{{3|}}}|{{{3|+}}}|{{#ifexist:{{#rel2abs:{{{3}}}}}|{{#rel2abs:{{{3}}}}}|&lt;!--
--&gt;{{#ifeq:{{{4|}}}|{{{4|+}}}|{{#ifexist:{{#rel2abs:{{{4}}}}}|{{#rel2abs:{{{4}}}}}|&lt;!--
--&gt;{{#ifeq:{{{5|}}}|{{{5|+}}}|{{#ifexist:{{#rel2abs:{{{5}}}}}|{{#rel2abs:{{{5}}}}}|&lt;!--
--&gt;{{#ifeq:{{{6|}}}|{{{6|+}}}|{{#ifexist:{{#rel2abs:{{{6}}}}}|{{#rel2abs:{{{6}}}}}|&lt;!--
--&gt;{{#ifeq:{{{7|}}}|{{{7|+}}}|{{#ifexist:{{#rel2abs:{{{7}}}}}|{{#rel2abs:{{{7}}}}}|&lt;!--
--&gt;{{#ifeq:{{{8|}}}|{{{8|+}}}|{{#ifexist:{{#rel2abs:{{{8}}}}}|{{#rel2abs:{{{8}}}}}|&lt;!--
--&gt;{{#ifeq:{{{9|}}}|{{{9|+}}}|{{#ifexist:{{#rel2abs:{{{9}}}}}|{{#rel2abs:{{{9}}}}}|&lt;!--
--&gt;{{#ifeq:{{{10|}}}|{{{10|+}}}|{{#ifexist:{{#rel2abs:{{{10}}}}}|{{#rel2abs:{{{10}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|{{{else|}}}}}|&lt;!--
--&gt;{{{else|}}}}}|{{{else|}}}}}&lt;!--
--&gt;&lt;/includeonly&gt;&lt;noinclude&gt;
{{esoteric}}

;Example Usage: [[{{tlx|existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}]]
;Result: [[{{existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}]]

;Example Usage: [[{{tlx|existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}|click here]]
;Result: [[{{existlist|A|B|C|Wikibooks:Sandbox|E|F|G}}|click here]]

;What it does: returns the name of the first page which exists up to 10 max.
[[Category:Utility templates|{{PAGENAME}}]]
&lt;/noinclude&gt;</text>
      <sha1>ky5n5d7c3w6km147ef9nw9iawcrdar3</sha1>
    </revision>
  </page>
  <page>
    <title>Template:NAIVEBOOKNAME</title>
    <ns>10</ns>
    <id>153997</id>
    <revision>
      <id>3364930</id>
      <parentid>1767387</parentid>
      <timestamp>2018-01-22T17:55:27Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>Pi zero moved page [[Template:FULLBOOKNAME]] to [[Template:NAIVEBOOKNAME]]: description</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="109" xml:space="preserve">&lt;includeonly&gt;{{#titleparts:{{{1|{{FULLPAGENAME}}}}}|1}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>p6elrbww9zt8w5vven8h68v7asswoj9</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Navigation</title>
    <ns>10</ns>
    <id>37865</id>
    <revision>
      <id>3424891</id>
      <parentid>3363947</parentid>
      <timestamp>2018-05-15T12:53:02Z</timestamp>
      <contributor>
        <username>GKFX</username>
        <id>707936</id>
      </contributor>
      <comment>Prevent error where table start and end tags didn't match on e.g. [[Taxi Language]].</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1232" xml:space="preserve">&lt;includeonly&gt;&lt;!--
START TABLE
--&gt;&lt;table style="width: 100%; clear: both; background-color:#fff !important; border-collapse: collapse; font-size:95%; border: 1px solid rgb(170, 170, 170);" cellpadding="2" class="noprint"&gt;&lt;!--
If on a subpage, show page one level up. --&gt;
{{#ifeq:{{PAGENAME}}|{{BASEPAGENAME}}||
&lt;tr&gt;&lt;td colspan="3" style="text-align: center; font-style: italic;"&gt;[[{{#titleparts:{{FULLPAGENAME}}|-1}}]]&lt;/td&gt;&lt;/tr&gt;}}&lt;!--
End if on subpage.
ROW TWO: --&gt;
&lt;tr&gt;
&lt;td style="text-align: left; width: 33%"&gt;{{#ifeq:{{{previous|BEGINNING}}}|BEGINNING||&amp;nbsp;←&amp;nbsp;[[{{#titleparts:{{FULLPAGENAME}}|1}}/{{{previous}}}|{{{previous}}}]]}}&lt;/td&gt;
&lt;td style="text-align: center; width: 33%"&gt;'''{{SUBPAGENAME}}'''&lt;/td&gt;
&lt;td style="text-align: right; width: 33%"&gt;{{#ifeq:{{{next|END}}}|END||[[{{#titleparts:{{FULLPAGENAME}}|1}}/{{{next}}}|{{{next}}}]]&amp;nbsp;→&amp;nbsp;}}&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;!--
END TABLE
--&gt;{{#if: {{{cat|}}}|[[Category:{{{cat}}}|{{BOOKSORTKEY}}]]|{{BookCat}}}}&lt;/includeonly&gt;&lt;noinclude&gt;{{documentation}}
&lt;!--
Don't forget to change the doc after edits, including the static display copy of this template. (I know, it's not ideal, but this way it's possible to show informative names and the "Book Title.")
--&gt;
&lt;/noinclude&gt;</text>
      <sha1>94s3ml028qho81ljjjgaa23ugup63wq</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Print version cover</title>
    <ns>10</ns>
    <id>110276</id>
    <revision>
      <id>3477419</id>
      <parentid>3419430</parentid>
      <timestamp>2018-10-15T20:11:47Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <comment>[[Special:UncategorizedPages]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="967" xml:space="preserve">&lt;div style="text-align: center; margin: 4em auto;"&gt;
{{{2|}}}

{{#if:{{{authors|}}}|&lt;div style="margin-top: 3em;"&gt;{{{authors}}}&lt;/div&gt;}}
&lt;div style="font-size: 350%; font-weight: bold; margin-top: 1em"&gt;{{{1|{{BASEPAGENAME}} }}}&lt;/div&gt;&lt;/div&gt;

&lt;div style="text-align: center; padding: 5em 5em 0em; border-bottom: 1px solid black"&gt;
The current, editable version of this book is available in Wikibooks, the open-content textbooks collection, at &lt;br&gt;
&lt;span class="plainlinks"&gt;https:{{fullurl:{{BASEPAGENAMEE}}}}&lt;/span&gt;

&lt;div style="font-size: 95%; padding: 1em 5em 2em;"&gt;Permission is granted to copy, distribute, and/or modify this document under the terms of the [[Wikibooks:Creative Commons Attribution-ShareAlike 3.0 Unported License|Creative Commons Attribution-ShareAlike 3.0 License]].&lt;/div&gt;
&lt;/div&gt;&lt;includeonly&gt;
__TOC__
[[Category:Print Versions|{{{1|{{PAGENAME}}}}}]]
&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
[[Category:Print templates|Version cover]]
&lt;/noinclude&gt;</text>
      <sha1>mo8v6utvxo81l902p1wi9pzn5c0iqe1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Print version notice</title>
    <ns>10</ns>
    <id>27932</id>
    <revision>
      <id>3366073</id>
      <parentid>3364335</parentid>
      <timestamp>2018-01-24T16:58:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <comment>BOOKNAME (new-style)</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="402" xml:space="preserve">{{ambox|type=notice|image=[[File:Printer.svg|40x40px]]|text='''This is the [[Help:Print versions|print version]] of [[{{{1|{{BOOKNAME}}}}}]]'''&lt;br/&gt;You won't see this message or any elements not part of the book's content when you print or [{{fullurl:{{existlist|{{{2|{{{1|{{BOOKNAME}}}}}/Print version}}}|{{FULLPAGENAME}}}}|printable=yes}} preview] this page.}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>0t02h1isu1ka7z7xxb4wk9np5o5d7xn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Solution</title>
    <ns>10</ns>
    <id>65016</id>
    <revision>
      <id>3120420</id>
      <parentid>2007701</parentid>
      <timestamp>2016-09-15T22:20:13Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="921" xml:space="preserve">&lt;div style="clear:both;width:{{{width|100%}}};color:#000000;" class="collapsible"&gt;
&lt;div class="title" align="{{{alignT|center}}}"&gt;{{{title|Solution}}}&lt;/div&gt;
&lt;div class="body" align="{{{align|left}}}"&gt;
{{{text|{{{1|}}}}}}
&lt;/div&gt;
&lt;/div&gt;
&lt;noinclude&gt;
&lt;br /&gt;

=Documentation=
==Usage==
This template is named ''solution'' with the first argument being the ''Title'' and the second argument being the ''Text''.

== Examples ==
Let's say the problem is '''1) 2x=4, solve for x.''' 

In this example, the problem is called '''Problem One: Solution''' and the text is the solution to the problem. Make sure to put arguments in quotes.

  &lt;nowiki&gt;{{solution|title="Problem One: Solution"|text="Divide both sides by 2 to get x=2"}}&lt;/nowiki&gt;

This produces: {{solution|title="Problem One: Solution"|text="Divide both sides by 2 to get x=2"}}

[[Category:Collapse templates|{{PAGENAME}}]]

[[ca:Template:Caixa ocultable]]
&lt;/noinclude&gt;</text>
      <sha1>pes5tdh73aa2jjpb1431083qn1g07z4</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Todo</title>
    <ns>10</ns>
    <id>29044</id>
    <revision>
      <id>2458775</id>
      <parentid>2458428</parentid>
      <timestamp>2012-12-11T20:04:37Z</timestamp>
      <contributor>
        <username>Ftiercel</username>
        <id>239666</id>
      </contributor>
      <comment>Fix the model.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="511" xml:space="preserve">&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;{{clear}}
{| style="background: {{{background|#ffd}}}; border: 1px solid #aaaaaa; padding: 6pt; margin: 12pt 8%; width: 60%; margin: auto;" class="notice noprint notice-todo" 
 | style="width: 58px;" | [[Image:Clipboard.svg|45 px|left|alt=Clipboard|link=]]
 |
'''{{{header|{{{title|To do:}}}}}}'''&lt;br /&gt;{{{1&lt;includeonly&gt;|&lt;/includeonly&gt;}}}
|}
&lt;includeonly&gt;{{clear}}&lt;/includeonly&gt;&lt;noinclude&gt;
[[Category:Maintenance templates|{{PAGENAME}}]]
[[pl:Szablon:TODO]]&lt;/noinclude&gt;</text>
      <sha1>a3cduhaiixs20bco9vmdkmjke08v0mq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:TScope</title>
    <ns>828</ns>
    <id>378746</id>
    <revision>
      <id>3149555</id>
      <parentid>3149438</parentid>
      <timestamp>2016-11-18T20:02:41Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Module:TScope]]": high-impact page ([Edit=Allow only administrators] (indefinite) [Move=Allow only administrators] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3756" xml:space="preserve">local export = {}

export.override = function( frame )
	local title = frame.args[1]
	local args = {}
	for v, k in pairs( frame:getParent().args ) do
		args[v] = k
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v ~= 1 then
				args[ v - 1 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.prepend = function( frame )
	local title = frame.args[1]
	local args = {}
	local displace = 0;
	for v, k in pairs( frame.args ) do
		if (type( v ) == "number") and (v ~= 1) then
			args[ v - 1 ] = k
			displace = math.max( displace, (v - 1) )
		end
	end
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) == "number" then
			args[ displace + v ] = k
		else
			args[v] = k
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) ~= "number" then
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.append = function( frame )
	local title = frame.args[1]
	local args = {}
	local displace = 0;
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) == "number" then
			displace = math.max( displace, v )
		end
		args[v] = k
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v ~= 1 then
				args[ displace + v - 1 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.drop = function( frame )
	local title = frame.args[1]
	local args = {}
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) ~= "number" then
			args[v] = k
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v ~= 1 then
				args[ v - 1 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.shiftLeft = function( frame )
	local title = frame.args[1]
	local args = {}
	local displace = tonumber( frame.args[2] )
	if displace == nil then displace = 0 end
	for v, k in pairs( frame:getParent().args ) do
		if type( v ) == "number" then
			if v &gt;= displace then
				args[ v - displace ] = k
			end
		else
			args[v] = k
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) == "number" then
			if v &gt; 2 then
				args[ v - 2 ] = k
			end
		else
			args[v] = k
		end
	end
	return frame:expandTemplate{ title = title, args = args }
end

export.map = function( frame )
	local title = frame.args[1]
	local displace = frame.args[2]
	if displace == nil then
		displace = 0
	else
		displace = tonumber( displace )
	end
	local args = {}
	local data = {}
	local maxv = 0
	for v, k in pairs( frame:getParent().args ) do
		if (type( v ) ~= "number") then
			args[v] = k
		elseif v &lt;= displace then
			args[v + 1] = k
		else
			data[v] = k
			maxv = math.max( v, maxv )
		end
	end
	for v, k in pairs( frame.args ) do
		if type( v ) ~= "number" then
			args[v] = k
		elseif v &gt; 2 then
			args[v - 1] = k
		end
	end
	local result = ""
	for v = 1, maxv do
		if data[v] ~= nil then
			args[1] = data[v]
			result = result .. frame:expandTemplate{ title = title, args = args }
		end
	end
	return result
end

export.static = function( frame )
	return frame:getParent():getTitle()
end

local function tabulate( args )
	local s = ''
	for k, v in pairs( args ) do
		s = s .. '|-\n| ' .. k .. '\n| &lt;code&gt;' .. v .. '&lt;/code&gt;\n'
	end
	if s ~= '' then
		s = '{| class="wikitable"\n|-\n! key\n! value\n' .. s .. '|}'
	end
	return s
end

export.echo = function( frame )
	local mp = tabulate( frame.args )
	local cp = tabulate( frame:getParent().args )
	if mp ~= '' then
		mp = 'module parameters:\n' .. mp .. '\n'
	end
	if cp ~= '' then
		cp = 'context parameters:\n' .. cp .. '\n'
	else
		cp = 'no context parameters.\n'
	end
	return mp .. cp
end

return export</text>
      <sha1>n3blx1g9jcetmcolf1n2fiuhyaql9nh</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wikilisp</title>
    <ns>828</ns>
    <id>377838</id>
    <revision>
      <id>3182515</id>
      <parentid>3182514</parentid>
      <timestamp>2017-02-14T18:13:35Z</timestamp>
      <contributor>
        <username>Pi zero</username>
        <id>75960</id>
      </contributor>
      <minor/>
      <comment>1 revision imported from [[:n:Module:Wikilisp]]: update</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="47989" xml:space="preserve">local export = {}

local wikilispversion = "0.18 (February 14, 2017)"

--[[ some basic abstractions ]]

local function stype( x ) -- type of sexpr
	local t = type( x )
	if t == "table" then t = x.type end
	return t
end

local function seterr( x, ... )
	if type(x) ~= "table" then
		return seterr( {}, x, ... )
	else
		x.type = "error"
		x.msg = mw.ustring.format( ... )
		return x
	end
end

--[[ parse text to a sequence of sexprs ]]

local function tok3( ls, t )
	-- tokenize lua string t, with no string literals comments or parens;
	--   append to ls
	local p1,p2 = mw.ustring.find( t, "[^%s]+" )
	while p1 ~= nil do
		local t1 = mw.ustring.sub(t, p1, p2)
		local n1 = tonumber(t1)
		if n1 ~= nil then
			ls[1 + #ls] = n1
		elseif t1 == "true" then
			ls[1 + #ls] = true
		elseif t1 == "false" then
			ls[1 + #ls] = false
		else
			ls[1 + #ls] = {
				type = "symbol",
				name = t1
			}
		end
		t = mw.ustring.sub(t, (p2 + 1))
		p1,p2 = mw.ustring.find( t, "[^%s]+" )
	end
end

local function tok2( ls, t )
	-- tokenize lua string t, with no string literals or comments; append to ls
	local p1 = mw.ustring.find( t, "[()\\]" )
	while p1 ~= nil do
		tok3( ls, mw.ustring.sub(t, 1, (p1 - 1)) )
		ls[1 + #ls] = { type = mw.ustring.sub(t, p1, p1) }
		if ls[#ls].type == "\\" then
			ls[#ls].name = ls[#ls].type
			ls[#ls].type = "symbol"
		end
		t = mw.ustring.sub(t, (p1 + 1))
		p1 = mw.ustring.find( t, "[()\\]" )
	end
	tok3( ls, t )
end

local function tok1( ls, t )
	-- tokenize lua string t, thru first string literal or comment; append to ls
	-- if not finished, append untokenized remainder string and return true
	local p0 = mw.ustring.find( t, ';' )
	local p1 = mw.ustring.find( t, '"' )
	local p2 = mw.ustring.find( t, "'" )
	if (p0 ~= nil) and (((p1 == nil) or (p0 &lt; p1)) and
						((p2 == nil) or (p0 &lt; p2))) then
		tok2( ls, mw.ustring.sub( t, 1, (p0 - 1) ) )
		p1 = mw.ustring.find( t, '\n', (p0 + 1) )
		if p1 == nil then
			return false
		else
			ls[1 + #ls] = mw.ustring.sub( t, (p1 + 1) )
			return true
		end
	elseif (p1 ~= nil) and ((p2 == nil) or (p1 &lt; p2)) then
		p2 = p1 + 1
		while true do
			p2 = mw.ustring.find( t, '"', p2 )
			if p2 == nil then
				seterr(ls, 'mismatched string-literal delimiter (")')
				return false
			elseif (p2 &lt; mw.ustring.len( t )) and
				(mw.ustring.codepoint( t, (p2 + 1) ) == 34)
			then
				p2 = (p2 + 2)
			else
				tok2( ls, mw.ustring.sub( t, 1, (p1 - 1) ) )
				ls[1 + #ls] = mw.ustring.gsub(
					mw.ustring.sub( t, (p1 + 1), (p2 - 1) ),
					'""', '"')
				ls[1 + #ls] = mw.ustring.sub( t, (p2 + 1) )
				return true
			end
		end
	elseif p2 ~= nil then
		-- side benefit: precludes Lisp shorthand for "suppress eval"
		p1 = p2
		p2 = mw.ustring.find( t, "'", (p1 + 1) )
		if p2 == nil then
			seterr(ls, "mismatched string-literal delimiter (')")
			return false
		else
			tok2( ls, mw.ustring.sub( t, 1, (p1 - 1) ) )
			ls[1 + #ls] = mw.ustring.sub( t, (p1 + 1), (p2 - 1) )
			ls[1 + #ls] = mw.ustring.sub( t, (p2 + 1) )
			return true
		end
	else
		tok2( ls, t )
		return false
	end
end

local function parse_next( x1, p1, x2 )
	-- parse one sexpr from token list x1 position p1, append sexpr to p2
	-- return new value for p1
	if stype(x1[p1]) == ")" then
		seterr(x2, "unmatched right-paren")
		return 1 + #x1
	elseif stype(x1[p1]) ~= "(" then
		x2[1 + #x2] = x1[p1]
		return p1 + 1
	else
		p1 = p1 + 1
		local x3 = { type = "list" }
		x2[1 + #x2] = x3
		while p1 &lt;= #x1 do
			if stype(x1[p1]) == ")" then
				return p1 + 1
			end
			p1 = parse_next( x1, p1, x3 )
		end
		seterr(x2, "unmatched left-paren")
		return p1
	end
end

local function parse_sexpr( x1 )
	-- x1 is an error or a list of tokens
	if x1.type ~= "list" then
		return x1
	else
		local p1 = 1 --next item to read from x1
		local x2 = { type = "list" }
		while p1 &lt;= #x1 do
			p1 = parse_next( x1, p1, x2 )
		end
		return x2
	end
end

local function text_to_sexpr( t )
	local ls = { type = "list" }
	while tok1( ls, t ) do
		t = ls[#ls]
		ls[#ls] = nil
	end
	ls = parse_sexpr( ls )
	return ls
end

--[[ write/display a sexpr ]]

local function write_sexpr( x )
	if type(x) == "number" then
		return tostring( x )
	elseif type(x) == "string" then
		return mw.ustring.format('"%s"', mw.ustring.gsub( x, '"', '""' ))
	elseif type(x) == "boolean" then
		if x then return "true" else return "false" end
	elseif type(x) ~= "table" then
		return mw.ustring.format("&amp;lt;unrecognized internal type: %s&amp;gt;", type(x))
	elseif x.type == "symbol" then
		return x.name
	elseif x.type == "fn" then
		return mw.ustring.format("&amp;lt;%s&amp;gt;", write_sexpr( x.comb ))
	elseif x.type == "op" then
		if x.name ~= nil then
			return mw.ustring.format("[op: %s]", x.name)
		else
			return "[op]"
		end
	elseif x.type == "list" then
		local r = {}
		r[1] = "("
		for k = 1, #x do
			r[k+1] = write_sexpr( x[k] )
		end
		r[#r + 1] = ")"
		return table.concat(r, " ")
	elseif x.type == "error" then
		return mw.ustring.format("&amp;lt;error: %s&amp;gt;", x.msg)
	elseif x.type == "pattern" then
		return mw.ustring.format('&amp;lt;pattern: "%s"&amp;gt;', x.pat)
	elseif x.type ~= nil then
		return mw.ustring.format("&amp;lt;unrecognized type: %s&amp;gt;", x.type)
	else
		return "&amp;lt;missing type&amp;gt;"
	end
end

local function display_sexpr( x )
	if stype(x) == "string" then
		return x
	else
		return write_sexpr( x )
	end
end

--[[ evaluation tools ]]

local maxdepth = 4 -- maximum call-nesting depth

local combine

local function eval( x, env, depth )
	if type(x) ~= "table" then -- literal
		return x
	elseif x.type == "symbol" then
		local v = env[x.name]
		if v == nil then
			return seterr("undefined symbol: %s", x.name)
		else
			return v
		end
	elseif x.type ~= "list" then -- literal
		return x
	elseif #x == 0 then -- empty list
		return x
	else -- combination
		local c = eval( x[1], env, depth )
		if stype(c) == "error" then return c end
		local ls = { type = "list" }
		for k = 2, #x do
			ls[k - 1] = x[k]
		end
		return combine( c, ls, env, depth )
	end
end

combine = function( c, ls, env, depth )
	while stype(c) == "fn" do
		local ls2 = { type = "list" }
		for k = 1, #ls do
			ls2[k] = eval( ls[k], env, depth )
			if stype(ls2[k]) == "error" then return ls2[k] end
		end
		c = c.comb
		ls = ls2
	end
	if stype(c) ~= "op" then
		return seterr("called object is not a combiner: %s", write_sexpr(c))
	elseif (c.shallow ~= nil) then
		return c.op(ls, env, depth)
	elseif (depth == nil) or (depth &lt; 1) then
		if maxdepth &gt; 1 then
			return seterr(
				"exceeded maximum call-nesting depth (%i)",
				maxdepth)
		else
			return seterr("exceeded maximum call-nesting depth")
		end
	else
		return c.op(ls, env, (depth - 1))
	end
end

local function eval_seq( ls, env, depth )
	-- ls must be an error or a list
	if ls.type == "error" then return ls end
	if #ls == 0 then return ls end
	for k = 1, (#ls - 1) do
		local x = eval( ls[k], env, depth )
		if stype(x) == "error" then return x end
	end
	return eval( ls[#ls], env, depth )
end

local function eval_all( ls, env, depth, cutoff )
	-- ls must be an error or a list
	if ls.type == "error" then return ls end
	local ls2 = { type="list" }
	for k = 1, #ls do
		ls2[k] = eval( ls[k], env, depth )
		if stype(ls2[k]) == "error" then return ls2[k] end
		if (cutoff ~= nil) and cutoff(ls2[k]) then return ls2 end
	end
	return ls2
end

local function combine_all( ops, args, env, depth, cutoff )
	-- ops must be a list; args must be an error or a list
	if args.type == "error" then return args end
	local ls2 = { type="list" }
	for k = 1, #ops do
		ls2[k] = combine( ops[k], args, env, depth )
		if stype(ls2[k]) == "error" then return ls2[k] end
		if (cutoff ~= nil) and cutoff(ls2[k]) then return ls2 end
	end
	return ls2
end

--[[ generic combiner constructors ]]

local function make_op( f, nm, sh )
	return {
		type = "op",
		op = f,
		name = nm,
		shallow = sh
	}
end

local function checktype( t, o, k ) -- types list, operands list, index
	if #t == 0 then return "" end
	o = o[k] -- particular operand
	if k &gt; #t then k = #t end
	t = t[k] -- particular type
	-- t should now be a string or internal function
	if type(t) == "string" then
		if stype(o) == t then t = "" end -- clear if no error
	else
		t = t(o) -- assume internal function works correctly
	end
	-- t should now be type name if error, empty string if okay
	return t
end

local function type_err( cname, tname, x )
	-- combiner name, type name(s), operand
	-- type name may be a string or an array of strings
	local where = ""
	if cname ~= nil then where = " to [op: " .. cname .. "]" end
	if type(tname) == "table" then
		if #tname == 0 then tname = "[unknown]"
		else
			for k = 1, #tname do
				while tname[k] == "" do
					for j = (k + 1), #tname do tname[j - 1] = tname[j] end
					tname[#tname] = nil
				end
				if tname[k] ~= nil then
					for j = (k + 1), #tname do
						if tname[k] == tname[j] then tname[j] = "" end
					end
				end
			end
			if #tname == 1 then tname = tname[1]
			else
				tname[#tname] = "or " .. tname[#tname]
				if #tname == 2
				then tname = table.concat( tname, " " )
				else tname = table.concat( tname, ", " )
				end
			end
		end
	end
	local what = write_sexpr(x)
	if #what &gt; 64 then what = stype(x) end
	return seterr(
		"bad operand%s: expected %s, got %s", where, tname, what)
end

local function typed_op( ... )
	-- alternating type (string or function) and op (table or function)
	-- strong recommendation: first op should be a table
	local ls0 = { ... }
	local n0 = select( '#', ... )
	local opname, shallow
	if type(ls0[2]) == "table" then
		opname = ls0[2].name
		shallow = ls0[2].shallow
	end
	local f = function(ls, env, depth)
		if #ls == 0 then
			local op = ls0[2]
			if type(op) == "table" then op = op.op end
			return op( ls, env, depth )
		end
		local ek = 1 -- operand number of accumulated error type names
		local enames = {} -- list of failed types for ls[ek]
		for j = 1, n0, 2 do
			local types = ls0[j]
			local op = ls0[j + 1]
			if type(op) == "table" then op = op.op end
			local t = ""
			for k = 1, #ls do
				if #t == 0 then
					t = checktype( types, ls, k )
					if #t &gt; 0 then
						if k &gt; ek then
							ek = k
							enames = { t }
						elseif k == ek then
							enames[1 + #enames] = t
						end
					end
				end
			end
			if #t == 0 then return op( ls, env, depth ) end
		end
		return type_err( opname, enames, ls[ek] )
	end
	return make_op( f, opname, shallow )
end

local function nary_op( c, n, m )
	local f = function(ls, env, depth)
		if n &lt; 0 then
			if #ls &lt; -n then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"too few operands%s: expected at least %i, got %i",
					where, -n, #ls)
			end
		elseif m == nil then
			if #ls ~= n then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"wrong number of operands%s: expected %i, got %i",
					where, n, #ls)
			end
		else
			if #ls &lt; n then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"too few operands%s: expected at least %i, got %i",
					where, n, #ls)
			elseif #ls &gt; m then
				local where = ""
				if c.name ~= nil then where = " to [op: " .. c.name .. "]" end
				return seterr(
					"too many operands%s: expected at most %i, got %i",
					where, m, #ls)
			end
		end
		return c.op( ls, env, depth )
	end
	return make_op( f, c.name, c.shallow )
end

local function binary_pred( test, nm )
	return make_op(function (ls)
			for k = 2, #ls do
				if not test(ls[k - 1], ls[k]) then
					return false
				end
			end
			return true
		end, nm, true)
end

local function unary_pred( test, nm )
	return make_op(function (ls)
			for k = 1, #ls do
				if not test(ls[k]) then
					return false
				end
			end
			return true
		end, nm, true)
end

local function wrap( c )
	return {
		type = "fn",
		comb = c
	}
end

--[[ wiki parsing stuff
	entry:  (char-code  (first-pos  last-pos  left-index))
	        (descriptor  (first-pos  last-pos  left-index)  entry  entry  ...)
	item entries contain part entries, part entries contain item entries
	left-index is removed at end of parse
]]

local lsquare,rsquare, lcurly,rcurly, pipe = 91,93, 123,125, 124

local function wikileft(e) -- is entry a left-delimiter?
	return ((e[1] == lsquare) or (e[1] == lcurly)) and (e[2][1] ~= e[2][2])
end

local function wikilen(e) -- how long is this entry?
	return 1 + e[2][2] - e[2][1]
end

local function wikisub( m, d ) -- parse, descriptor
	local k2 = #m          -- index of right delimiter
	local k1 = m[k2][2][3] -- index of left delimiter
	local p = { type = "list", "part", { type = "list" } } -- first part
	p[2][1] = (m[k1][2][2] + 1) -- start of first part
	local e = { -- entry containing parts
		type = "list",
		d,
		{ type = "list",
		  (m[k1][2][2] - (m[k2][2][2] - m[k2][2][1])),
		  m[k2][2][2],
		  k1
		},
		p
	}
	for k = (k1 + 1), (k2 - 1) do
		if type(m[k][1]) ~= "number" then
			m[k][2][3] = nil
			p[1 + #p] = m[k]
		elseif m[k][1] == pipe then
			p[2][2] = (m[k][2][1] - 1) -- end of current part
			p = { type = "list", "part", { type = "list" } } -- next part
			p[2][1] = (m[k][2][2] + 1) -- start of this part
			e[1 + #e] = p -- add to list of parts
		end
		m[k] = nil
	end
	p[2][2] = (m[k2][2][1] - 1) -- end of last part
	m[k2] = nil
	m[k1][2][2] = (e[2][1] - 1)
	if (m[k1][2][1] &gt; m[k1][2][2]) then
		e[2][3] = m[k1][2][3]
		m[k1] = nil
	end
	m[1 + #m] = e
end

local function parse_wiki( ls )
	local s = ls[1]                             -- string to parse
	local m = { type = "list" }                 -- result of parse
	local k = mw.ustring.find( s, "[%[%]{}|]" ) -- position in string
	while k ~= nil do
		local c = mw.ustring.codepoint(s,k)
		if #m == 0 then
			if (c == lsquare) or (c == lcurly) then
				m[1] = {type="list", c, {type="list", k, k, 0}}
			end
		elseif (k == (m[#m][2][2] + 1)) and (c == m[#m][1]) and (c ~= pipe) then
			m[#m][2][2] = k
			if m[#m][2][3] &gt; 0 then
				local e2 = m[#m]
				local e1 = m[e2[2][3]]
				if (e2[1] == rcurly) and (e1[1] == lcurly) and
					(wikilen(e2) == 3) and (wikilen(e1) &gt; 2)
				then
					wikisub( m, "param" )
				elseif (e2[1] == rsquare) and (e1[1] == lsquare) and
					(wikilen(e2) == 2) and (wikilen(e1) &gt; 1)
				then
					wikisub( m, "link" )
				end
			end
		else
			if m[#m][2][3] &gt; 0 then
				local e2 = m[#m]
				local e1 = m[e2[2][3]]
				if (e2[1] == rcurly) and (e1[1] == lcurly) and
					(wikilen(e2) == 2) and (wikilen(e1) &gt; 1)
				then
					wikisub( m, "call" )
				end
			end
			m[1 + #m] = {type="list", c, {type="list", k, k}}
			if wikileft(m[#m - 1]) then
				m[#m][2][3] = (#m - 1)
			else
				m[#m][2][3] = m[#m - 1][2][3]
			end
		end
		k = mw.ustring.find( s, "[%[%]{}|]", (k + 1) )
	end
	if #m == 0 then return m end
	if m[#m][2][3] &gt; 0 then
		local e2 = m[#m]
		local e1 = m[e2[2][3]]
		if (e2[1] == rcurly) and (e1[1] == lcurly) and
			(wikilen(e2) == 2) and (wikilen(e1) &gt; 1)
		then
			wikisub( m, "call" )
		end
	end
	local m2 = { type = "list" }
	for j = 1, #m do
		if type(m[j][1]) ~= "number" then
			m[j][2][3] = nil
			m2[1 + #m2] = m[j]
		end
	end
	return m2
end

--[[ miscellaneous ]]

local function int_tc(x)
	if (type(x) ~= "number") or (x ~= math.floor(x)) then
		return "integer"
	else
		return ""
	end
end

local function posint_tc(x)
	if (type(x) ~= "number") or (x ~= math.floor(x)) or (x &lt; 1) then
		return "positive integer"
	else
		return ""
	end
end

local function logical_and( ls ) -- for and?
	for k = 1, #ls do
		if stype(ls[k]) ~= "boolean" then
			return seterr(
				"bad operand to [op: and?]: expected boolean, got %s",
				write_sexpr(ls[k]))
		end
	end
	for k = 1, #ls do if not ls[k] then return false end end
	return true
end

local function logical_or( ls ) -- for or?
	for k = 1, #ls do
		if stype(ls[k]) ~= "boolean" then
			return seterr(
				"bad operand to [op: or?]: expected boolean, got %s",
				write_sexpr(ls[k]))
		end
	end
	for k = 1, #ls do if ls[k] then return true end end
	return false
end

local function and_fn(ls, env, depth)
	ls = eval_all( ls, env, depth,
		function (x)
			return (stype(x) == "boolean") and not x
		end)
	if stype(ls) == "error" then return ls end
	if (#ls == 0) or (stype(ls[1]) == "boolean") then
		return logical_and(ls)
	end
	local ops = { type="list" }
	for k = 1, #ls do
		if stype(ls[k]) == "fn" then ops[k] = ls[k].comb
		elseif stype(ls[k]) == "op" then ops[k] = ls[k]
		elseif k == 1 then
			return seterr(
				"bad operand to [op: and?]: expected boolean or combiner, got %s",
				write_sexpr(ls[k]))
		else
			return seterr(
				"bad operand to [op: and?]: expected combiner, got %s",
				write_sexpr(ls[k]))
		end
	end
	return wrap(make_op(function (ls, env, depth)
			ls = combine_all(ops, ls, env, depth,
				function (x)
					return (stype(x) ~= "boolean") or not x
				end)
			if ls.type == "error" then return ls end
			return logical_and(ls)
		end, "and?", true))
end

local function or_fn(ls, env, depth)
	ls = eval_all(ls, env, depth,
		function (x)
			return (stype(x) == "boolean") and x
		end)
	if stype(ls) == "error" then return ls end
	if (#ls == 0) or (stype(ls[1]) == "boolean") then
		return logical_or(ls)
	end
	local ops = { type="list" }
	for k = 1, #ls do
		if stype(ls[k]) == "fn" then ops[k] = ls[k].comb
		elseif stype(ls[k]) == "op" then ops[k] = ls[k]
		elseif k == 1 then
			return seterr(
				"bad operand to [op: or?]: expected boolean or combiner, got %s",
				write_sexpr(ls[k]))
		else
			return seterr(
				"bad operand to [op: or?]: expected combiner, got %s",
				write_sexpr(ls[k]))
		end
	end
	return wrap(make_op(function (ls, env, depth)
			ls = combine_all(ops, ls, env, depth,
				function (x)
					return (stype(x) ~= "boolean") or x
				end)
			if ls.type == "error" then return ls end
			return logical_or(ls)
		end, "or?", true))
end

local function valid_parmlist( ls ) -- for \
	if stype(ls) ~= "list" then return false end
	for k = 1, #ls do
		if stype(ls[k]) ~= "symbol" then return false end
	end
	return true
end

local function match_parmlist( parms, ls ) -- for \
	local env = {}
	for k = 1, #parms do env[parms[k].name] = ls[k] end
	return env
end

local function lambda_fn(ls, senv)
	local parms = ls[1]
	if stype(parms) == "symbol" then
		parms = { type="list", parms }
	elseif not valid_parmlist(parms) then
		return seterr(
			"bad parameter-list operand to [op: \\]: %s",
			write_sexpr(parms))
	end
	local body = { type = "list" }
	for k = 2, #ls do body[k - 1] = ls[k] end
	return wrap(nary_op(make_op(function (ls, denv, depth)
		-- denv is ignored
		local env = match_parmlist( parms, ls )
		setmetatable(env, { __index = senv })
		return eval_seq(body, env, depth)
	end), #parms))
end

local relevantFrame = mw.getCurrentFrame()

local function getarg_fn(ls)
	local args = relevantFrame.args
	local t = nil
	if stype(ls[1]) == "number" then
		t = ls[1]
	else -- must be number or string
		t = ls[1]
	end
	t = args[t]
	if t == nil then return { type = "list" } end
	return t
end

local function getargexpr_fn(ls)
	local args = relevantFrame.args
	local t = nil
	if stype(ls[1]) == "number" then
		t = ls[1]
	else -- must be number or string
		t = ls[1]
	end
	t = args[t]
	if t == nil then return { type = "list" } end
	t = text_to_sexpr(t)
	if stype(t) == "error" then return { type = "list" } end
	if #t ~= 1 then return { type = "list" } end
	return t[1]
end

local function filter_fn(ls, env, depth)
	local preds = { type = "list" }
	for k = 2, #ls do preds[k - 1] = ls[k].comb end -- predicates
	local function hof(ls, n, f, app)
		-- copy first n elements of ls, apply f to later elements
		-- if app, instead skip first n, and return result,app
		if app == nil then app = false end
		local ls2 = { type = "list" }
		if #ls &lt;= n then
			if app then return ls2,app else return ls end
		end
		if not app then for k = 1, n do ls2[k] = ls[k] end end
		for k = (n + 1), #ls do
			local x,app2 = f(ls[k])
			if stype(x) == "error" then return x end
			if app2 == nil then app2 = false end
			if app2 then
				for j = 1, #x do ls2[1 + #ls2] = x[j] end
			else
				ls2[1 + #ls2] = x
			end
		end
		return ls2,app
	end
	local function filter_entry(entry)
		local b = combine_all(preds, {type="list", entry}, env, depth,
			function (x)
				return (stype(x) ~= "boolean") or not x
			end)
		if stype(b) == "error" then return b end
		b = logical_and(b)
		if stype(b) == "error" then return b end
		if b then
			if stype(entry) == "list" then
				return hof(entry, 2, function (part)
						return hof(part, 2, filter_entry)
					end)
			else
				return entry
			end
		else
			if stype(entry) == "list" then
				return hof(entry, 2, function (part)
						return hof(part, 2, filter_entry, true)
					end, true)
			else
				return { type = "list" }, true
			end
		end
	end
	return hof(ls[1], 0, filter_entry)
end

local function item_tc(x)
	if (stype(x) == "list") and (#x &gt; 1) and
		(stype(x[1]) == "string") and (x[1] ~= "part") and
		(stype(x[2]) == "list") and (#x[2] == 2) and
		(int_tc(x[2][1]) == "") and (int_tc(x[2][2]) == "")
	then
		return ""
	else
		return "item"
	end
end

local function part_tc(x)
	if (stype(x) == "list") and (#x &gt; 1) and (x[1] == "part") and
		(stype(x[2]) == "list") and (#x[2] == 2) and
		(int_tc(x[2][1]) == "") and (int_tc(x[2][2]) == "")
	then
		return ""
	else
		return "part"
	end
end

local function cd_tc(x)
	if (stype(x) == "list") and (#x &gt; 0) then
		if stype(x[1]) == "string" then x = x[2] end
		if (x ~= nil) and (stype(x) == "list") and (#x == 2) and
			(int_tc(x[1]) == "") and (int_tc(x[2]) == "")
		then
			return ""
		end
	end
	return "coordinates descriptor"
end

local function cd_ls_tc(x)
	local ok = true
	if stype(x) ~= "list" then ok = false
	else for k = 1, #x do if cd_tc(x[k]) ~= "" then ok = false end end
	end
	if ok then return ""
	else return "list of coordinates descriptors"
	end
end

local function getsubstr_ntv(s, k1, k2) -- k1, k2 ints if provided
	if k1 == nil then return s end
	if k1 &lt; 1 then k1 = 1 end
	if k2 ~= nil then
		if k2 &gt;= mw.ustring.len(s) then k2 = nil end
	end
	return mw.ustring.sub( s, k1, k2 )
end

local function cd_norm(x) -- assumes cd_tc
	if stype(x[1]) == "number" then return x else return x[2] end
end

local function getsubstr_int_fn(ls)
	local s = ls[1]
	return getsubstr_ntv(s, ls[2], ls[3])
end

local function getsubstr_cd_fn(ls)
	local s = ls[1]
	local c = cd_norm(ls[2])
	return getsubstr_ntv(s, c[1], c[2])
end

local function getsubstr_ls_fn(ls)
	local s = ls[1]
	local r = { type = "list" }
	for k = 1, #ls[2] do
		r[k] = cd_norm(ls[2][k])
	end
	for k = 1, #r do r[k] = getsubstr_ntv(s, r[k][1], r[k][2]) end
	return r
end

local function setsubstr_ls(s, lsc, lss)
	-- string, array of cds, array of strings
	local n = math.min(#lsc, #lss) -- just ignore extras of either
	if n == 0 then return s end
	local function berr(...)
		return seterr("bounds violation in [op: set-substring]: %s",
			mw.ustring.format( ... ))
	end
	if lsc[1][1] &lt; 1 then
		return berr("segment starts left of string start (%i)", lsc[1][1])
	end
	if lsc[n][2] &gt; mw.ustring.len(s) then
		return berr("segment ends right of string end (%i, %i)",
			lsc[n][2], mw.ustring.len(s))
	end
	local r = {}
	for k = 1, n do
		if lsc[k][1] &gt; (lsc[k][2] + 1) then
			return berr("segment starts right of its own end (%i, %i)",
				lsc[k][1], lsc[k][2])
		end
		r[2 * k] = lss[k]
	end
	r[1] = mw.ustring.sub(s, 1, (lsc[1][1] - 1))
	r[1 + (2 * n)] = mw.ustring.sub(s, (lsc[n][2] + 1))
	for k = 2, n do
		if lsc[k - 1][2] &gt;= lsc[k][1] then
			return berr("segment ends right of next segment start (%i, %i)",
				lsc[k - 1][2], lsc[k][1])
		end
		r[(2 * k) - 1] = mw.ustring.sub(s,
			(lsc[k - 1][2] + 1),
			(lsc[k][1] - 1))
	end
	return table.concat(r)
end

local function str_ls_tc(x)
	local ok = true
	if stype(x) ~= "list" then ok = false
	else for k = 1, #x do if stype(x[k]) ~= "string" then ok = false end end
	end
	if ok then return ""
	else return "list of strings"
	end
end

local function getsublist_fn(ls)
	local n1 = ls[2]
	local n2 = ls[3]
	local ls = ls[1]
	local x = { type = "list" }
	if n1 &lt; 1 then n1 = 1 end
	if n2 == nil then n2 = #ls elseif n2 &gt; #ls then ns = #ls end
	for k = n1, n2 do x[1 + #x] = ls[k] end
	return x
end

local function setsublist_fn(ls)
	local base = ls[1]
	local n1 = ls[2] - 1
	local n2 = ls[3] + 1
	local seg = ls[4]
	if n1 &lt; 0 then n1 = 0 end
	if n2 &lt;= n1 then n2 = n1 + 1 end
	local r = { type = "list" }
	for k = 1, n1 do r[k] = base[k] end
	for k = 1, #seg do r[1 + #r] = seg[k] end
	for k = n2, #base do r[1 + #r] = base[k] end
	return r
end

local function findprd_fn(ls, env, depth)
	local x = ls[1]
	local p = ls[2].comb
	local x2 = { type = "list" }
	for k = 1, #x do
		local q = combine( p, { type="list", x[k] }, env, depth )
		if stype(q) == "error" then return q end
		if stype(q) ~= "boolean" then
			return seterr(
				"bad predicate result type to [op: find]: got %s",
				stype(q))
		end
		if q then x2[1 + #x2] = k end
	end
	return x2
end

local function findstr_fn(ls)
	local s = ls[1]
	local p = ls[2]
	local x2 = { type = "list" }
	if #p == 0 then return x2 end
	local k = 1
	repeat
		local x3 = { mw.ustring.find( s, p, k, true ) }
		if #x3 == 0 then return x2 end
		x2[1 + #x2] = { type = "list", x3[1], x3[2] }
		k = 1 + x3[2]
	until false
end

local function findpat_fn(ls)
	local s = ls[1]
	local p = ls[2].pat
	local x2 = { type = "list" }
	local k = 1
	repeat
		local x3 = { mw.ustring.find( s, p, k ) }
		if #x3 == 0 then return x2 end
		x2[1 + #x2] = { type = "list", x3[1], x3[2] }
		k = 1 + x3[2]
	until false
end

local function any_tc(x) return "" end
local function none_tc(x) return "no operand here" end

local function member_fn(ls) -- 1 or 2 operands, second must be a list
	local t = write_sexpr(ls[1])
	if ls[2] ~= nil then
		ls = ls[2]
		for k = 1, #ls do
			if write_sexpr(ls[k]) == t then return true end
		end
		return false
	else
		return wrap(nary_op(typed_op({ "list" }, make_op(function(ls)
			ls = ls[1]
			for k = 1, #ls do
				if write_sexpr(ls[k]) == t then return true end
			end
			return false
		end, nil, true)), 1))
	end
end

local lang = mw.language.getContentLanguage()

local function let_tc(x)
	if (stype(x) == "list") and (#x == 2) and (stype(x[1]) == "symbol")
	then return ""
	else return "symbol-value binding"
	end
end

local function sorp_tc(x)
	if (stype(x) == "string") or (stype(x) == "pattern")
	then return ""
	else return "string or pattern"
	end
end

local function split_tc(x)
	if (stype(x) == "list") and (#x &gt;= 1) and (sorp_tc(x[1]) == "") and
		((#x == 1) or
		 ((#x == 2) and ((sorp_tc(x[2]) == "") or (split_tc(x[2]) == ""))) or
		 ((#x == 3) and (sorp_tc(x[2]) == "") and (split_tc(x[3]) == "")))
	then
		return ""
	else
		return "valid string-split descriptor"
	end
end

local function strnest_tc(x)
	if stype(x) == "string" then return ""
	elseif stype(x) == "list" then
		for k = 1, #x do
			local msg = strnest_tc(x[k])
			if msg ~= "" then return msg end
		end
		return ""
	end
	return "string or tree of strings"
end

local function splitsep_fn(s, p)
	local x
	if (stype(p) == "string")
	then x = mw.text.split( s, p, true )
	else x = mw.text.split( s, p.pat )
	end
	x.type = "list"
	return x
end

local function splitdelim_fn(s, lt, rt)
	local lp = (stype(lt) == "string")
	local rp = (stype(rt) == "string")
	if not lp then lt = lt.pat end
	if not rp then rt = rt.pat end
	local snarf -- find next unmatched right-delimiter
	snarf = function (k)
		repeat
			local xl = { mw.ustring.find( s, lt, k, lp ) }
			local xr = { mw.ustring.find( s, rt, k, rp ) }
			if #xr == 0 then return xr end
			if #xl == 0 then return xr end
			if xr[1] &lt;= xl[1] then return xr end
			xr = snarf(xl[2] + 1)
			if #xr == 0 then return xr end
			k = (xr[2] + 1)
		until false
	end
	local results = { type = "list" }
	local k = 1 -- leftmost character of interest
	repeat
		local xl = { mw.ustring.find( s, lt, k, lp ) }
		if #xl == 0 then return results end
		k = xl[2] + 1
		local xr = snarf(k)
		if #xr &gt; 0 then
			results[1 + #results] = mw.ustring.sub( s, k, (xr[1] - 1) )
			k = xr[2] + 1
		end
	until false
end

local function splitrec_fn(s, rc)
	local ls
	if (#rc &gt; 1) and (stype(rc[2]) ~= "list") then
		ls = splitdelim_fn(s, rc[1], rc[2])
	else
		ls = splitsep_fn(s, rc[1])
	end
	ls.type = "list"
	rc = rc[#rc]
	if (stype(rc) == "list") then
		for k = 1, #ls do
			ls[k] = splitrec_fn(ls[k], rc)
		end
	end
	return ls
end

local function splitnest_fn(s, rc)
	if stype(s) == "string" then return splitrec_fn(s, rc) end
	local result = { type="list" }
	for k = 1, #s do
		result[k] = splitnest_fn(s[k], rc)
		if stype(result[k]) == "error" then return result[k] end
	end
	return result
end

local function split_fn(ls)
	local rc = { type = "list" }
	for k = 2, #ls do rc[k - 1] = ls[k] end
	return splitnest_fn(ls[1], rc)
end

local function join_tc(x)
	if (stype(x) == "list") and (#x &gt;= 1) and (stype(x[1]) == "string") and
		((#x == 1) or
		 ((#x == 2) and ((stype(x[2]) == "string") or (join_tc(x[2]) == ""))) or
		 ((#x == 3) and (stype(x[2]) == "string") and (join_tc(x[3]) == "")))
	then
		return ""
	else
		return "valid string-join descriptor"
	end
end

local function neststr_tc(x)
	if stype(x) == "list" then
		for k = 1, #x do
			if stype(x[k]) ~= "string" then
				local msg = neststr_tc(x[k])
				if msg ~= "" then return msg end
			end
		end
		return ""
	end
	return "tree of strings"
end

local function joinsep_fn(t, s)
	if #t == 0 then return "" end
	if stype(t[1]) == "string" then
		for k = 2, #t do if stype(t[k]) ~= "string" then
			return seterr("bad target for [op: join]: uneven tree depth")
		end end
		return table.concat( t, s )
	end
	for k = 2, #t do if stype(t[k]) == "string" then
		return seterr("bad target for [op: join]: uneven tree depth")
	end end
	local result = { type = "list" }
	for k = 1, #t do
		result[k] = joinsep_fn(t[k], s)
		if stype(result[k]) == "error" then return result[k] end
	end
	return result
end

local function joindelim_fn(t, lf, rg)
	if #t == 0 then return "" end
	if stype(t[1]) == "string" then
		for k = 2, #t do if stype(t[k]) ~= "string" then
			return seterr("bad target for [op: join]: uneven tree depth")
		end end
		return lf .. table.concat( t, (rg .. lf) ) .. rg
	end
	for k = 2, #t do if stype(t[k]) == "string" then
		return seterr("bad target for [op: join]: uneven tree depth")
	end end
	local result = { type = "list" }
	for k = 1, #t do
		result[k] = joindelim_fn(t[k], lf, rg)
		if stype(result[k]) == "error" then return result[k] end
	end
	return result
end

local function joinnest_fn(t, rc)
	if stype(t) == "error" then return t end
	if stype(t) == "string" then
		return seterr("bad target for [op: join]: tree not deep enough")
	end
	if #rc == 1 then
		return joinsep_fn(t, rc[1])
	elseif #rc == 3 then
		return joinnest_fn(joindelim_fn(t, rc[1], rc[2]), rc[3])
	elseif stype(rc[2]) == "string" then
		return joindelim_fn(t, rc[1], rc[2])
	else
		return joinnest_fn(joinsep_fn(t, rc[1]), rc[2])
	end
end

local function join_fn(ls)
	local rc = { type = "list" }
	for k = 2, #ls do rc[k - 1] = ls[k] end
	return joinnest_fn(ls[1], rc)
end

local function xformer_fn(pred, basis, succ, n)
	return wrap(nary_op(typed_op({ "fn", "fn", any_tc },
		make_op(function (ls, denv, depth)
			local leaf = ls[1]
			local parent = ls[2]
			local data = ls[3]
			local function xform(basis, data)
				local recurse = false
				if stype(data) == "list" then
					if stype(pred) ~= "fn" then
						recurse = true
					else
						recurse = combine( pred.comb, { type="list", data }, env, depth )
						if stype(recurse) ~= "boolean" then
							if stype(recurse) == "error" then return recurse end
							return seterr(
								"bad predicate result type to [op transform]: %s",
								stype(recurse))
						end
					end
				end
				local comb
				if recurse then
					local b2
					if stype(succ) == "fn"
					then b2 = combine( succ.comb, { type="list", basis }, env, depth )
					else b2 = basis
					end
					local d2 = { type="list" }
					for k = 1, #data do
						if k &lt;= n then
							d2[k] = data[k]
						else
							d2[k] = xform(b2, data[k])
							if stype(d2[k]) == "error" then return d2[k] end
						end
					end
					data = d2
					comb = parent.comb
				else
					comb = leaf.comb
				end
				if stype(succ) == "fn"
				then data = { type="list", basis, data }
				else data = { type="list",        data }
				end
				return combine( comb, data, env, depth )
			end
			return xform(basis, data)
		end, "transform", true)), 3))
end

--[[ standard environment ]]

local ground_env = {
	list = wrap(make_op(function (ls) return ls end, "list", true)),
	["+"] = wrap(typed_op(
		{ "number" }, make_op(function (ls)
			local sum = 0
			for k = 1, #ls do sum = sum + ls[k] end
			return sum
		end, "add", true),
		{ "string" }, function (ls)
			local s = {}
			for k = 1, #ls do s[k] = ls[k] end
			return table.concat(s)
		end,
		{ "boolean" }, function (ls)
			local sum = true
			for k = 1, #ls do sum = sum and ls[k] end
			return sum
		end,
		{ "list" }, function (ls)
			local x = { type = "list" }
			for j = 1, #ls do
				for k = 1, #ls[j] do
					x[1 + #x] = ls[j][k]
				end
			end
			return x
		end)),
	["*"] = wrap(typed_op({ "number" }, make_op(function (ls)
			local product = 1
			for k = 1, #ls do product = product * ls[k] end
			return product
		end, "multiply", true))),
	["-"] = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			local result = ls[1]
			for k = 2, #ls do result = result - ls[k] end
			return result
		end, "subtract", true)), -2)),
	["/"] = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			local result = ls[1]
			for k = 2, #ls do result = result / ls[k] end
			return result
		end, "divide", true)), -2)),
	["^"] = wrap(nary_op(typed_op({ "number" }, make_op(function  (ls)
			return ls[1] ^ ls[2]
		end, "exponentiation", true)), 2)),
	["\\"] = nary_op(make_op(lambda_fn, "\\", true), -1),
	abs = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			return math.abs(ls[1])
		end, "abs", true)), 1)),
	anchorencode = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return mw.uri.anchorEncode( ls[1] )
		end, "anchorencode", true)), 1)),
	["and?"] = make_op(and_fn, "and?", true),
	apply = wrap(nary_op(typed_op(
		{ "fn", "list" }, make_op(function (ls, env, depth)
			return combine(ls[1].comb, ls[2], env, depth)
		end, "apply", "true")), 2)),
	["boolean?"] = wrap(unary_pred(function (x)
			return stype(x) == "boolean"
		end, "boolean?")),
	["call?"] = wrap(unary_pred(function (x)
			return (stype(x) == "list") and (#x &gt; 0) and
				(stype(x[1]) == "string") and (x[1] == "call")
		end, "call?")),
	canonicalurl = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			if #ls == 1
			then return tostring( mw.uri.canonicalUrl( ls[1] ) )
			else return tostring( mw.uri.canonicalUrl( ls[1], ls[2] ) )
			end
		end, "canonicalurl", true)), 1, 2)),
	ceil = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			return math.ceil(ls[1])
		end, "ceil", true)), 1)),
	define = nary_op(make_op(function (ls, env, depth)
			if stype(ls[1]) ~= "symbol" then
				return seterr(
					"bad definiend to [op: define]: expected symbol, got %s",
					write_sexpr(ls[1]))
			end
			local x = eval(ls[2], env, depth)
			if stype(x) == "error" then return x end
			env[ls[1].name] = x
			while stype(x) == "fn" do x = x.comb end
			if stype(x) == "op" and x.name == nil then x.name = ls[1].name end
			return { type = "list" }
		end, "define", true), 2),
	["equal?"] = wrap(make_op(function (ls)
			if #ls &gt;= 2 then
				local t = write_sexpr(ls[1])
				for k = 2, #ls do
					if write_sexpr(ls[k]) ~= t then
						return false
					end
				end
			end
			return true
		end, "equal?", true)),
	filter = wrap(nary_op(typed_op({ "list", "fn" }, make_op(filter_fn,
		"filter", true)), -1)),
	find = wrap(nary_op(typed_op(
		{ "list", "fn" }, make_op(findprd_fn, "find", true),
		{ "string", "string" }, findstr_fn,
		{ "string", "pattern" }, findpat_fn
		), 2)),
	floor = wrap(nary_op(typed_op({ "number" }, make_op(function (ls)
			return math.floor(ls[1])
		end, "floor", true)), 1)),
	["fn?"] = wrap(unary_pred(function (x)
			return stype(x) == "fn"
		end, "fn?")),
	fullurl = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			if #ls == 1
			then return tostring( mw.uri.fullUrl( ls[1] ) )
			else return tostring( mw.uri.fullUrl( ls[1], ls[2] ) )
			end
		end, "fullurl", true)), 1, 2)),
	["ge?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &gt;= x2 end, "ge?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &gt;= x2 end))),
	['get-arg'] = wrap(nary_op(typed_op(
		{ "number" }, make_op(getarg_fn, "get-arg", true),
		{ "string" }, getarg_fn), 1)),
	['get-arg-expr'] = wrap(nary_op(typed_op(
		{ "number" }, make_op(getargexpr_fn, "get-arg-expr", true),
		{ "string" }, getargexpr_fn), 1)),
	['get-args'] = nary_op(make_op(function ()
			local ls = { type = "list" }
			for v, k in pairs( relevantFrame.args ) do
				ls[1 + #ls] = v
			end
			return ls
		end, "get-args"), 0),
	['get-coords'] = wrap(nary_op(typed_op({ cd_tc },make_op(function (ls)
			ls = ls[1]
			if stype(ls[1]) == "string" then ls = ls[2] end
			return { type="list", ls[1], ls[2] }
		end, "get-coords", true)), 1)),
	["get-items"] = wrap(nary_op(typed_op({ part_tc }, make_op(function (ls)
			ls = ls[1]
			local ls2 = { type="list" }
			for k = 3, #ls do ls2[k - 2] = ls[k] end
			return ls2
		end, "get-items", true)), 1)),
	["get-parts"] = wrap(nary_op(typed_op({ item_tc }, make_op(function (ls)
			ls = ls[1]
			local ls2 = { type="list" }
			for k = 3, #ls do ls2[k - 2] = ls[k] end
			return ls2
		end, "get-parts", true)), 1)),
	["get-sublist"] = wrap(nary_op(typed_op(
		{ "list", int_tc },
		make_op(getsublist_fn, "get-sublist", true)), 2, 3)),
	["get-substring"] = wrap(typed_op(
		{ "string", int_tc },
		nary_op(make_op(getsubstr_int_fn, "get-substring", true), 2, 3),
		{ "string", cd_tc },
		nary_op(make_op(getsubstr_cd_fn, "get-substring", true), 2),
		{ "string", cd_ls_tc },
		nary_op(make_op(getsubstr_ls_fn, "get-substring", true), 2))),
	["gt?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &gt; x2 end, "gt?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &gt; x2 end))),
	["if"] = nary_op(make_op(function (ls, env, depth)
			local test = eval(ls[1], env, depth)
			if stype(test) == "error" then return test end
			if stype(test) ~= "boolean" then
				return seterr(
					"bad test-result in [op: if]: %s",
					write_sexpr(test))
			elseif test then
				return eval(ls[2], env, depth)
			else
				return eval(ls[3], env, depth)
			end
		end, "if", true), 3),
	join = wrap(typed_op(
		{ neststr_tc, "string", join_tc },
		nary_op(make_op(join_fn, "join", true), 2, 3),
		{ neststr_tc, "string", "string", join_tc },
		nary_op(make_op(join_fn, "split", true), 3, 4))),
	lc = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:lc(ls[1])
		end, "lc", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:lc(ls[k]) end
			return r
		end), 1)),
	lcfirst = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:lcfirst(ls[1])
		end, "lcfirst", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:lcfirst(ls[k]) end
			return r
		end), 1)),
	["le?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &lt;= x2 end, "le?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &lt;= x2 end))),
	length = wrap(nary_op(typed_op(
		{ "list" }, make_op(function (ls)
			return #ls[1]
		end, "length", true),
		{ "string" }, function (ls)
			return mw.ustring.len( ls[1] )
		end), 1)),
	let = nary_op(typed_op({ let_tc, any_tc }, make_op(function (ls, env, depth)
			local p = ls[1][1]
			local v = eval( ls[1][2], env, depth )
			if stype(v) == "error" then return v end
			local body = { type = "list" }
			for k = 2, #ls do body[k - 1] = ls[k] end
			local e = {}
			e[p.name] = v
			setmetatable(e, { __index = env})
			return eval_seq(body, e, depth)
		end, "let", true)), -1),
	["link?"] = wrap(unary_pred(function (x)
			return (stype(x) == "list") and (#x &gt; 0) and
				(stype(x[1]) == "string") and (x[1] == "link")
		end, "link?")),
	["list?"] = wrap(unary_pred(function (x)
			return stype(x) == "list"
		end, "list?")),
	["lt?"] = wrap(typed_op(
		{ "number" }, binary_pred(function (x1, x2) return x1 &lt; x2 end, "lt?"),
		{ "string" }, binary_pred(function (x1, x2) return x1 &lt; x2 end))),
	map = wrap(nary_op(typed_op({ "fn", "list" }, make_op(
		function (ls, env, depth)
			local n = #ls[2]
			for k = 3, #ls do if #ls[k] &lt; n then n = #ls[k] end end
			local x = { type = "list" }
			for j = 1, n do
				local x2 = { type = "list" }
				for k = 2, #ls do x2[k - 1] = ls[k][j] end
				x[j] = combine( ls[1].comb, x2, env, depth )
				if stype(x[j]) == "error" then return x[j] end
			end
			return x
		end, "map", true)), -2)),
	["member?"] = wrap(nary_op(typed_op(
		{ any_tc, "list" }, make_op(member_fn, "member?", true)), 1, 2)),
	merge = wrap(nary_op(typed_op({ "fn", "list" }, make_op(
		function (ls, env, depth)
			local ks = {}
			for k = 2, #ls do ks[k] = 1 end
			local result = { type = "list" }
			while true do
				local j = nil
				for k = 2, #ls do
					if ks[k] &lt;= #ls[k] then
						if j == nil then j = k else
							local x = combine( ls[1].comb,
								{ ls[k][ks[k]], ls[j][ks[j]] }, env, depth )
							if stype(x) == "error" then return x end
							if x then j = k end
						end
					end
				end
				if j == nil then return result else
					result[#result + 1] = ls[j][ks[j]]
					ks[j] = ks[j] + 1
				end
			end
		end, "merge", true)), -2)),
	["not?"] = wrap(nary_op(typed_op({ "boolean" }, make_op(function (ls)
			return not ls[1]
		end, "not?", true)), 1)),
	nth = wrap(nary_op(typed_op({ "list", posint_tc }, make_op(function (ls)
			local x = ls[1]
			for k = 2, #ls do
				local n = ls[k]
				if #x &lt; n then
					return seterr(
						"bad index to [op: nth]: asked for %i, list length is %i",
						n, #x)
				end
				x = x[n]
				if (k &lt; #ls) and (stype(x) ~= "list") then
					return seterr("bad multi-index to [op: nth]: tree too shallow")
				end
			end
			return x
		end, "nth", true)), -2)),
	["number?"] = wrap(unary_pred(function (x)
			return stype(x) == "number"
		end, "number?")),
	["op?"] = wrap(unary_pred(function (x)
			return stype(x) == "op"
		end, "op?")),
	["or?"] = make_op(or_fn, "or?", true),
	["param?"] = wrap(unary_pred(function (x)
			return (stype(x) == "list") and (#x &gt; 0) and
				(stype(x[1]) == "string") and (x[1] == "param")
		end, "param?")),
	parse = wrap(nary_op(typed_op({ "string" }, make_op(parse_wiki,
		"parse", true)), 1)),
	pattern = wrap(nary_op(typed_op({ "string" }, make_op(function (ls)
			local p = ls[1]
			if #p == 0 then p = "[^%z%Z]" end -- disable null pattern
			return { type="pattern", pat=p }
		end, "pattern", true)), 1)),
	sequence = make_op(function (ls, env, depth)
			return eval_seq(ls, env, depth)
		end, "sequence", true),
	["set-sublist"] = wrap(nary_op(typed_op(
		{ "list", int_tc, int_tc, "list" },
		make_op(setsublist_fn, "set-sublist", true)), 4)),
	["set-substring"] = wrap(typed_op(
		{ "string", int_tc, int_tc, "string" },
		nary_op(make_op(function (ls)
				return setsubstr_ls(ls[1], { { ls[2], ls[3] } }, { ls[4] })
			end, "set-substring", true), 4),
		{ "string", cd_tc, "string" },
		nary_op(make_op(function (ls)
				return setsubstr_ls(ls[1], { cd_norm(ls[2]) }, { ls[3] })
			end, "set-substring", true), 3),
		{ "string", cd_ls_tc, str_ls_tc },
		nary_op(make_op(function (ls)
				local lsc = {}
				for k = 1, #ls[2] do lsc[k] = cd_norm(ls[2][k]) end
				return setsubstr_ls(ls[1], lsc, ls[3])
			end, "set-substring", true), 3)
		)),
	split = wrap(typed_op(
		{ strnest_tc, sorp_tc, split_tc },
		nary_op(make_op(split_fn, "split", true), 2, 3),
		{ strnest_tc, sorp_tc, sorp_tc, split_tc },
		nary_op(make_op(split_fn, "split", true), 3, 4))),
	["string?"] = wrap(unary_pred(function (x)
			return stype(x) == "string"
		end, "string?")),
	["symbol?"] = wrap(unary_pred(function (x)
			return stype(x) == "symbol"
		end, "symbol?")),
	["to-entity"] = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			local s = ls[1]
			if #s == 0 then return s end
			return "&amp;#" .. mw.ustring.codepoint(s, 1) .. ";"
		end, "to-entity", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do
				local s = ls[k]
				if #s == 0 then r[k] = s
				else r[k] = "&amp;#" .. mw.ustring.codepoint(s, 1) .. ";"
				end
			end
			return r
		end), 1)),
	["to-number"] = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			local n = tonumber(ls[1])
			if n == nil then return { type="list" } else return n end
		end, "to-number", true)), 1)),
	["to-string"] = wrap(nary_op(typed_op(
		{ "number" }, make_op(function (ls)
			return write_sexpr(ls[1])
		end, "to-string", true)),1)),
	transformer = wrap(typed_op(
		{ none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(    0,     0,     0,     0)
			end, "transformer", true),
		{ "fn", none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(ls[1],     0,     0,     0)
			end, "transformer", true),
		{ posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(    0,     0,     0, ls[1])
			end, "transformer", true),
		{ any_tc, "fn", none_tc },
		nary_op(make_op(function (ls, env, depth)
				return xformer_fn(    0, ls[1], ls[2],     0)
			end, "transformer", true), -2),
		{ "fn", posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(ls[1],     0,     0, ls[2])
			end, "transformer", true),
		{ "fn", any_tc, "fn", none_tc },
		nary_op(make_op(function (ls, env, depth)
				return xformer_fn(ls[1], ls[2], ls[3],     0)
			end, "transformer", true), -3),
		{ any_tc, "fn", posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(    0, ls[1], ls[2], ls[3])
			end, "transformer", true),
		{ "fn", any_tc, "fn", posint_tc, none_tc },
		make_op(function (ls, env, depth)
				return xformer_fn(ls[1], ls[2], ls[3], ls[4])
			end, "transformer", true)
		)),
	trim = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return mw.text.trim(ls[1])
		end, "trim", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = mw.text.trim(ls[k]) end
			return r
		end), 1)),
	uc = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:uc(ls[1])
		end, "uc", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:uc(ls[k]) end
			return r
		end), 1)),
	ucfirst = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			return lang:ucfirst(ls[1])
		end, "ucfirst", true),
		{ str_ls_tc }, function (ls)
			ls = ls[1]
			local r = { type = "list" }
			for k = 1, #ls do r[k] = lang:ucfirst(ls[k]) end
			return r
		end), 1)),
	urlencode = wrap(nary_op(typed_op(
		{ "string" }, make_op(function (ls)
			if #ls == 1 then ls[2] = 'QUERY' end
			return mw.uri.encode( ls[1], ls[2] )
		end, "urlencode", true)), 1, 2)),
	["wikilisp-version"] = wrap(nary_op(make_op(function (ls)
			return wikilispversion
		end, "wikilisp-version", true), 0)),
	write = wrap(nary_op(make_op(function (ls)
			return write_sexpr(ls[1])
		end, "write", true), 1))
}

local function make_standard_env()
	local standard_env = {}
	setmetatable(standard_env, { __index = ground_env})
	return standard_env
end

--[[ read-eval-print]]

function export.rep( frame )
	local t = frame.args[1]
	if t == nil then t = "" end
	return display_sexpr(
		eval_seq(
			text_to_sexpr(t),
			make_standard_env(),
			maxdepth))
end

function export.trep( frame )
	relevantFrame = frame:getParent()
	return export.rep(frame)
end

return export</text>
      <sha1>pj4vm8qb5jh0xuqywm926aeq903pofc</sha1>
    </revision>
  </page>
</mediawiki>
